# Onno ë°±ì—”ë“œ API ì„¤ê³„

**ë²„ì „**: 2.1 (Part 6.4 ì ‘ê·¼ì„± - ì ‘ê·¼ì„± ì„¤ì • API, í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤, ì ‘ê·¼ì„± Analytics)
**ì‘ì„±ì¼**: 2025-12-29 (ìµœì¢… ì—…ë°ì´íŠ¸: 2025-12-30)
**ëŒ€ìƒ**: ë°±ì—”ë“œ ê°œë°œì
**ëª©ì **: ì™„ì „í•œ API ëª…ì„¸ ë° ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì •ì˜
**Part 1.4 ì—…ë°ì´íŠ¸**: Notion OAuth ë° ì €ì¥ API ì¶”ê°€
**Part 1.5 ì—…ë°ì´íŠ¸**: ë¯¸íŒ… ì¤€ë¹„ ë°ì´í„° ë° ì•Œë¦¼ API ì¶”ê°€
**Part 2 ì—…ë°ì´íŠ¸**: Today í™”ë©´ ë°ì´í„° ë° ì¹´ë“œ ìƒíƒœ ê´€ë¦¬ API ì¶”ê°€
**Part 3 ì—…ë°ì´íŠ¸**: HUD ì‹¤ì‹œê°„ ì„¸ì…˜, ì•Œë¦¼ ì‹œìŠ¤í…œ, Gap ë¶„ì„, ì‚¬ìš©ì ì‘ë‹µ ì²˜ë¦¬ API ì¶”ê°€
**Part 4 ì—…ë°ì´íŠ¸**: í™•ì • ëª¨ë‹¬ API, ê²°ì • ì‚¬í•­ ê´€ë¦¬, Notion ì €ì¥ API, ì™„ë£Œ ì²˜ë¦¬ ì¶”ê°€
**Part 5 ì—…ë°ì´íŠ¸**: ì‹œë§¨í‹± ê²€ìƒ‰ API, ë²¡í„° ê²€ìƒ‰, ê²°ê³¼ ë­í‚¹, í•„í„°ë§, ê´€ë ¨ ë¯¸íŒ… API ì¶”ê°€
**Part 5.2 ì—…ë°ì´íŠ¸**: ì„¤ì • API, OAuth í†µí•© ê´€ë¦¬, ì•Œë¦¼ ì„¤ì •, í”„ë¡œí•„/ê³„ì • ê´€ë¦¬, ë°ì´í„° í”„ë¼ì´ë²„ì‹œ ì¶”ê°€
**Part 6.1 ì—…ë°ì´íŠ¸**: ì—ëŸ¬ ë¶„ë¥˜ ì‹œìŠ¤í…œ, ì—ëŸ¬ ì‘ë‹µ í‘œì¤€í™”, ë³µêµ¬ ì„œë¹„ìŠ¤, ì—ëŸ¬ ë¡œê¹…/í†µê³„, ì—ëŸ¬ ë¯¸ë“¤ì›¨ì–´, êµ­ì œí™”, ì„±ëŠ¥ ì§€í‘œ ì¶”ê°€
**Part 6.2 ì—…ë°ì´íŠ¸**: ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ API, ì§„í–‰ë¥  ì¶”ì  ì„œë¹„ìŠ¤, ì¥ê¸° ì‹¤í–‰ ì‘ì—… íŒ¨í„´, ë¡œë”© íŒíŠ¸ ë©”íƒ€ë°ì´í„°, í´ë§ API, ë¡œë”© ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì¶”ê°€
**Part 6.3 ì—…ë°ì´íŠ¸**: ë¹ˆ ìƒíƒœ ì½˜í…ì¸  API, ì²« ì‚¬ìš©ì ê°ì§€ ì„œë¹„ìŠ¤, ë¹ˆ ìƒíƒœ Analytics ì—”ë“œí¬ì¸íŠ¸, ë¹ˆ ìƒíƒœ DB ìŠ¤í‚¤ë§ˆ ì¶”ê°€
**Part 6.4 ì—…ë°ì´íŠ¸**: ì ‘ê·¼ì„± ì„¤ì • API, í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì„¤ì •, ì ‘ê·¼ì„± Analytics ì—”ë“œí¬ì¸íŠ¸, ì ‘ê·¼ì„± DB ìŠ¤í‚¤ë§ˆ ì¶”ê°€

---

## ğŸ“‹ ëª©ì°¨

1. [ê¸°ìˆ  ìŠ¤íƒ](#1-ê¸°ìˆ -ìŠ¤íƒ)
2. [ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#2-ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
3. [ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„](#3-ë°ì´í„°ë² ì´ìŠ¤-ì„¤ê³„)
4. [API ì—”ë“œí¬ì¸íŠ¸](#4-api-ì—”ë“œí¬ì¸íŠ¸)
5. [WebSocket ì´ë²¤íŠ¸](#5-websocket-ì´ë²¤íŠ¸)
6. [ì¸ì¦ ë° ì¸ê°€](#6-ì¸ì¦-ë°-ì¸ê°€)
7. [AI íŒŒì´í”„ë¼ì¸](#7-ai-íŒŒì´í”„ë¼ì¸)
8. [ì™¸ë¶€ í†µí•©](#8-ì™¸ë¶€-í†µí•©)
9. [ì—ëŸ¬ ì²˜ë¦¬](#9-ì—ëŸ¬-ì²˜ë¦¬)
10. [ì„±ëŠ¥ ë° í™•ì¥ì„±](#10-ì„±ëŠ¥-ë°-í™•ì¥ì„±)
11. [ë³´ì•ˆ](#11-ë³´ì•ˆ)
12. [ë°°í¬ ë° ëª¨ë‹ˆí„°ë§](#12-ë°°í¬-ë°-ëª¨ë‹ˆí„°ë§)

---

## 1. ê¸°ìˆ  ìŠ¤íƒ

### 1.1 Core Stack

```json
{
  "runtime": "Node.js 20 LTS",
  "framework": "Next.js 14 (App Router)",
  "language": "TypeScript 5.3",
  "orm": "Prisma 5.0",
  "validation": "Zod 3.22"
}
```

**ì„ íƒ ì´ìœ :**

```
Next.js 14:
â”œâ”€ API Routes (RESTful)
â”œâ”€ Server Actions (RPC-style)
â”œâ”€ Edge Runtime (ì €ì§€ì—°)
â”œâ”€ Vercel ë°°í¬ ê°„í¸
â””â”€ í”„ë¡ íŠ¸ì—”ë“œì™€ í†µí•© ê°€ëŠ¥ (í–¥í›„)

Prisma:
â”œâ”€ Type-safe ORM
â”œâ”€ Migration ê´€ë¦¬
â”œâ”€ Client ìë™ ìƒì„±
â””â”€ PostgreSQL ìµœì í™”

Zod:
â”œâ”€ Runtime validation
â”œâ”€ TypeScript íƒ€ì… ì¶”ë¡ 
â””â”€ API ì…ë ¥ ê²€ì¦
```

### 1.2 ë°ì´í„°ë² ì´ìŠ¤

```json
{
  "primary": "PostgreSQL 16 (Supabase)",
  "vector": "Pinecone (Serverless)",
  "cache": "Redis (Upstash)",
  "storage": "S3 Compatible (Supabase Storage)"
}
```

**ì„ íƒ ì´ìœ :**

```
PostgreSQL:
â”œâ”€ ACID ë³´ì¥ (ë°ì´í„° ë¬´ê²°ì„±)
â”œâ”€ JSON ì§€ì› (ìœ ì—°ì„±)
â”œâ”€ Full-text search
â””â”€ Supabase (ê´€ë¦¬í˜•, ë¬´ë£Œ tier)

Pinecone:
â”œâ”€ ë²¡í„° ê²€ìƒ‰ ì „ìš©
â”œâ”€ Serverless (ë¹„ìš© íš¨ìœ¨)
â”œâ”€ ë¹ ë¥¸ ê²€ìƒ‰ (<100ms)
â””â”€ OpenAI Embeddings í˜¸í™˜

Redis:
â”œâ”€ ì„¸ì…˜ ìºì‹±
â”œâ”€ API Rate Limiting
â””â”€ ì‹¤ì‹œê°„ ë°ì´í„° ì„ì‹œ ì €ì¥
```

### 1.3 AI & ML

```json
{
  "stt": "Deepgram Nova-2",
  "llm": "OpenAI GPT-4 Turbo",
  "embeddings": "OpenAI text-embedding-3-small",
  "alternative-llm": "Anthropic Claude 3.5 Sonnet"
}
```

### 1.4 ì‹¤ì‹œê°„ í†µì‹ 

```json
{
  "websocket": "Socket.IO 4.6",
  "pubsub": "Redis Pub/Sub"
}
```

### 1.5 ì™¸ë¶€ í†µí•©

```json
{
  "notion": "@notionhq/client 2.2",
  "salesforce": "jsforce 2.0",
  "google-calendar": "googleapis",
  "slack": "@slack/web-api 6.10"
}
```

---

## 2. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 2.1 ì „ì²´ êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Client Layer                         â”‚
â”‚  (Browser Extension, HUD, Web App)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚ REST API                  â”‚ WebSocket
             â”‚                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Next.js API Server                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ API Routes  â”‚  â”‚ WebSocket   â”‚  â”‚ Edge API    â”‚      â”‚
â”‚  â”‚ /api/*      â”‚  â”‚ Socket.IO   â”‚  â”‚ (Regional)  â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚         â”‚                â”‚                â”‚              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚          Service Layer (Business Logic)       â”‚      â”‚
â”‚  â”‚  - MeetingService                             â”‚      â”‚
â”‚  â”‚  - DecisionService                            â”‚      â”‚
â”‚  â”‚  - SearchService                              â”‚      â”‚
â”‚  â”‚  - IntegrationService                         â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                â”‚                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚   PostgreSQL   â”‚  â”‚  Pinecone   â”‚  â”‚    Redis    â”‚
â”‚   (Supabase)   â”‚  â”‚  (Vector)   â”‚  â”‚   (Cache)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  AI Pipeline                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ Deepgram â”‚  â”‚ GPT-4    â”‚  â”‚ Claude   â”‚             â”‚
â”‚  â”‚ (STT)    â”‚  â”‚ (LLM)    â”‚  â”‚ (LLM)    â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                External Integrations                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ Notion   â”‚  â”‚Salesforceâ”‚  â”‚ Slack    â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ìš”ì²­ íë¦„

```
ì‚¬ìš©ì ìš”ì²­
    â†“
Next.js API Route
    â†“
Middleware (ì¸ì¦, Rate Limit)
    â†“
Zod Validation (ì…ë ¥ ê²€ì¦)
    â†“
Service Layer (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
    â†“
Prisma Client (ë°ì´í„°ë² ì´ìŠ¤)
    â†“
Response (JSON)
```

---

## 3. ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„

### 3.1 Prisma Schema

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// User & Authentication
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String
  avatar        String?

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  meetings      Meeting[]
  integrations  Integration[]

  @@map("users")
}

// ============================================
// Meeting
// ============================================

model Meeting {
  id            String       @id @default(cuid())
  userId        String

  title         String
  company       String?
  platform      Platform     @default(ZOOM)
  status        MeetingStatus @default(SCHEDULED)

  startTime     DateTime
  endTime       DateTime?
  duration      Int?         // ë¶„ ë‹¨ìœ„

  participants  Json?        // { name, email, role }[]
  metadata      Json?        // { zoomId, meetUrl, etc }

  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  transcripts   Transcript[]
  decisions     Decision[]
  insights      Insight[]
  actions       Action[]

  @@index([userId, startTime])
  @@index([company])
  @@map("meetings")
}

enum Platform {
  ZOOM
  GOOGLE_MEET
  TEAMS
  OTHER
}

enum MeetingStatus {
  SCHEDULED
  ONGOING
  COMPLETED
  CANCELLED
}

// ============================================
// Transcript (ì‹¤ì‹œê°„ ì „ì‚¬)
// ============================================

model Transcript {
  id            String    @id @default(cuid())
  meetingId     String

  timestamp     DateTime  @default(now())
  speaker       String    // ë°œí™”ì ì´ë¦„ ë˜ëŠ” "Speaker 1"
  text          String    @db.Text
  confidence    Float?    // STT ì‹ ë¢°ë„ (0-1)

  meeting       Meeting   @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  @@index([meetingId, timestamp])
  @@map("transcripts")
}

// ============================================
// Decision (ê²°ì • 8ìš”ì†Œ)
// ============================================

model Decision {
  id            String    @id @default(cuid())
  meetingId     String

  goal          String?   @db.Text
  evidence      Json?     // { claim, source, timestamp }[]
  assumptions   Json?     // string[]
  risks         Json?     // { risk, impact, probability }[]
  unknowns      Json?     // string[]
  decision      String?   @db.Text
  actions       Json?     // â†’ Action í…Œì´ë¸”ë¡œ ì •ê·œí™”
  outcome       String?   @db.Text

  completeness  Int       @default(0) // 0-100 (8ìš”ì†Œ ì±„ì›Œì§„ ì •ë„)

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  meeting       Meeting   @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  @@index([meetingId])
  @@map("decisions")
}

// ============================================
// Insight (ì¸ì‚¬ì´íŠ¸ ì¶”ì¶œ)
// ============================================

model Insight {
  id            String       @id @default(cuid())
  meetingId     String

  type          InsightType
  content       String       @db.Text
  source        String?      // ë°œí™” ì›ë¬¸
  timestamp     DateTime     @default(now())
  confidence    Float?       // AI ì‹ ë¢°ë„

  metadata      Json?        // { speaker, context, etc }

  meeting       Meeting      @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  @@index([meetingId, type])
  @@map("insights")
}

enum InsightType {
  METRIC        // ìˆ«ì, ì§€í‘œ (MAU 10ë§Œ)
  CLAIM         // ì£¼ì¥, ì‚¬ì‹¤ (ê²½ìŸì‚¬ëŠ” 3ê³³)
  CONCERN       // ìš°ë ¤ ì‚¬í•­ (ë³´ì•ˆ ê±±ì •ë¨)
  QUESTION      // ë¯¸í•´ê²° ì§ˆë¬¸
  COMMITMENT    // ì•½ì† (ë‹¤ìŒ ì£¼ê¹Œì§€)
}

// ============================================
// Action (ì•¡ì…˜ ì•„ì´í…œ)
// ============================================

model Action {
  id            String       @id @default(cuid())
  meetingId     String

  title         String
  description   String?      @db.Text
  assignee      String?      // ë‹´ë‹¹ì ì´ë¦„
  assigneeEmail String?
  dueDate       DateTime?
  status        ActionStatus @default(PENDING)

  externalId    String?      // Notion, Salesforce ë“± ì™¸ë¶€ ID
  externalUrl   String?

  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  completedAt   DateTime?

  meeting       Meeting      @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  @@index([meetingId, status])
  @@index([assigneeEmail, status])
  @@map("actions")
}

enum ActionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// ============================================
// Alert (ê°­ ê°ì§€ ì•Œë¦¼)
// ============================================

model Alert {
  id            String     @id @default(cuid())
  meetingId     String

  level         Int        // 1, 2, 3
  title         String
  message       String     @db.Text
  suggestedQuestion String? @db.Text
  reason        Json?      // string[]

  shown         Boolean    @default(false)
  response      AlertResponse? // ì‚¬ìš©ì ì‘ë‹µ

  createdAt     DateTime   @default(now())

  @@index([meetingId, createdAt])
  @@map("alerts")
}

enum AlertResponse {
  ASKED         // ë¬¼ì–´ë´„
  DISMISSED     // ë¬´ì‹œ
  RISK_ACCEPTED // ìœ„í—˜ ê°ìˆ˜ (Level 3)
}

// ============================================
// Integration (ì™¸ë¶€ ë„êµ¬ ì—°ë™)
// ============================================

model Integration {
  id            String          @id @default(cuid())
  userId        String

  platform      IntegrationType
  enabled       Boolean         @default(true)

  credentials   String?         @db.Text // ì•”í˜¸í™”ëœ í† í°
  metadata      Json?           // { workspaceId, databaseId, etc }

  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, platform])
  @@map("integrations")
}

enum IntegrationType {
  NOTION
  SALESFORCE
  SLACK
  GOOGLE_CALENDAR
}

// ============================================
// Embedding (ë²¡í„° ê²€ìƒ‰ìš©)
// ============================================

model Embedding {
  id            String    @id @default(cuid())
  meetingId     String
  chunkIndex    Int       // ë¶„í• ëœ ì „ì‚¬ì˜ ì¸ë±ìŠ¤

  text          String    @db.Text
  vectorId      String    // Pineconeì˜ Vector ID

  createdAt     DateTime  @default(now())

  @@unique([meetingId, chunkIndex])
  @@index([meetingId])
  @@map("embeddings")
}
```

### 3.2 ì¸ë±ìŠ¤ ì „ëµ

```sql
-- ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œ ì¶”ê°€ ì¸ë±ìŠ¤

-- ë¯¸íŒ… ê²€ìƒ‰ (íšŒì‚¬ë³„, ë‚ ì§œë³„)
CREATE INDEX idx_meetings_company_date ON meetings(company, start_time DESC);

-- ì „ì‚¬ ì „ì²´ í…ìŠ¤íŠ¸ ê²€ìƒ‰
CREATE INDEX idx_transcripts_text_search ON transcripts USING gin(to_tsvector('english', text));

-- ì•¡ì…˜ ì•„ì´í…œ (ë‹´ë‹¹ìë³„ ë¯¸ì™„ë£Œ)
CREATE INDEX idx_actions_assignee_pending ON actions(assignee_email, status) WHERE status != 'COMPLETED';

-- ì•Œë¦¼ (ë¯¸íŒ…ë³„ ìµœì‹ ìˆœ)
CREATE INDEX idx_alerts_meeting_recent ON alerts(meeting_id, created_at DESC);
```

---

## 4. API ì—”ë“œí¬ì¸íŠ¸

### 4.1 Authentication

#### POST /api/auth/signup

```typescript
// Request
{
  "email": "user@example.com",
  "name": "í™ê¸¸ë™",
  "password": "secure_password"
}

// Response 201
{
  "user": {
    "id": "usr_123",
    "email": "user@example.com",
    "name": "í™ê¸¸ë™"
  },
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

#### POST /api/auth/login

```typescript
// Request
{
  "email": "user@example.com",
  "password": "secure_password"
}

// Response 200
{
  "user": { ... },
  "token": "..."
}
```

#### POST /api/auth/oauth/google

```typescript
// Request (Part 1.3: êµ¬ê¸€ ë¡œê·¸ì¸)
{
  "code": "google_oauth_code",
  "redirectUri": "https://onno.ai/auth/callback"
}

// Response 200
{
  "user": {
    "id": "usr_123",
    "email": "user@gmail.com",
    "name": "ë¯¼ìˆ˜",
    "provider": "google",
    "createdAt": "2025-12-29T10:00:00Z"
  },
  "token": "eyJhbGciOiJIUzI1NiIs...",
  "demoDataMigrated": true  // ì²´í—˜ ë°ì´í„° ì´ê´€ ì™„ë£Œ ì—¬ë¶€
}
```

#### POST /api/auth/oauth/github

```typescript
// Request (Part 1.3: GitHub ë¡œê·¸ì¸)
{
  "code": "github_oauth_code",
  "redirectUri": "https://onno.ai/auth/callback"
}

// Response 200
{
  "user": { ... },
  "token": "...",
  "demoDataMigrated": true
}
```

#### POST /api/auth/signup/email

```typescript
// Request (Part 1.3: ì´ë©”ì¼ ê°€ì…)
{
  "email": "user@example.com",
  "password": "secure_password",
  "termsAccepted": true
}

// Response 201
{
  "user": {
    "id": "usr_123",
    "email": "user@example.com",
    "provider": "email",
    "emailVerified": false,
    "createdAt": "2025-12-29T10:00:00Z"
  },
  "token": "eyJhbGciOiJIUzI1NiIs...",
  "demoDataMigrated": true
}

// Error 400
{
  "error": "EMAIL_ALREADY_EXISTS",
  "message": "ì´ë¯¸ ê°€ì…ëœ ì´ë©”ì¼ì…ë‹ˆë‹¤",
  "suggestedProvider": "google"  // í•´ë‹¹ ì´ë©”ì¼ë¡œ ê°€ì…í•œ ë°©ë²•
}
```

#### POST /api/auth/migrate-demo-data

```typescript
// Request (Part 1.3: ì²´í—˜ ë°ì´í„° ì´ê´€)
{
  "userId": "usr_123",
  "demoSessionId": "demo_session_abc123"  // ì¿ í‚¤ì—ì„œ ê°€ì ¸ì˜´
}

// Response 200
{
  "success": true,
  "migratedItems": {
    "meetings": 1,
    "decisions": 3,
    "insights": 5,
    "actions": 2
  }
}

// Response 404 (ì²´í—˜ ë°ì´í„° ì—†ìŒ or ë§Œë£Œ)
{
  "error": "DEMO_DATA_NOT_FOUND",
  "message": "ì²´í—˜ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (7ì¼ ê²½ê³¼ ë˜ëŠ” ì‚­ì œë¨)"
}
```

### 4.2 Analytics (ì„¤ì¹˜ ì¶”ì  ë° ê°€ì… ì´ë²¤íŠ¸)

#### POST /api/analytics/installation

```typescript
// Request (ì„¤ì¹˜ ì‹œë®¬ë ˆì´ì…˜ ì´ë²¤íŠ¸ ì¶”ì )
{
  "event": "started" | "completed" | "abandoned",
  "browser": "Chrome" | "Edge" | "Brave",
  "timestamp": "2025-12-29T10:00:00Z"
}

// Response 200
{
  "success": true
}
```

**ì£¼ì˜ì‚¬í•­:**
- ì‹¤ì œ íŒŒì¼ ë‹¤ìš´ë¡œë“œëŠ” ì—†ìŒ
- ë‹¨ìˆœ ì´ë²¤íŠ¸ ë¡œê¹…ë§Œ ìˆ˜í–‰
- ì‚¬ìš©ì ìœ ì… ê²½ë¡œ ë¶„ì„ìš©

#### POST /api/analytics/signup

```typescript
// Request (Part 1.3: íšŒì›ê°€ì… ì´ë²¤íŠ¸ ì¶”ì )
{
  "event": "signup_modal_shown" | "signup_attempted" | "signup_completed" | "signup_abandoned",
  "method": "google" | "github" | "email" | null,
  "timestamp": "2025-12-29T10:00:00Z",
  "metadata": {
    "demoCompleted": true,
    "timeFromDemoEnd": 1500,  // ë°€ë¦¬ì´ˆ (1.5ì´ˆ)
    "laterClicked": false
  }
}

// Response 200
{
  "success": true
}
```

**ì¶”ì  ì´ë²¤íŠ¸:**
- `signup_modal_shown`: ê°€ì… ëª¨ë‹¬ í‘œì‹œë¨
- `signup_attempted`: ê°€ì… ë²„íŠ¼ í´ë¦­ (êµ¬ê¸€/GitHub/ì´ë©”ì¼)
- `signup_completed`: ê°€ì… ì™„ë£Œ (ê³„ì • ìƒì„± ì„±ê³µ)
- `signup_abandoned`: "ë‚˜ì¤‘ì—" í´ë¦­ìœ¼ë¡œ ì´íƒˆ

**ëª©í‘œ ì§€í‘œ:**
- ëª¨ë‹¬ í‘œì‹œ â†’ ê°€ì… ì‹œë„: > 45%
- ê°€ì… ì‹œë„ â†’ ê°€ì… ì™„ë£Œ: > 93%
- ì „ì²´ ì „í™˜ìœ¨ (ë°ëª¨ ì™„ë£Œ â†’ ê°€ì…): > 42%

---

### 4.3 Meetings

#### GET /api/meetings

```typescript
// Query Parameters
?from=2025-01-01&to=2025-12-31&company=Aì‚¬&status=completed&limit=20&offset=0

// Response 200
{
  "meetings": [
    {
      "id": "mtg_123",
      "title": "Aì‚¬ 2ì°¨ íˆ¬ì ê²€í† ",
      "company": "Aì‚¬",
      "platform": "ZOOM",
      "status": "COMPLETED",
      "startTime": "2025-12-29T10:00:00Z",
      "endTime": "2025-12-29T11:00:00Z",
      "duration": 60,
      "participants": [
        { "name": "ê¹€ëŒ€í‘œ", "email": "ceo@acompany.com", "role": "CEO" }
      ],
      "summary": {
        "decisionCount": 3,
        "insightCount": 12,
        "actionCount": 5
      }
    }
  ],
  "total": 150,
  "limit": 20,
  "offset": 0
}
```

#### GET /api/meetings/:id

```typescript
// Response 200
{
  "meeting": {
    "id": "mtg_123",
    "title": "Aì‚¬ 2ì°¨ íˆ¬ì ê²€í† ",
    "company": "Aì‚¬",
    "platform": "ZOOM",
    "status": "COMPLETED",
    "startTime": "2025-12-29T10:00:00Z",
    "endTime": "2025-12-29T11:00:00Z",
    "duration": 60,
    "participants": [...],
    "transcript": [
      {
        "id": "tr_1",
        "timestamp": "2025-12-29T10:05:23Z",
        "speaker": "ê¹€ëŒ€í‘œ",
        "text": "ì €í¬ MAUëŠ” í˜„ì¬ 10ë§Œì…ë‹ˆë‹¤.",
        "confidence": 0.95
      }
    ],
    "decisions": [
      {
        "id": "dec_1",
        "goal": "Aì‚¬ íˆ¬ì ì§„í–‰ ì—¬ë¶€ ê²°ì •",
        "evidence": [...],
        "decision": "DD ì§„í–‰ í•©ì˜",
        "completeness": 75
      }
    ],
    "insights": [
      {
        "id": "ins_1",
        "type": "METRIC",
        "content": "MAU 10ë§Œ, ì›” ì„±ì¥ë¥  15%",
        "timestamp": "2025-12-29T10:05:23Z"
      }
    ],
    "actions": [
      {
        "id": "act_1",
        "title": "ì¬ë¬´ ìë£Œ ì œì¶œ",
        "assignee": "ê¹€ëŒ€í‘œ",
        "dueDate": "2025-01-10T00:00:00Z",
        "status": "PENDING"
      }
    ]
  }
}
```

#### POST /api/meetings

```typescript
// Request
{
  "title": "Bì‚¬ 1ì°¨ ë¯¸íŒ…",
  "company": "Bì‚¬",
  "platform": "GOOGLE_MEET",
  "startTime": "2025-12-30T14:00:00Z",
  "participants": [
    { "name": "ì´ëŒ€í‘œ", "email": "ceo@bcompany.com" }
  ]
}

// Response 201
{
  "meeting": {
    "id": "mtg_124",
    ...
  }
}
```

#### PATCH /api/meetings/:id

```typescript
// Request
{
  "status": "COMPLETED",
  "endTime": "2025-12-29T11:00:00Z"
}

// Response 200
{
  "meeting": { ... }
}
```

#### POST /api/meetings/:id/confirm

```typescript
// Request (íšŒì˜ í›„ í™•ì •)
{
  "decisions": [
    {
      "goal": "íˆ¬ì ì§„í–‰ ì—¬ë¶€",
      "decision": "DD ì§„í–‰",
      "completeness": 80
    }
  ],
  "actions": [
    {
      "title": "ì¬ë¬´ ìë£Œ ì œì¶œ",
      "assignee": "ê¹€ëŒ€í‘œ",
      "assigneeEmail": "ceo@acompany.com",
      "dueDate": "2025-01-10"
    }
  ],
  "insights": [
    {
      "type": "METRIC",
      "content": "MAU 10ë§Œ"
    }
  ]
}

// Response 200
{
  "success": true,
  "meeting": { ... },
  "integrations": {
    "notion": { "pageId": "..." },
    "salesforce": { "dealId": "..." },
    "slack": { "messageTs": "..." }
  }
}
```

### 4.3 Decisions

#### GET /api/decisions

```typescript
// Query: ?meetingId=mtg_123

// Response 200
{
  "decisions": [
    {
      "id": "dec_1",
      "meetingId": "mtg_123",
      "goal": "íˆ¬ì ì§„í–‰ ì—¬ë¶€ ê²°ì •",
      "evidence": [
        {
          "claim": "MAU 10ë§Œ",
          "source": "ê¹€ëŒ€í‘œ ë°œì–¸",
          "timestamp": "2025-12-29T10:05:23Z"
        }
      ],
      "assumptions": ["ì‹œì¥ ì„±ì¥ ì§€ì†"],
      "risks": [
        {
          "risk": "ê²½ìŸ ì‹¬í™”",
          "impact": "HIGH",
          "probability": 0.6
        }
      ],
      "unknowns": ["CAC ì±„ë„ë³„ ìƒì„¸"],
      "decision": "DD ì§„í–‰ í•©ì˜",
      "completeness": 75
    }
  ]
}
```

### 4.4 Search

#### POST /api/search

```typescript
// Request
{
  "query": "Aì‚¬ CAC",
  "filters": {
    "company": "Aì‚¬",
    "from": "2024-01-01",
    "to": "2025-12-31"
  },
  "limit": 10
}

// Response 200
{
  "results": [
    {
      "meetingId": "mtg_123",
      "meetingTitle": "Aì‚¬ 2ì°¨ ë¯¸íŒ…",
      "date": "2025-12-29",
      "excerpt": "CACëŠ” ì±„ë„ë³„ë¡œ ì˜¨ë¼ì¸ì´ $85, ì˜¤í”„ë¼ì¸ì´ $120ì…ë‹ˆë‹¤.",
      "highlights": [
        {
          "text": "CACëŠ” ì±„ë„ë³„ë¡œ ì˜¨ë¼ì¸ì´ $85",
          "start": 0,
          "end": 20
        }
      ],
      "relevance": 0.92
    }
  ],
  "total": 3
}
```

### 4.5 Actions

#### GET /api/actions

```typescript
// Query: ?status=PENDING&assignee=me&sort=dueDate

// Response 200
{
  "actions": [
    {
      "id": "act_1",
      "meetingId": "mtg_123",
      "meetingTitle": "Aì‚¬ 2ì°¨ ë¯¸íŒ…",
      "title": "ì¬ë¬´ ìë£Œ ì œì¶œ",
      "assignee": "ê¹€ëŒ€í‘œ",
      "assigneeEmail": "ceo@acompany.com",
      "dueDate": "2025-01-10T00:00:00Z",
      "status": "PENDING",
      "externalUrl": "https://notion.so/page123"
    }
  ]
}
```

#### PATCH /api/actions/:id

```typescript
// Request
{
  "status": "COMPLETED"
}

// Response 200
{
  "action": { ... }
}
```

### 4.6 Integrations

#### GET /api/integrations

```typescript
// Response 200
{
  "integrations": [
    {
      "id": "int_1",
      "platform": "NOTION",
      "enabled": true,
      "metadata": {
        "workspaceName": "ë‚´ ì›Œí¬ìŠ¤í˜ì´ìŠ¤",
        "databaseId": "db_123"
      }
    }
  ]
}
```

#### POST /api/integrations/:platform/connect

```typescript
// Request (Notion ì˜ˆì‹œ)
{
  "code": "oauth_code_from_notion"
}

// Response 200
{
  "integration": {
    "id": "int_1",
    "platform": "NOTION",
    "enabled": true
  }
}
```

#### DELETE /api/integrations/:id

```typescript
// Response 204 No Content
```

### 4.7 Notion í†µí•© (Part 1.4)

#### GET /api/auth/notion

```typescript
// OAuth ì‹œì‘ - ë¦¬ë‹¤ì´ë ‰íŠ¸ URL ë°˜í™˜
// Query: ?redirectUri=https://onno.ai/app

// Response: Notion OAuth í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
// â†’ https://api.notion.com/v1/oauth/authorize?client_id=...&redirect_uri=...
```

#### GET /api/auth/notion/callback

```typescript
// Notion OAuth ì½œë°± (Notionì´ í˜¸ì¶œ)
// Query: ?code=oauth_code&state=state_value

// ì²˜ë¦¬ íë¦„:
// 1. codeë¡œ access_token êµí™˜
// 2. Workspace ì •ë³´ ê°€ì ¸ì˜¤ê¸°
// 3. í† í° ì•”í˜¸í™” í›„ ì €ì¥
// 4. ë¶€ëª¨ ì°½ìœ¼ë¡œ ë©”ì‹œì§€ ì „ì†¡ í›„ íŒì—… ë‹«ê¸°

// Response: HTML (íŒì—… ë‹«ê¸° ìŠ¤í¬ë¦½íŠ¸)
/*
<script>
  window.opener.postMessage({
    type: 'NOTION_AUTH_SUCCESS',
    payload: {
      workspaceId: 'ws_123',
      workspaceName: 'ë¯¼ìˆ˜ì˜ ì›Œí¬ìŠ¤í˜ì´ìŠ¤',
      accessToken: 'secret_abc...'
    }
  }, '*');
  window.close();
</script>
*/
```

#### GET /api/integrations/notion/status

```typescript
// Notion ì—°ê²° ìƒíƒœ í™•ì¸
// Header: Authorization: Bearer {token}

// Response 200 (ì—°ê²°ë¨)
{
  "isConnected": true,
  "workspace": {
    "id": "ws_123",
    "name": "ë¯¼ìˆ˜ì˜ ì›Œí¬ìŠ¤í˜ì´ìŠ¤",
    "icon": "https://notion.so/icon.png"
  },
  "connectedAt": "2025-12-30T10:00:00Z"
}

// Response 200 (ë¯¸ì—°ê²°)
{
  "isConnected": false
}
```

#### POST /api/integrations/notion/save

```typescript
// ë¯¸íŒ… ë°ì´í„°ë¥¼ Notionì— ì €ì¥
// Header: Authorization: Bearer {token}

// Request
{
  "meetingId": "mtg_123",
  "meetingTitle": "Aì‚¬ 2ì°¨ íˆ¬ì ê²€í† ",
  "company": "Aì‚¬",
  "startTime": "2025-12-30T10:00:00Z",
  "endTime": "2025-12-30T11:00:00Z",
  "decisions": [
    {
      "content": "DD ì§„í–‰ í•©ì˜",
      "details": {
        "startDate": "2025-01-06",
        "assignee": "ê¹€ëŒ€í‘œ"
      }
    }
  ],
  "actions": [
    {
      "title": "ì¬ë¬´ ìë£Œ ì œì¶œ",
      "assignee": "ê¹€ëŒ€í‘œ",
      "dueDate": "2025-01-10"
    }
  ],
  "insights": [
    {
      "type": "METRIC",
      "content": "MAU 10ë§Œ, ì›” ì„±ì¥ë¥  15%"
    },
    {
      "type": "METRIC",
      "content": "ìœ ë£Œ ì „í™˜ìœ¨ 8%"
    }
  ]
}

// Response 201
{
  "success": true,
  "pageId": "page_abc123",
  "pageUrl": "https://notion.so/page_abc123",
  "savedAt": "2025-12-30T11:05:00Z"
}

// Response 401 (Notion ë¯¸ì—°ê²°)
{
  "error": "NOTION_NOT_CONNECTED",
  "message": "Notionì´ ì—°ê²°ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤"
}

// Response 500 (ì €ì¥ ì‹¤íŒ¨)
{
  "error": "NOTION_SAVE_FAILED",
  "message": "Notion ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤",
  "details": {
    "reason": "API rate limit exceeded"
  }
}
```

#### DELETE /api/integrations/notion/disconnect

```typescript
// Notion ì—°ê²° í•´ì œ
// Header: Authorization: Bearer {token}

// Response 200
{
  "success": true,
  "disconnectedAt": "2025-12-30T12:00:00Z"
}
```

#### POST /api/analytics/notion

```typescript
// Notion í†µí•© ì´ë²¤íŠ¸ ì¶”ì  (Part 1.4)
// Request
{
  "event": "notion_checkbox_shown" | "notion_checkbox_checked" | "notion_connect_clicked" |
           "notion_oauth_completed" | "notion_oauth_denied" | "notion_save_completed" | "notion_save_failed",
  "timestamp": "2025-12-30T10:00:00Z",
  "metadata": {
    "isConnected": boolean,
    "workspaceId": string | null,
    "errorType": string | null,
    "retryCount": number | null
  }
}

// Response 200
{
  "success": true
}
```

**Notion ì´ë²¤íŠ¸ ì¶”ì  ì§€í‘œ:**
```
ì²´í¬ë°•ìŠ¤ ì„ íƒë¥  = notion_checkbox_checked / notion_checkbox_shown
ëª©í‘œ: > 60%

ì—°ê²° ì „í™˜ìœ¨ = notion_oauth_completed / notion_connect_clicked
ëª©í‘œ: > 80%

ì €ì¥ ì„±ê³µë¥  = notion_save_completed / notion_save_attempted
ëª©í‘œ: > 95%
```

### 4.8 ë¯¸íŒ… ì¤€ë¹„ API (Part 1.5)

#### GET /meetings/:meetingId/prep

ë¯¸íŒ… ì¤€ë¹„ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.

```typescript
// Response
{
  "success": true,
  "data": {
    "meetingId": "mtg_abc123",
    "companyName": "Aì‚¬",
    "meetingNumber": 2,
    "meetingTime": "10:00",
    "scheduledAt": "2025-12-30T10:00:00Z",
    "minutesUntilMeeting": 15,
    "pastMeetings": [
      {
        "id": "mtg_prev1",
        "date": "2025-12-22",
        "meetingNumber": 1,
        "summary": [
          "MAU 10ë§Œ, ì›” ì„±ì¥ë¥  15%",
          "ì‹œë¦¬ì¦ˆA 50ì–µ í¬ë§",
          "ê²½ìŸì‚¬ Bì‚¬ ëŒ€ë¹„ ìš°ìœ„ì  ë…¼ì˜"
        ]
      }
    ],
    "unconfirmedItems": [
      {
        "id": "unconf_1",
        "label": "CAC (ê³ ê°íšë“ë¹„ìš©)",
        "description": "ì±„ë„ë³„ CAC ìƒì„¸ ìˆ˜ì¹˜ ë¯¸í™•ì¸"
      },
      {
        "id": "unconf_2",
        "label": "LTV (ê³ ê°ìƒì• ê°€ì¹˜)",
        "description": "ê³„ì‚° ë°©ì‹ ë° ê¸°ê°„ ë¯¸í™•ì¸"
      }
    ],
    "suggestedQuestions": [
      {
        "id": "q_1",
        "text": "CACëŠ” ì±„ë„ë³„ë¡œ ì–´ë–»ê²Œ ë‹¤ë¥¸ê°€ìš”?"
      },
      {
        "id": "q_2",
        "text": "LTV ê³„ì‚° ë°©ì‹ì´ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?"
      }
    ]
  }
}
```

#### POST /meetings/:meetingId/prep/complete

ë¯¸íŒ… ì¤€ë¹„ ì™„ë£Œë¥¼ ì €ì¥í•©ë‹ˆë‹¤.

```typescript
// Request
{
  "checkedQuestions": ["q_1", "q_2"],
  "userQuestions": ["íŒ€ ê·œëª¨ì™€ ì±„ìš© ê³„íšì€?"],
  "prepTimeSeconds": 95
}

// Response
{
  "success": true,
  "data": {
    "prepId": "prep_xyz789",
    "completedAt": "2025-12-30T09:50:00Z"
  }
}
```

#### POST /meetings/:meetingId/prep/skip

ì¤€ë¹„ ê±´ë„ˆë›°ê¸°ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤.

```typescript
// Request
{
  "reason": "time_constraint" // "time_constraint" | "not_needed" | "other"
}

// Response
{
  "success": true
}
```

#### ë¯¸íŒ… ì¤€ë¹„ ë°ì´í„° ìƒì„± ë¡œì§

```typescript
// services/meetingPrepService.ts

interface PrepDataGenerator {
  generatePrepData(meetingId: string): Promise<PrepData>;
}

export class MeetingPrepService implements PrepDataGenerator {
  constructor(
    private db: PrismaClient,
    private aiService: AIService,
    private cacheService: CacheService
  ) {}

  async generatePrepData(meetingId: string): Promise<PrepData> {
    // ìºì‹œ í™•ì¸ (10ë¶„ TTL)
    const cached = await this.cacheService.get(`prep:${meetingId}`);
    if (cached) return cached;

    const meeting = await this.db.meeting.findUnique({
      where: { id: meetingId },
      include: {
        company: true,
        user: true,
      },
    });

    if (!meeting) throw new Error('Meeting not found');

    // 1. ê³¼ê±° ë¯¸íŒ… ì¡°íšŒ
    const pastMeetings = await this.getPastMeetings(
      meeting.companyId,
      meeting.id
    );

    // 2. ë¯¸í™•ì¸ í•­ëª© ì¶”ì¶œ (ê³¼ê±° ë¯¸íŒ…ì—ì„œ í™•ì¸ ì•ˆ ëœ ê²ƒë“¤)
    const unconfirmedItems = await this.getUnconfirmedItems(pastMeetings);

    // 3. AI ì§ˆë¬¸ ìƒì„±
    const suggestedQuestions = await this.generateQuestions(
      meeting,
      pastMeetings,
      unconfirmedItems
    );

    // 4. ë¯¸íŒ…ê¹Œì§€ ë‚¨ì€ ì‹œê°„ ê³„ì‚°
    const minutesUntilMeeting = this.calculateMinutesUntil(meeting.scheduledAt);

    const prepData = {
      meetingId: meeting.id,
      companyName: meeting.company.name,
      meetingNumber: await this.getMeetingNumber(meeting.companyId, meeting.id),
      meetingTime: format(meeting.scheduledAt, 'HH:mm'),
      scheduledAt: meeting.scheduledAt.toISOString(),
      minutesUntilMeeting,
      pastMeetings,
      unconfirmedItems,
      suggestedQuestions,
    };

    // ìºì‹œ ì €ì¥
    await this.cacheService.set(`prep:${meetingId}`, prepData, 600); // 10ë¶„

    return prepData;
  }

  private async getPastMeetings(
    companyId: string,
    currentMeetingId: string
  ): Promise<PastMeeting[]> {
    const meetings = await this.db.meeting.findMany({
      where: {
        companyId,
        id: { not: currentMeetingId },
        status: 'COMPLETED',
      },
      orderBy: { createdAt: 'desc' },
      take: 5,
      include: {
        insights: true,
        decisions: true,
      },
    });

    return meetings.map((m, idx) => ({
      id: m.id,
      date: format(m.createdAt, 'yyyy-MM-dd'),
      meetingNumber: meetings.length - idx,
      summary: this.extractSummary(m.insights, m.decisions),
    }));
  }

  private async getUnconfirmedItems(
    pastMeetings: PastMeeting[]
  ): Promise<UnconfirmedItem[]> {
    // ì§€ë‚œ ë¯¸íŒ…ë“¤ì—ì„œ 'GAP' ìœ í˜•ì˜ ë¯¸í•´ê²° í•­ëª© ì¶”ì¶œ
    const unconfirmed = await this.db.decision.findMany({
      where: {
        meetingId: { in: pastMeetings.map((m) => m.id) },
        type: 'GAP',
        status: { not: 'CONFIRMED' },
      },
      take: 5,
    });

    return unconfirmed.map((item) => ({
      id: item.id,
      label: item.title,
      description: item.description,
    }));
  }

  private async generateQuestions(
    meeting: Meeting,
    pastMeetings: PastMeeting[],
    unconfirmedItems: UnconfirmedItem[]
  ): Promise<SuggestedQuestion[]> {
    // AIë¥¼ í™œìš©í•œ ë§ì¶¤í˜• ì§ˆë¬¸ ìƒì„±
    const prompt = this.buildQuestionPrompt(
      meeting,
      pastMeetings,
      unconfirmedItems
    );

    const response = await this.aiService.generate({
      model: 'gpt-4-turbo-preview',
      prompt,
      maxTokens: 500,
    });

    return this.parseQuestions(response);
  }

  private buildQuestionPrompt(
    meeting: Meeting,
    pastMeetings: PastMeeting[],
    unconfirmedItems: UnconfirmedItem[]
  ): string {
    return `
ë‹¤ìŒ ë¯¸íŒ…ì„ ìœ„í•œ í•µì‹¬ ì§ˆë¬¸ 2-3ê°œë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”.

íšŒì‚¬: ${meeting.company.name}
ë¯¸íŒ… ì°¨ìˆ˜: ${pastMeetings.length + 1}ì°¨
ì´ì „ ë¯¸íŒ… ìš”ì•½:
${pastMeetings.map((m) => `- ${m.date}: ${m.summary.join(', ')}`).join('\n')}

ë¯¸í™•ì¸ í•­ëª©:
${unconfirmedItems.map((i) => `- ${i.label}: ${i.description}`).join('\n')}

ì§ˆë¬¸ì€ ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ì‘ì„±:
1. [ì§ˆë¬¸ ë‚´ìš©]
2. [ì§ˆë¬¸ ë‚´ìš©]
    `.trim();
  }

  private calculateMinutesUntil(scheduledAt: Date): number {
    const now = new Date();
    const diff = scheduledAt.getTime() - now.getTime();
    return Math.max(0, Math.floor(diff / 60000));
  }
}
```

#### í‘¸ì‹œ ì•Œë¦¼ ìŠ¤ì¼€ì¤„ë§ (ë¯¸íŒ… 10ë¶„ ì „)

```typescript
// services/notificationService.ts

import { CronJob } from 'cron';
import webpush from 'web-push';

export class NotificationService {
  constructor(
    private db: PrismaClient,
    private pushService: PushService
  ) {
    // ë§¤ë¶„ ì‹¤í–‰ë˜ëŠ” í¬ë¡  ì‘ì—…
    new CronJob('* * * * *', this.checkUpcomingMeetings.bind(this)).start();
  }

  private async checkUpcomingMeetings(): Promise<void> {
    const now = new Date();
    const tenMinutesLater = new Date(now.getTime() + 10 * 60 * 1000);
    const elevenMinutesLater = new Date(now.getTime() + 11 * 60 * 1000);

    // 10ë¶„ í›„ ë¯¸íŒ… ì¡°íšŒ
    const upcomingMeetings = await this.db.meeting.findMany({
      where: {
        scheduledAt: {
          gte: tenMinutesLater,
          lt: elevenMinutesLater,
        },
        status: 'SCHEDULED',
        prepReminderSent: false,
      },
      include: {
        user: {
          include: {
            pushSubscriptions: true,
          },
        },
        company: true,
      },
    });

    for (const meeting of upcomingMeetings) {
      await this.sendPrepReminder(meeting);
      await this.db.meeting.update({
        where: { id: meeting.id },
        data: { prepReminderSent: true },
      });
    }
  }

  private async sendPrepReminder(meeting: Meeting & { user: User; company: Company }): Promise<void> {
    const payload = {
      title: 'ë¯¸íŒ… ì¤€ë¹„ ì•Œë¦¼',
      body: `${meeting.company.name} ë¯¸íŒ…ì´ 10ë¶„ í›„ ì‹œì‘ë©ë‹ˆë‹¤. ì¤€ë¹„í•˜ì‹œê² ì–´ìš”?`,
      icon: '/icons/prep-reminder.png',
      data: {
        type: 'prep_reminder',
        meetingId: meeting.id,
        url: `/meetings/${meeting.id}/prep`,
      },
    };

    for (const subscription of meeting.user.pushSubscriptions) {
      try {
        await this.pushService.send(subscription, payload);

        // ì´ë²¤íŠ¸ ë¡œê¹…
        await this.logEvent('prep_reminder_pushed', {
          meetingId: meeting.id,
          userId: meeting.userId,
        });
      } catch (error) {
        console.error('Push notification failed:', error);
      }
    }
  }
}
```

#### ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì¶”ê°€ (Part 1.5)

```prisma
// schema.prisma (ì¶”ê°€)

model MeetingPrep {
  id              String    @id @default(cuid())
  meetingId       String    @unique
  meeting         Meeting   @relation(fields: [meetingId], references: [id])

  // ì¤€ë¹„ ìƒíƒœ
  status          PrepStatus @default(PENDING)
  completedAt     DateTime?
  skippedAt       DateTime?
  skipReason      String?

  // ì„ íƒëœ ì§ˆë¬¸ë“¤
  checkedQuestions String[]
  userQuestions    String[]

  // ë©”íŠ¸ë¦­
  prepTimeSeconds Int?

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

enum PrepStatus {
  PENDING     // ì¤€ë¹„ ëŒ€ê¸°
  COMPLETED   // ì¤€ë¹„ ì™„ë£Œ
  SKIPPED     // ê±´ë„ˆëœ€
  EXPIRED     // ë¯¸íŒ… ì‹œì‘ìœ¼ë¡œ ë§Œë£Œ
}

// Meeting ëª¨ë¸ì— ì¶”ê°€
model Meeting {
  // ... ê¸°ì¡´ í•„ë“œë“¤

  // Part 1.5: ì¤€ë¹„ ê´€ë ¨
  prepReminderSent Boolean   @default(false)
  prep             MeetingPrep?
}
```

**ë¯¸íŒ… ì¤€ë¹„ ì´ë²¤íŠ¸ ì¶”ì  (Part 1.5):**

```typescript
// ì´ë²¤íŠ¸ íƒ€ì…
type PrepEventType =
  | 'prep_reminder_pushed'      // 10ë¶„ ì „ ì•Œë¦¼ ë°œì†¡
  | 'prep_reminder_clicked'     // ì•Œë¦¼ì—ì„œ ì§ì ‘ í´ë¦­
  | 'prep_card_shown'           // ì˜¤ëŠ˜ í™”ë©´ì—ì„œ ì¹´ë“œ í‘œì‹œ
  | 'prep_button_clicked'       // [ì¤€ë¹„í•˜ê¸°] í´ë¦­
  | 'prep_modal_opened'         // ëª¨ë‹¬ ì—´ë¦¼
  | 'prep_past_expanded'        // ì§€ë‚œ ë¯¸íŒ… ì„¹ì…˜ í™•ì¥
  | 'prep_unconfirmed_viewed'   // ë¯¸í™•ì¸ í•­ëª© í™•ì¸
  | 'prep_question_unchecked'   // AI ì§ˆë¬¸ ì²´í¬ í•´ì œ
  | 'prep_question_added'       // ì‚¬ìš©ì ì§ˆë¬¸ ì¶”ê°€
  | 'prep_completed'            // ì¤€ë¹„ ì™„ë£Œ í´ë¦­
  | 'prep_skipped'              // ë‚˜ì¤‘ì— í´ë¦­
  | 'prep_direct_start';        // ë°”ë¡œ ì‹œì‘ í´ë¦­

// POST /analytics/events ì˜ˆì‹œ
{
  "event": "prep_completed",
  "properties": {
    "meetingId": "mtg_abc123",
    "companyName": "Aì‚¬",
    "meetingNumber": 2,
    "pastMeetingCount": 1,
    "unconfirmedCount": 2,
    "suggestedQuestionCount": 2,
    "userQuestionCount": 1,
    "checkedQuestionCount": 3,
    "prepTimeSeconds": 95,
    "isQuickMode": false
  },
  "timestamp": "2025-12-30T09:50:00Z"
}
```

**Part 1.5 í•µì‹¬ ì§€í‘œ:**
```
ì¤€ë¹„ ì™„ë£Œìœ¨ = prep_completed / (prep_modal_opened - prep_direct_start)
ëª©í‘œ: > 70%

í‰ê·  ì¤€ë¹„ ì‹œê°„ = avg(prepTimeSeconds)
ëª©í‘œ: < 120ì´ˆ

AI ì§ˆë¬¸ ì±„íƒë¥  = (suggestedQuestionCount - uncheckedCount) / suggestedQuestionCount
ëª©í‘œ: > 80%

ê±´ë„ˆë›°ê¸° ë¹„ìœ¨ = prep_skipped / prep_modal_opened
ëª©í‘œ: < 30%
```

### 4.9 Today í™”ë©´ API (Part 2)

#### GET /api/today - Today í™”ë©´ ë°ì´í„° ì¡°íšŒ

```typescript
// Request
GET /api/today
Authorization: Bearer <token>
Query Parameters:
  - timezone: string (optional, default: 'Asia/Seoul')

// Response 200
{
  "success": true,
  "data": {
    "greeting": {
      "message": "ì¢‹ì€ ì•„ì¹¨ì´ì—ìš”, ë¯¼ìˆ˜ë‹˜ ğŸ‘‹",
      "date": "2025ë…„ 12ì›” 30ì¼ ì›”ìš”ì¼",
      "timeOfDay": "morning"
    },
    "sections": {
      "urgent": {
        "count": 2,
        "items": [
          {
            "id": "mtg_001",
            "type": "unconfirmed_decision",
            "companyName": "Aì‚¬",
            "meetingNumber": 2,
            "title": "ì–´ì œ Aì‚¬ ë¯¸íŒ… - ê²°ì • í™•ì • ì•ˆ ë¨",
            "missingFields": ["ë‹´ë‹¹ì", "ê¸°í•œ"],
            "estimatedTime": 3,
            "createdAt": "2025-12-29T10:00:00Z",
            "urgencyScore": 95
          }
        ]
      },
      "today": {
        "count": 3,
        "items": [
          {
            "id": "mtg_002",
            "companyName": "Aì‚¬",
            "meetingNumber": 2,
            "scheduledAt": "2025-12-30T10:00:00Z",
            "state": "urgent",
            "hasUnconfirmed": true,
            "unconfirmedCount": 2,
            "unconfirmedItems": ["CAC", "LTV"],
            "prepTimeEstimate": 120,
            "suggestedQuestions": [
              "CACëŠ” ì±„ë„ë³„ë¡œ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?",
              "LTV ê³„ì‚° ë°©ì‹ì´ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?"
            ]
          }
        ]
      },
      "later": {
        "count": 4,
        "items": []  // ì ‘íŒ ìƒíƒœì´ë¯€ë¡œ ë³„ë„ API í˜¸ì¶œ í•„ìš”
      }
    },
    "alerts": {
      "overload": false,
      "urgentPileup": false
    }
  },
  "metadata": {
    "totalMeetings": 9,
    "totalUnconfirmed": 3,
    "lastUpdated": "2025-12-30T08:00:00Z"
  }
}

// Response 401
{
  "success": false,
  "error": {
    "code": "UNAUTHORIZED",
    "message": "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤"
  }
}
```

#### GET /api/today/section/:type - ì„¹ì…˜ë³„ ë°ì´í„° ì¡°íšŒ

```typescript
// Request
GET /api/today/section/later?page=1&limit=10
Authorization: Bearer <token>

// Response 200
{
  "success": true,
  "data": {
    "items": [
      {
        "id": "mtg_005",
        "companyName": "Dì‚¬",
        "meetingNumber": 1,
        "scheduledAt": "2025-12-31T14:00:00Z",
        "state": "pending",
        "hasUnconfirmed": false
      }
    ],
    "pagination": {
      "page": 1,
      "limit": 10,
      "total": 4,
      "hasMore": false
    }
  }
}
```

#### PATCH /api/meetings/:id/state - ë¯¸íŒ… ì¹´ë“œ ìƒíƒœ ë³€ê²½

```typescript
// Request
PATCH /api/meetings/mtg_002/state
Authorization: Bearer <token>
Content-Type: application/json

{
  "state": "prepping",
  "metadata": {
    "triggeredFrom": "card_prep_clicked",
    "timeUntilMeeting": 35
  }
}

// Response 200
{
  "success": true,
  "data": {
    "id": "mtg_002",
    "previousState": "urgent",
    "newState": "prepping",
    "stateChangedAt": "2025-12-30T09:25:00Z",
    "validTransitions": ["ready"]
  }
}

// Response 400 (ì˜ëª»ëœ ìƒíƒœ ì „í™˜)
{
  "success": false,
  "error": {
    "code": "INVALID_STATE_TRANSITION",
    "message": "pending ìƒíƒœì—ì„œ readyë¡œ ì§ì ‘ ì „í™˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
    "validTransitions": ["urgent", "skipped"]
  }
}
```

#### TodayScreenService êµ¬í˜„

```typescript
// src/services/TodayScreenService.ts

import { prisma } from '@/lib/prisma';
import { addHours, startOfDay, endOfDay, isToday } from 'date-fns';

type SectionType = 'urgent' | 'today' | 'later';
type CardState = 'pending' | 'urgent' | 'prepping' | 'ready' | 'live' | 'skipped';

interface TodayScreenData {
  greeting: {
    message: string;
    date: string;
    timeOfDay: 'morning' | 'afternoon' | 'evening';
  };
  sections: Record<SectionType, {
    count: number;
    items: any[];
  }>;
  alerts: {
    overload: boolean;
    urgentPileup: boolean;
  };
}

export class TodayScreenService {
  // ì‹œê°„ëŒ€ë³„ ì¸ì‚¬ ë©”ì‹œì§€ ìƒì„±
  private getGreeting(userName: string, timezone: string): TodayScreenData['greeting'] {
    const now = new Date();
    const hour = parseInt(
      now.toLocaleString('en-US', { hour: 'numeric', hour12: false, timeZone: timezone })
    );

    let message: string;
    let timeOfDay: 'morning' | 'afternoon' | 'evening';

    if (hour >= 5 && hour < 12) {
      message = `ì¢‹ì€ ì•„ì¹¨ì´ì—ìš”, ${userName}ë‹˜ ğŸ‘‹`;
      timeOfDay = 'morning';
    } else if (hour >= 12 && hour < 18) {
      message = `ì¢‹ì€ ì˜¤í›„ì˜ˆìš”, ${userName}ë‹˜ ğŸ‘‹`;
      timeOfDay = 'afternoon';
    } else {
      message = `ì¢‹ì€ ì €ë…ì´ì—ìš”, ${userName}ë‹˜ ğŸ‘‹`;
      timeOfDay = 'evening';
    }

    const date = now.toLocaleDateString('ko-KR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      weekday: 'long',
      timeZone: timezone,
    });

    return { message, date, timeOfDay };
  }

  // ì¹´ë“œ ìƒíƒœ ê³„ì‚°
  private calculateCardState(meeting: any): CardState {
    if (meeting.isLive) return 'live';
    if (meeting.prepCompleted) return 'ready';
    if (meeting.prepStarted) return 'prepping';
    if (meeting.prepSkipped) return 'skipped';

    const hoursUntil = (new Date(meeting.scheduledAt).getTime() - Date.now()) / (1000 * 60 * 60);

    if (hoursUntil <= 24 && hoursUntil > 0 && meeting.hasUnconfirmed) {
      return 'urgent';
    }

    return 'pending';
  }

  // ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚°
  private calculateUrgencyScore(meeting: any): number {
    let score = 0;
    const hoursUntil = (new Date(meeting.scheduledAt).getTime() - Date.now()) / (1000 * 60 * 60);

    // ì‹œê°„ ê¸°ë°˜ ì ìˆ˜ (24ì‹œê°„ ì´ë‚´ = ë†’ì€ ì ìˆ˜)
    if (hoursUntil <= 1) score += 50;
    else if (hoursUntil <= 6) score += 40;
    else if (hoursUntil <= 12) score += 30;
    else if (hoursUntil <= 24) score += 20;

    // ë¯¸í™•ì¸ í•­ëª© ì ìˆ˜
    score += (meeting.unconfirmedCount || 0) * 10;

    // ë¯¸íŒ… íšŸìˆ˜ (ê¸°ì¡´ ê´€ê³„) ì ìˆ˜
    score += Math.min(meeting.meetingNumber || 1, 5) * 5;

    return score;
  }

  // Today í™”ë©´ ì „ì²´ ë°ì´í„° ì¡°íšŒ
  async getTodayData(userId: string, timezone = 'Asia/Seoul'): Promise<TodayScreenData> {
    const user = await prisma.user.findUnique({ where: { id: userId } });
    const now = new Date();
    const todayStart = startOfDay(now);
    const todayEnd = endOfDay(now);
    const next24h = addHours(now, 24);

    // ë¯¸íŒ… ì¡°íšŒ
    const meetings = await prisma.meeting.findMany({
      where: {
        userId,
        scheduledAt: { gte: now },
      },
      include: {
        company: true,
        decisions: { where: { confirmedAt: null } },
        prepSession: true,
      },
      orderBy: { scheduledAt: 'asc' },
    });

    // ë¯¸í™•ì • ê²°ì • ì¡°íšŒ (24ì‹œê°„ ì´ë‚´)
    const unconfirmedDecisions = await prisma.decision.findMany({
      where: {
        meeting: { userId },
        confirmedAt: null,
        createdAt: { gte: addHours(now, -24) },
      },
      include: { meeting: { include: { company: true } } },
    });

    // ë¯¸íŒ… ë°ì´í„° ë³€í™˜
    const enrichedMeetings = meetings.map(meeting => ({
      id: meeting.id,
      companyName: meeting.company?.name || 'Unknown',
      meetingNumber: meeting.meetingNumber,
      scheduledAt: meeting.scheduledAt,
      state: this.calculateCardState(meeting),
      hasUnconfirmed: meeting.decisions.length > 0,
      unconfirmedCount: meeting.decisions.length,
      unconfirmedItems: meeting.decisions.map(d => d.element),
      prepTimeEstimate: this.estimatePrepTime(meeting),
      suggestedQuestions: [], // AI ì§ˆë¬¸ì€ ë³„ë„ ì„œë¹„ìŠ¤ì—ì„œ ì¡°íšŒ
      urgencyScore: this.calculateUrgencyScore(meeting),
    }));

    // ê¸´ê¸‰ ì„¹ì…˜ (24ì‹œê°„ ë‚´ í™•ì • í•„ìš” + ë¯¸í™•ì • ê²°ì •)
    const urgentItems = [
      ...unconfirmedDecisions.map(d => ({
        id: d.id,
        type: 'unconfirmed_decision',
        companyName: d.meeting.company?.name,
        meetingNumber: d.meeting.meetingNumber,
        title: `${d.meeting.company?.name} ë¯¸íŒ… - ${d.element} í™•ì • ì•ˆ ë¨`,
        missingFields: this.getMissingFields(d),
        estimatedTime: 3,
        createdAt: d.createdAt,
        urgencyScore: 90,
      })),
      ...enrichedMeetings.filter(m =>
        m.state === 'urgent' ||
        (m.hasUnconfirmed && new Date(m.scheduledAt) <= next24h)
      ),
    ].sort((a, b) => b.urgencyScore - a.urgencyScore);

    // ì˜¤ëŠ˜ ë¯¸íŒ… ì„¹ì…˜
    const todayItems = enrichedMeetings.filter(m =>
      isToday(new Date(m.scheduledAt)) &&
      !urgentItems.find(u => u.id === m.id)
    );

    // ë‚˜ì¤‘ì— ì„¹ì…˜ (ì˜¤ëŠ˜ ì´í›„)
    const laterItems = enrichedMeetings.filter(m =>
      !isToday(new Date(m.scheduledAt)) &&
      !urgentItems.find(u => u.id === m.id)
    );

    // ì•Œë¦¼ ìƒíƒœ
    const alerts = {
      overload: todayItems.length >= 5,
      urgentPileup: urgentItems.length >= 5,
    };

    return {
      greeting: this.getGreeting(user?.name || 'ì‚¬ìš©ì', timezone),
      sections: {
        urgent: { count: urgentItems.length, items: urgentItems },
        today: { count: todayItems.length, items: todayItems },
        later: { count: laterItems.length, items: [] }, // ì ‘íŒ ìƒíƒœ
      },
      alerts,
    };
  }

  // ë¯¸íŒ… ìƒíƒœ ë³€ê²½
  async updateMeetingState(
    meetingId: string,
    newState: CardState,
    metadata?: Record<string, any>
  ) {
    const meeting = await prisma.meeting.findUnique({ where: { id: meetingId } });
    if (!meeting) throw new Error('Meeting not found');

    const currentState = this.calculateCardState(meeting);
    const validTransitions = this.getValidTransitions(currentState);

    if (!validTransitions.includes(newState)) {
      throw new Error(`Invalid transition from ${currentState} to ${newState}`);
    }

    // ìƒíƒœë³„ ì—…ë°ì´íŠ¸
    const updateData: any = { stateUpdatedAt: new Date() };

    switch (newState) {
      case 'prepping':
        updateData.prepStarted = true;
        updateData.prepStartedAt = new Date();
        break;
      case 'ready':
        updateData.prepCompleted = true;
        updateData.prepCompletedAt = new Date();
        break;
      case 'skipped':
        updateData.prepSkipped = true;
        updateData.prepSkippedAt = new Date();
        break;
      case 'live':
        updateData.isLive = true;
        updateData.startedAt = new Date();
        break;
    }

    const updated = await prisma.meeting.update({
      where: { id: meetingId },
      data: updateData,
    });

    // ì´ë²¤íŠ¸ ë¡œê¹…
    await prisma.event.create({
      data: {
        type: 'card_state_changed',
        meetingId,
        metadata: {
          previousState: currentState,
          newState,
          ...metadata,
        },
      },
    });

    return {
      id: updated.id,
      previousState: currentState,
      newState,
      stateChangedAt: updated.stateUpdatedAt,
      validTransitions: this.getValidTransitions(newState),
    };
  }

  // ìœ íš¨í•œ ìƒíƒœ ì „í™˜ ëª©ë¡
  private getValidTransitions(currentState: CardState): CardState[] {
    const transitions: Record<CardState, CardState[]> = {
      pending: ['urgent', 'skipped'],
      urgent: ['prepping', 'skipped'],
      prepping: ['ready'],
      ready: ['live', 'skipped'],
      live: [],
      skipped: ['prepping'],
    };
    return transitions[currentState] || [];
  }

  // ì¤€ë¹„ ì‹œê°„ ì¶”ì •
  private estimatePrepTime(meeting: any): number {
    let baseTime = 60; // ê¸°ë³¸ 1ë¶„

    // ë¯¸í™•ì¸ í•­ëª©ë‹¹ 30ì´ˆ ì¶”ê°€
    baseTime += (meeting.decisions?.length || 0) * 30;

    // ê³¼ê±° ë¯¸íŒ… ìˆìœ¼ë©´ ìš”ì•½ ì½ê¸° 30ì´ˆ
    if (meeting.meetingNumber > 1) baseTime += 30;

    return Math.min(baseTime, 300); // ìµœëŒ€ 5ë¶„
  }

  // ëˆ„ë½ í•„ë“œ ì¶”ì¶œ
  private getMissingFields(decision: any): string[] {
    const missing: string[] = [];
    if (!decision.assignee) missing.push('ë‹´ë‹¹ì');
    if (!decision.dueDate) missing.push('ê¸°í•œ');
    if (!decision.confirmedBy) missing.push('í™•ì •ì');
    return missing;
  }
}
```

#### Today í™”ë©´ ì´ë²¤íŠ¸ ë¡œê¹…

```typescript
// src/types/today-events.ts

type TodayEventType =
  | 'today_screen_viewed'       // Today í™”ë©´ ì§„ì…
  | 'today_section_expanded'    // ì„¹ì…˜ í¼ì¹¨
  | 'today_section_collapsed'   // ì„¹ì…˜ ì ‘ìŒ
  | 'today_card_clicked'        // ì¹´ë“œ í´ë¦­
  | 'today_empty_state_shown'   // ë¹ˆ ìƒíƒœ í‘œì‹œ
  | 'today_refresh_triggered'   // ìƒˆë¡œê³ ì¹¨
  | 'today_overload_shown';     // ê³¼ë¶€í•˜ ê²½ê³  í‘œì‹œ

type CardEventType =
  | 'card_viewed'              // ì¹´ë“œ ë·°í¬íŠ¸ ì§„ì…
  | 'card_clicked'             // ì¹´ë“œ í´ë¦­
  | 'card_prep_clicked'        // [ì¤€ë¹„í•˜ê¸°] í´ë¦­
  | 'card_start_clicked'       // [ë°”ë¡œ ì‹œì‘] í´ë¦­
  | 'card_state_changed'       // ìƒíƒœ ì „í™˜
  | 'card_urgent_triggered'    // ê¸´ê¸‰ ìƒíƒœ ì „í™˜
  | 'card_pulse_shown';        // í„ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ í‘œì‹œ

interface TodayEventPayload {
  userId: string;
  sessionId: string;
  event: TodayEventType | CardEventType;
  metadata: {
    // Today í™”ë©´ ì´ë²¤íŠ¸
    urgentCount?: number;
    todayCount?: number;
    laterCount?: number;
    totalUnconfirmed?: number;
    timeOfDay?: 'morning' | 'afternoon' | 'evening';
    sectionType?: string;

    // ì¹´ë“œ ì´ë²¤íŠ¸
    cardId?: string;
    meetingId?: string;
    companyName?: string;
    meetingNumber?: number;
    cardState?: CardState;
    previousState?: CardState;
    newState?: CardState;
    timeUntilMeeting?: number;
    hasUnconfirmed?: boolean;
    unconfirmedCount?: number;
  };
  timestamp: string;
}

// ì´ë²¤íŠ¸ ë¡œê¹… ìƒ˜í”Œ
const todayScreenViewedEvent: TodayEventPayload = {
  userId: "usr_123",
  sessionId: "sess_abc",
  event: "today_screen_viewed",
  metadata: {
    urgentCount: 2,
    todayCount: 3,
    laterCount: 4,
    totalUnconfirmed: 5,
    timeOfDay: "morning"
  },
  timestamp: "2025-12-30T08:00:00Z"
};

const cardPrepClickedEvent: TodayEventPayload = {
  userId: "usr_123",
  sessionId: "sess_abc",
  event: "card_prep_clicked",
  metadata: {
    cardId: "card_001",
    meetingId: "mtg_002",
    companyName: "Aì‚¬",
    meetingNumber: 2,
    cardState: "urgent",
    timeUntilMeeting: 35,
    hasUnconfirmed: true,
    unconfirmedCount: 2
  },
  timestamp: "2025-12-30T09:25:00Z"
};
```

**Part 2 í•µì‹¬ ì§€í‘œ:**
```
í‰ê·  ìŠ¤ìº” ì‹œê°„ = avg(sessionDuration WHERE today_screen_viewed)
ëª©í‘œ: < 10ì´ˆ

ê¸´ê¸‰ í•­ëª© ì²˜ë¦¬ìœ¨ = count(urgent_completed) / count(urgent_shown)
ëª©í‘œ: > 80%

ì¤€ë¹„í•˜ê¸° í´ë¦­ë¥  = count(card_prep_clicked) / count(card_viewed)
ëª©í‘œ: > 70%

ê±´ë„ˆë›°ê¸°ìœ¨ = count(card_start_clicked) / count(card_viewed WHERE hasUnconfirmed)
ëª©í‘œ: < 30%

í‰ê·  í–‰ë™ê¹Œì§€ ì‹œê°„ = avg(timeToClick WHERE card_viewed to card_prep_clicked)
ëª©í‘œ: < 5ì´ˆ
```

### 4.10 HUD ì„¸ì…˜ API (Part 3.1)

#### POST /api/hud/session - HUD ì„¸ì…˜ ì‹œì‘

```typescript
// Request
POST /api/hud/session
Authorization: Bearer <token>
Content-Type: application/json

{
  "platform": "zoom",  // "zoom" | "meet" | "teams"
  "meetingUrl": "https://zoom.us/j/123456789",
  "autoStarted": true,
  "detectedAt": "2025-12-30T10:00:00Z"
}

// Response 201
{
  "success": true,
  "data": {
    "sessionId": "hud_sess_001",
    "meetingId": "mtg_003",
    "platform": "zoom",
    "startedAt": "2025-12-30T10:00:05Z",
    "status": "active",
    "settings": {
      "alertLevels": [1, 2, 3],
      "opacityDefault": 0.8,
      "autoHideAfter": 300000  // 5ë¶„
    }
  }
}

// Response 409 (ì´ë¯¸ í™œì„± ì„¸ì…˜ ì¡´ì¬)
{
  "success": false,
  "error": {
    "code": "SESSION_ALREADY_ACTIVE",
    "message": "ì´ë¯¸ í™œì„±í™”ëœ HUD ì„¸ì…˜ì´ ìˆìŠµë‹ˆë‹¤",
    "activeSessionId": "hud_sess_000"
  }
}
```

#### GET /api/hud/session/:id - HUD ì„¸ì…˜ ì¡°íšŒ

```typescript
// Request
GET /api/hud/session/hud_sess_001
Authorization: Bearer <token>

// Response 200
{
  "success": true,
  "data": {
    "sessionId": "hud_sess_001",
    "meetingId": "mtg_003",
    "platform": "zoom",
    "startedAt": "2025-12-30T10:00:05Z",
    "status": "active",
    "duration": 1800,  // ì´ˆ ë‹¨ìœ„
    "stats": {
      "totalAlerts": { "level1": 5, "level2": 2, "level3": 0 },
      "alertsActioned": 6,
      "alertsDeferred": 1,
      "alertsIgnored": 0,
      "gapsIdentified": 3,
      "gapsResolved": 2,
      "idleRatio": 0.97
    },
    "deferredItems": [
      {
        "id": "def_001",
        "alertId": "alt_003",
        "question": "ê²°ì œ ì¡°ê±´ì€ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?",
        "category": "gap",
        "deferredAt": "2025-12-30T10:15:00Z"
      }
    ]
  }
}
```

#### PATCH /api/hud/session/:id/end - HUD ì„¸ì…˜ ì¢…ë£Œ

```typescript
// Request
PATCH /api/hud/session/hud_sess_001/end
Authorization: Bearer <token>
Content-Type: application/json

{
  "endReason": "meeting_ended",  // "meeting_ended" | "user_stopped" | "error"
  "summary": {
    "totalDuration": 3600,
    "idleTime": 3480,
    "alertTime": 120
  }
}

// Response 200
{
  "success": true,
  "data": {
    "sessionId": "hud_sess_001",
    "endedAt": "2025-12-30T11:00:05Z",
    "finalStats": {
      "totalAlerts": { "level1": 8, "level2": 3, "level3": 1 },
      "alertsActioned": 10,
      "alertsDeferred": 2,
      "alertsIgnored": 0,
      "gapsIdentified": 5,
      "gapsResolved": 4,
      "risksAccepted": 0,
      "idleRatio": 0.97
    },
    "pendingActions": [
      {
        "type": "deferred_question",
        "count": 2,
        "items": ["ê²°ì œ ì¡°ê±´ì€ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?", "ê³„ì•½ ê¸°ê°„ í˜‘ìƒ ê°€ëŠ¥í•œê°€ìš”?"]
      }
    ]
  }
}
```

### 4.11 ì•Œë¦¼ ì‹œìŠ¤í…œ API (Part 3.3)

#### GET /api/hud/alerts - í˜„ì¬ ì„¸ì…˜ ì•Œë¦¼ ëª©ë¡

```typescript
// Request
GET /api/hud/alerts?sessionId=hud_sess_001&level=2,3
Authorization: Bearer <token>

// Response 200
{
  "success": true,
  "data": {
    "alerts": [
      {
        "id": "alt_001",
        "level": 2,
        "category": "gap",
        "icon": "ğŸ’¡",
        "title": "ì •ë³´ ëˆ„ë½ ê°ì§€",
        "message": "ì˜ˆì‚° ë²”ìœ„ì— ëŒ€í•œ ì •ë³´ê°€ í™•ì¸ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤",
        "suggestedQuestion": "ì˜ˆì‚° ë²”ìœ„ê°€ ì–´ëŠ ì •ë„ ë˜ì‹¤ê¹Œìš”?",
        "reason": [
          "ê°€ê²© ë…¼ì˜ê°€ ì§„í–‰ ì¤‘ì´ë‚˜ ì˜ˆì‚° ì–¸ê¸‰ ì—†ìŒ",
          "ê²°ì •ê¶Œìê°€ ì˜ˆì‚° ìŠ¹ì¸ í•„ìš”í•˜ë‹¤ê³  ì–¸ê¸‰"
        ],
        "timestamp": "2025-12-30T10:15:00Z",
        "status": "pending",  // "pending" | "actioned" | "deferred" | "ignored"
        "expiresAt": "2025-12-30T10:15:10Z"
      }
    ],
    "pendingCount": 1,
    "totalCount": 7
  }
}
```

#### POST /api/hud/alerts/:id/action - ì•Œë¦¼ì— ëŒ€í•œ ì‚¬ìš©ì ì‘ë‹µ

```typescript
// Request
POST /api/hud/alerts/alt_001/action
Authorization: Bearer <token>
Content-Type: application/json

{
  "action": "ask",  // "ask" | "defer" | "dismiss" | "accept_risk"
  "metadata": {
    "responseTime": 2500,  // ms
    "questionCopied": true
  }
}

// Response 200 (ask)
{
  "success": true,
  "data": {
    "alertId": "alt_001",
    "action": "ask",
    "result": {
      "status": "question_copied",
      "question": "ì˜ˆì‚° ë²”ìœ„ê°€ ì–´ëŠ ì •ë„ ë˜ì‹¤ê¹Œìš”?",
      "followUp": {
        "trackAnswer": true,
        "expectedKeywords": ["ì–µ", "ë§Œì›", "ì˜ˆì‚°", "ë¹„ìš©"]
      }
    }
  }
}

// Response 200 (defer)
{
  "success": true,
  "data": {
    "alertId": "alt_001",
    "action": "defer",
    "result": {
      "deferredItemId": "def_002",
      "addedToDeferredList": true,
      "currentDeferredCount": 3
    }
  }
}

// Response 200 (accept_risk - Level 3ë§Œ)
{
  "success": true,
  "data": {
    "alertId": "alt_001",
    "action": "accept_risk",
    "result": {
      "riskAccepted": true,
      "warningAcknowledged": true,
      "riskCategory": "contract_terms"
    }
  }
}
```

### 4.12 Gap ë¶„ì„ API (Part 3.3)

#### GET /api/meetings/:id/gaps - ë¯¸íŒ… ì¤‘ Gap ë¶„ì„ ê²°ê³¼

```typescript
// Request
GET /api/meetings/mtg_003/gaps
Authorization: Bearer <token>

// Response 200
{
  "success": true,
  "data": {
    "meetingId": "mtg_003",
    "analyzedAt": "2025-12-30T10:30:00Z",
    "gaps": [
      {
        "id": "gap_001",
        "category": "budget",
        "severity": "high",
        "description": "ì˜ˆì‚° ë²”ìœ„ ë¯¸í™•ì¸",
        "detectedAt": "2025-12-30T10:15:00Z",
        "status": "resolved",
        "resolvedAt": "2025-12-30T10:18:00Z",
        "resolvedBy": {
          "type": "user_question",
          "alertId": "alt_001"
        }
      },
      {
        "id": "gap_002",
        "category": "timeline",
        "severity": "medium",
        "description": "ë„ì… ì‹œì  ë¯¸í™•ì •",
        "detectedAt": "2025-12-30T10:25:00Z",
        "status": "pending",
        "suggestedQuestion": "ë„ì… ì˜ˆì • ì‹œì ì´ ì–¸ì œì¯¤ ë˜ì‹¤ê¹Œìš”?"
      }
    ],
    "summary": {
      "total": 5,
      "resolved": 3,
      "pending": 2,
      "resolutionRate": 0.6
    }
  }
}
```

### 4.13 ì—°ê¸° í•­ëª© API (Part 3.4)

#### GET /api/hud/deferred - ì—°ê¸°ëœ í•­ëª© ëª©ë¡

```typescript
// Request
GET /api/hud/deferred?sessionId=hud_sess_001
Authorization: Bearer <token>

// Response 200
{
  "success": true,
  "data": {
    "items": [
      {
        "id": "def_001",
        "alertId": "alt_003",
        "question": "ê²°ì œ ì¡°ê±´ì€ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?",
        "category": "gap",
        "priority": "high",
        "deferredAt": "2025-12-30T10:15:00Z",
        "suggestedAskTime": "meeting_end",
        "context": {
          "relatedTranscript": "ê°€ê²©ì€ í˜‘ì˜ ê°€ëŠ¥í•©ë‹ˆë‹¤",
          "transcriptTimestamp": "2025-12-30T10:14:30Z"
        }
      }
    ],
    "count": 2
  }
}
```

#### DELETE /api/hud/deferred/:id - ì—°ê¸° í•­ëª© ì œê±° (í•´ê²°ë¨)

```typescript
// Request
DELETE /api/hud/deferred/def_001
Authorization: Bearer <token>
Content-Type: application/json

{
  "reason": "resolved",  // "resolved" | "asked" | "not_relevant"
  "metadata": {
    "resolvedAt": "2025-12-30T10:45:00Z",
    "resolvedBy": "user_action"
  }
}

// Response 200
{
  "success": true,
  "data": {
    "id": "def_001",
    "status": "resolved",
    "remainingCount": 1
  }
}
```

### 4.14 HUD ë¶„ì„ ì´ë²¤íŠ¸ API (Part 3)

#### POST /api/analytics/hud - HUD ì´ë²¤íŠ¸ ë¡œê¹…

```typescript
// Request
POST /api/analytics/hud
Authorization: Bearer <token>
Content-Type: application/json

{
  "sessionId": "hud_sess_001",
  "events": [
    {
      "type": "alert_shown",
      "alertId": "alt_001",
      "level": 2,
      "category": "gap",
      "timestamp": "2025-12-30T10:15:00Z"
    },
    {
      "type": "alert_ask_clicked",
      "alertId": "alt_001",
      "timeToAction": 2500,
      "timestamp": "2025-12-30T10:15:02.5Z"
    },
    {
      "type": "gap_resolved",
      "gapId": "gap_001",
      "alertId": "alt_001",
      "timestamp": "2025-12-30T10:18:00Z"
    }
  ]
}

// Response 200
{
  "success": true,
  "data": {
    "processedCount": 3,
    "sessionStats": {
      "alertsShown": 7,
      "alertsActioned": 6,
      "gapsResolved": 3
    }
  }
}
```

#### HUDSessionService êµ¬í˜„

```typescript
// src/services/HUDSessionService.ts

import { prisma } from '@/lib/prisma';
import { redis } from '@/lib/redis';
import { GapAnalysisService } from './GapAnalysisService';
import { AlertGeneratorService } from './AlertGeneratorService';

type Platform = 'zoom' | 'meet' | 'teams';
type AlertLevel = 1 | 2 | 3;
type AlertCategory = 'gap' | 'decision' | 'action' | 'risk';
type AlertAction = 'ask' | 'defer' | 'dismiss' | 'accept_risk';
type SessionStatus = 'active' | 'paused' | 'ended';

interface HUDSessionStats {
  totalAlerts: { level1: number; level2: number; level3: number };
  alertsActioned: number;
  alertsDeferred: number;
  alertsIgnored: number;
  gapsIdentified: number;
  gapsResolved: number;
  risksAccepted: number;
  idleRatio: number;
}

interface DeferredItem {
  id: string;
  alertId: string;
  question: string;
  category: AlertCategory;
  deferredAt: Date;
}

export class HUDSessionService {
  private gapAnalysis: GapAnalysisService;
  private alertGenerator: AlertGeneratorService;

  constructor() {
    this.gapAnalysis = new GapAnalysisService();
    this.alertGenerator = new AlertGeneratorService();
  }

  // Part 3.1: ì„¸ì…˜ ì‹œì‘
  async startSession(
    userId: string,
    platform: Platform,
    meetingUrl: string,
    autoStarted: boolean
  ) {
    // ê¸°ì¡´ í™œì„± ì„¸ì…˜ í™•ì¸
    const existingSession = await prisma.hudSession.findFirst({
      where: { userId, status: 'active' }
    });

    if (existingSession) {
      throw new Error('SESSION_ALREADY_ACTIVE');
    }

    // ë¯¸íŒ… ID ë§¤ì¹­ ë˜ëŠ” ìƒì„±
    const meeting = await this.findOrCreateMeeting(userId, platform, meetingUrl);

    // ì„¸ì…˜ ìƒì„±
    const session = await prisma.hudSession.create({
      data: {
        userId,
        meetingId: meeting.id,
        platform,
        meetingUrl,
        autoStarted,
        status: 'active',
        startedAt: new Date(),
        stats: {
          totalAlerts: { level1: 0, level2: 0, level3: 0 },
          alertsActioned: 0,
          alertsDeferred: 0,
          alertsIgnored: 0,
          gapsIdentified: 0,
          gapsResolved: 0,
          risksAccepted: 0,
          idleRatio: 1.0,
        },
      },
    });

    // Redisì— ì„¸ì…˜ ìºì‹œ
    await redis.setex(
      `hud:session:${session.id}`,
      3600 * 4, // 4ì‹œê°„ TTL
      JSON.stringify(session)
    );

    return session;
  }

  // Part 3.2: Idle ìƒíƒœ ì—…ë°ì´íŠ¸
  async updateIdleStats(sessionId: string, idleTime: number, totalTime: number) {
    const idleRatio = totalTime > 0 ? idleTime / totalTime : 1.0;

    await prisma.hudSession.update({
      where: { id: sessionId },
      data: {
        stats: {
          update: { idleRatio }
        }
      }
    });

    // Redis ìºì‹œ ì—…ë°ì´íŠ¸
    const cached = await redis.get(`hud:session:${sessionId}`);
    if (cached) {
      const session = JSON.parse(cached);
      session.stats.idleRatio = idleRatio;
      await redis.setex(`hud:session:${sessionId}`, 3600 * 4, JSON.stringify(session));
    }
  }

  // Part 3.3: ì•Œë¦¼ ìƒì„± ë° ê´€ë¦¬
  async processTranscriptForAlerts(sessionId: string, transcript: string) {
    const session = await this.getSession(sessionId);
    if (!session) throw new Error('SESSION_NOT_FOUND');

    // Gap ë¶„ì„
    const gaps = await this.gapAnalysis.analyze(session.meetingId, transcript);

    // ì•Œë¦¼ ìƒì„±
    const alerts = [];
    for (const gap of gaps) {
      const alert = await this.alertGenerator.createFromGap(gap, session.id);
      alerts.push(alert);

      // ì„¸ì…˜ í†µê³„ ì—…ë°ì´íŠ¸
      await this.incrementAlertCount(sessionId, alert.level);
    }

    return alerts;
  }

  // Part 3.4: ì‚¬ìš©ì ì‘ë‹µ ì²˜ë¦¬
  async handleAlertAction(
    sessionId: string,
    alertId: string,
    action: AlertAction,
    metadata?: Record<string, any>
  ) {
    const session = await this.getSession(sessionId);
    if (!session) throw new Error('SESSION_NOT_FOUND');

    const alert = await prisma.hudAlert.findUnique({
      where: { id: alertId }
    });
    if (!alert) throw new Error('ALERT_NOT_FOUND');

    let result: any;

    switch (action) {
      case 'ask':
        result = await this.handleAskAction(session, alert, metadata);
        break;
      case 'defer':
        result = await this.handleDeferAction(session, alert);
        break;
      case 'dismiss':
        result = await this.handleDismissAction(session, alert);
        break;
      case 'accept_risk':
        result = await this.handleAcceptRiskAction(session, alert);
        break;
    }

    // ë¶„ì„ ì´ë²¤íŠ¸ ê¸°ë¡
    await this.logAnalyticsEvent(sessionId, `alert_${action}`, {
      alertId,
      level: alert.level,
      category: alert.category,
      ...metadata
    });

    return result;
  }

  private async handleAskAction(session: any, alert: any, metadata?: any) {
    // ì•Œë¦¼ ìƒíƒœ ì—…ë°ì´íŠ¸
    await prisma.hudAlert.update({
      where: { id: alert.id },
      data: { status: 'actioned', actionedAt: new Date() }
    });

    // ì„¸ì…˜ í†µê³„ ì—…ë°ì´íŠ¸
    await prisma.hudSession.update({
      where: { id: session.id },
      data: {
        stats: {
          update: {
            alertsActioned: { increment: 1 }
          }
        }
      }
    });

    return {
      status: 'question_copied',
      question: alert.suggestedQuestion,
      followUp: {
        trackAnswer: true,
        expectedKeywords: this.extractKeywords(alert.category)
      }
    };
  }

  private async handleDeferAction(session: any, alert: any) {
    // ì—°ê¸° í•­ëª© ìƒì„±
    const deferredItem = await prisma.deferredItem.create({
      data: {
        sessionId: session.id,
        alertId: alert.id,
        question: alert.suggestedQuestion,
        category: alert.category,
        priority: alert.level === 3 ? 'high' : 'medium',
      }
    });

    // ì•Œë¦¼ ìƒíƒœ ì—…ë°ì´íŠ¸
    await prisma.hudAlert.update({
      where: { id: alert.id },
      data: { status: 'deferred' }
    });

    // ì„¸ì…˜ í†µê³„ ì—…ë°ì´íŠ¸
    await prisma.hudSession.update({
      where: { id: session.id },
      data: {
        stats: {
          update: {
            alertsDeferred: { increment: 1 }
          }
        }
      }
    });

    const count = await prisma.deferredItem.count({
      where: { sessionId: session.id, status: 'pending' }
    });

    return {
      deferredItemId: deferredItem.id,
      addedToDeferredList: true,
      currentDeferredCount: count
    };
  }

  private async handleAcceptRiskAction(session: any, alert: any) {
    if (alert.level !== 3 || alert.category !== 'risk') {
      throw new Error('INVALID_RISK_ACCEPT');
    }

    // ì•Œë¦¼ ìƒíƒœ ì—…ë°ì´íŠ¸
    await prisma.hudAlert.update({
      where: { id: alert.id },
      data: { status: 'risk_accepted', actionedAt: new Date() }
    });

    // ì„¸ì…˜ í†µê³„ ì—…ë°ì´íŠ¸
    await prisma.hudSession.update({
      where: { id: session.id },
      data: {
        stats: {
          update: {
            risksAccepted: { increment: 1 },
            alertsActioned: { increment: 1 }
          }
        }
      }
    });

    return {
      riskAccepted: true,
      warningAcknowledged: true,
      riskCategory: alert.metadata?.riskCategory || 'unknown'
    };
  }

  // ì„¸ì…˜ ì¢…ë£Œ
  async endSession(sessionId: string, endReason: string, summary?: any) {
    const session = await this.getSession(sessionId);
    if (!session) throw new Error('SESSION_NOT_FOUND');

    // ìµœì¢… í†µê³„ ê³„ì‚°
    const finalStats = await this.calculateFinalStats(session);

    // ì„¸ì…˜ ì—…ë°ì´íŠ¸
    await prisma.hudSession.update({
      where: { id: sessionId },
      data: {
        status: 'ended',
        endedAt: new Date(),
        endReason,
        stats: finalStats
      }
    });

    // Redis ìºì‹œ ì‚­ì œ
    await redis.del(`hud:session:${sessionId}`);

    // ì—°ê¸° í•­ëª© í™•ì¸
    const pendingDeferred = await prisma.deferredItem.findMany({
      where: { sessionId, status: 'pending' }
    });

    return {
      sessionId,
      endedAt: new Date(),
      finalStats,
      pendingActions: pendingDeferred.length > 0 ? [
        {
          type: 'deferred_question',
          count: pendingDeferred.length,
          items: pendingDeferred.map(d => d.question)
        }
      ] : []
    };
  }

  private async getSession(sessionId: string) {
    // Redisì—ì„œ ë¨¼ì € ì¡°íšŒ
    const cached = await redis.get(`hud:session:${sessionId}`);
    if (cached) return JSON.parse(cached);

    // DBì—ì„œ ì¡°íšŒ
    return prisma.hudSession.findUnique({
      where: { id: sessionId }
    });
  }

  private async incrementAlertCount(sessionId: string, level: AlertLevel) {
    const levelKey = `level${level}` as const;
    await prisma.hudSession.update({
      where: { id: sessionId },
      data: {
        stats: {
          update: {
            totalAlerts: {
              update: { [levelKey]: { increment: 1 } }
            },
            gapsIdentified: { increment: 1 }
          }
        }
      }
    });
  }

  private extractKeywords(category: AlertCategory): string[] {
    const keywordMap: Record<AlertCategory, string[]> = {
      gap: ['ì˜ˆì‚°', 'ë¹„ìš©', 'ê°€ê²©', 'ê¸°í•œ', 'ë‹´ë‹¹ì'],
      decision: ['ê²°ì •', 'ìŠ¹ì¸', 'í™•ì •', 'ë™ì˜'],
      action: ['ì§„í–‰', 'ì‹œì‘', 'ì™„ë£Œ', 'ë‹¤ìŒ'],
      risk: ['ë¦¬ìŠ¤í¬', 'ìœ„í—˜', 'ë¬¸ì œ', 'ì£¼ì˜'],
    };
    return keywordMap[category] || [];
  }

  private async calculateFinalStats(session: any): Promise<HUDSessionStats> {
    // ì‹¤ì œ í†µê³„ ê³„ì‚° ë¡œì§
    const alerts = await prisma.hudAlert.findMany({
      where: { sessionId: session.id }
    });

    const stats: HUDSessionStats = {
      totalAlerts: { level1: 0, level2: 0, level3: 0 },
      alertsActioned: 0,
      alertsDeferred: 0,
      alertsIgnored: 0,
      gapsIdentified: 0,
      gapsResolved: 0,
      risksAccepted: 0,
      idleRatio: session.stats?.idleRatio || 0.95,
    };

    for (const alert of alerts) {
      stats.totalAlerts[`level${alert.level}` as keyof typeof stats.totalAlerts]++;
      if (alert.status === 'actioned') stats.alertsActioned++;
      if (alert.status === 'deferred') stats.alertsDeferred++;
      if (alert.status === 'ignored' || alert.status === 'timeout') stats.alertsIgnored++;
      if (alert.status === 'risk_accepted') stats.risksAccepted++;
      if (alert.category === 'gap') stats.gapsIdentified++;
      if (alert.category === 'gap' && alert.status === 'actioned') stats.gapsResolved++;
    }

    return stats;
  }

  private async logAnalyticsEvent(
    sessionId: string,
    eventType: string,
    metadata: Record<string, any>
  ) {
    await prisma.analyticsEvent.create({
      data: {
        sessionId,
        eventType,
        metadata,
        timestamp: new Date()
      }
    });
  }

  private async findOrCreateMeeting(userId: string, platform: Platform, meetingUrl: string) {
    // ê¸°ì¡´ ë¯¸íŒ… ì°¾ê¸° ë˜ëŠ” ìƒˆë¡œ ìƒì„±
    let meeting = await prisma.meeting.findFirst({
      where: {
        userId,
        platform,
        OR: [
          { meetingUrl },
          { status: 'scheduled', scheduledAt: { gte: new Date() } }
        ]
      }
    });

    if (!meeting) {
      meeting = await prisma.meeting.create({
        data: {
          userId,
          platform,
          meetingUrl,
          status: 'live',
          startedAt: new Date()
        }
      });
    }

    return meeting;
  }
}
```

**Part 3 í•µì‹¬ ì§€í‘œ:**
```
ìë™ ì‹œì‘ë¥  = count(meeting_auto_started) / count(meeting_detected)
ëª©í‘œ: > 90%

í‰ê·  Idle ë¹„ìœ¨ = avg(idleRatio WHERE session_ended)
ëª©í‘œ: > 95%

ì•Œë¦¼ ì‹¤í–‰ë¥  = count(alert_ask_clicked) / count(alert_shown WHERE level >= 2)
ëª©í‘œ: > 50%

Gap í•´ê²°ë¥  = count(gap_resolved) / count(gap_identified)
ëª©í‘œ: > 70%

ì—°ê¸° ì™„ë£Œìœ¨ = count(deferred_resolved) / count(deferred_added)
ëª©í‘œ: > 80%

ìœ„í—˜ ê°ìˆ˜ìœ¨ = count(risk_accepted) / count(risk_dialog_shown)
ëª©í‘œ: < 20%

í‰ê·  ì‘ë‹µ ì‹œê°„ = avg(timeToAction WHERE alert_ask_clicked)
ëª©í‘œ: < 5ì´ˆ
```

### 4.15 í™•ì • ëª¨ë‹¬ API (Part 4.2)

#### í™•ì • ëª¨ë‹¬ ë°ì´í„° ì¡°íšŒ

```http
GET /api/meetings/{meetingId}/confirmation
```

**Response:**
```json
{
  "meeting": {
    "id": "mtg_123",
    "title": "Aì‚¬ íˆ¬ì ê²€í†  ë¯¸íŒ…",
    "startTime": "2025-12-30T14:00:00Z",
    "endTime": "2025-12-30T15:23:00Z",
    "duration": 4980
  },
  "decisions": [
    {
      "id": "dec_1",
      "content": "ì‹œë¦¬ì¦ˆA 500ì–µ ë°¸ë¥˜ ì œì•ˆ í•©ì˜",
      "assignee": "ê¹€ì² ìˆ˜",
      "deadline": "2025-01-15",
      "isComplete": true,
      "source": "ai_extracted"
    },
    {
      "id": "dec_2",
      "content": "ê¸°ìˆ  ì‹¤ì‚¬ ì¼ì • ì¡°ìœ¨ í•„ìš”",
      "assignee": null,
      "deadline": null,
      "isComplete": false,
      "source": "ai_extracted"
    }
  ],
  "insights": [
    "ì°½ì—…ì ì‹¤í–‰ë ¥ í‰ê°€: 5/5",
    "ì‹œì¥ ì§„ì… íƒ€ì´ë° ì ì ˆ",
    "MAU 10ë§Œ, ì›” ì„±ì¥ë¥  15%"
  ],
  "gaps": {
    "total": 3,
    "filled": 1
  }
}
```

#### ê²°ì • ì‚¬í•­ ì—…ë°ì´íŠ¸

```http
PATCH /api/decisions/{decisionId}
```

**Request:**
```json
{
  "assignee": "ë°•ì§€ì˜",
  "deadline": "2025-01-20"
}
```

**Response:**
```json
{
  "decision": {
    "id": "dec_2",
    "content": "ê¸°ìˆ  ì‹¤ì‚¬ ì¼ì • ì¡°ìœ¨ í•„ìš”",
    "assignee": "ë°•ì§€ì˜",
    "deadline": "2025-01-20",
    "isComplete": true,
    "updatedAt": "2025-12-30T15:25:00Z"
  }
}
```

#### ê²°ì • ì‚¬í•­ ì¶”ê°€ (ìˆ˜ë™)

```http
POST /api/meetings/{meetingId}/decisions
```

**Request:**
```json
{
  "content": "ì¶”ê°€ ë…¼ì˜ ì‚¬í•­: ê²½ìŸì‚¬ ë¶„ì„",
  "assignee": null,
  "deadline": null
}
```

#### ê²°ì • ì‚¬í•­ ì‚­ì œ

```http
DELETE /api/decisions/{decisionId}
```

### 4.16 í™•ì • ì™„ë£Œ API (Part 4.2-4.3)

#### í™•ì • ì €ì¥ (ë¡œì»¬ + Notion)

```http
POST /api/meetings/{meetingId}/confirm
```

**Request:**
```json
{
  "decisions": [
    {
      "id": "dec_1",
      "assignee": "ê¹€ì² ìˆ˜",
      "deadline": "2025-01-15"
    },
    {
      "id": "dec_2",
      "assignee": "ë°•ì§€ì˜",
      "deadline": "2025-01-20"
    }
  ],
  "saveToNotion": true,
  "notionWorkspaceId": "workspace_abc"
}
```

**Response:**
```json
{
  "success": true,
  "meeting": {
    "id": "mtg_123",
    "status": "confirmed",
    "confirmedAt": "2025-12-30T15:30:00Z"
  },
  "notion": {
    "saved": true,
    "pageId": "page_xyz",
    "pageUrl": "https://notion.so/mtg_123"
  }
}
```

#### Notion ì €ì¥ ì¬ì‹œë„

```http
POST /api/meetings/{meetingId}/notion/retry
```

**Response:**
```json
{
  "success": true,
  "pageId": "page_xyz",
  "pageUrl": "https://notion.so/mtg_123"
}
```

### 4.17 ë‚˜ì¤‘ì— ì²˜ë¦¬ API (Part 4)

#### ë‚˜ì¤‘ì— ì²˜ë¦¬ ìƒíƒœë¡œ ì „í™˜

```http
POST /api/meetings/{meetingId}/defer
```

**Response:**
```json
{
  "success": true,
  "meeting": {
    "id": "mtg_123",
    "status": "deferred",
    "deferredAt": "2025-12-30T15:25:00Z"
  },
  "notification": {
    "scheduled": true,
    "scheduledAt": "2025-12-30T18:00:00Z"
  }
}
```

#### ì—°ê¸°ëœ ë¯¸íŒ… ëª©ë¡ ì¡°íšŒ

```http
GET /api/meetings/deferred
```

**Response:**
```json
{
  "meetings": [
    {
      "id": "mtg_123",
      "title": "Aì‚¬ íˆ¬ì ê²€í†  ë¯¸íŒ…",
      "deferredAt": "2025-12-30T15:25:00Z",
      "gaps": { "total": 2, "filled": 0 },
      "priority": "high"
    }
  ]
}
```

### 4.18 Part 4 ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```prisma
// Part 4 ê´€ë ¨ ì¶”ê°€ ìŠ¤í‚¤ë§ˆ

model MeetingConfirmation {
  id                String    @id @default(cuid())
  meetingId         String    @unique
  meeting           Meeting   @relation(fields: [meetingId], references: [id])

  // í™•ì • ìƒíƒœ
  status            ConfirmationStatus @default(PENDING)
  confirmedAt       DateTime?
  deferredAt        DateTime?

  // ê²°ì • ì‚¬í•­
  decisions         Decision[]

  // Notion í†µí•©
  notionPageId      String?
  notionPageUrl     String?
  notionSavedAt     DateTime?
  notionError       String?

  // ë©”íƒ€ë°ì´í„°
  totalGaps         Int       @default(0)
  filledGaps        Int       @default(0)
  timeToConfirm     Int?      // ì´ˆ ë‹¨ìœ„

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
}

enum ConfirmationStatus {
  PENDING
  IN_PROGRESS
  CONFIRMED
  DEFERRED
  SKIPPED
}

model Decision {
  id              String    @id @default(cuid())
  confirmationId  String
  confirmation    MeetingConfirmation @relation(fields: [confirmationId], references: [id])

  // ê²°ì • ë‚´ìš©
  content         String
  assignee        String?
  deadline        DateTime?
  source          DecisionSource @default(AI_EXTRACTED)

  // ìƒíƒœ
  isComplete      Boolean   @default(false)
  isEdited        Boolean   @default(false)

  // ì¶”ì¶œ ë©”íƒ€ë°ì´í„°
  extractedFrom   String?   // ì „ì‚¬ í…ìŠ¤íŠ¸ ì°¸ì¡°
  confidence      Float?    // AI ì‹ ë¢°ë„

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

enum DecisionSource {
  AI_EXTRACTED
  USER_ADDED
  EDITED
}
```

### 4.19 Part 4 ì„œë¹„ìŠ¤ êµ¬í˜„

```typescript
// src/services/ConfirmationService.ts

import { prisma } from '@/lib/prisma';
import { NotionService } from './NotionService';
import { AnalyticsService } from './AnalyticsService';

export class ConfirmationService {
  // í™•ì • ëª¨ë‹¬ ë°ì´í„° ì¡°íšŒ
  async getConfirmationData(meetingId: string) {
    const meeting = await prisma.meeting.findUnique({
      where: { id: meetingId },
      include: {
        confirmation: {
          include: {
            decisions: true
          }
        },
        insights: true,
        transcript: true
      }
    });

    if (!meeting) {
      throw new Error('Meeting not found');
    }

    // í™•ì • ë°ì´í„°ê°€ ì—†ìœ¼ë©´ AI ì¶”ì¶œ ì‹¤í–‰
    if (!meeting.confirmation) {
      const confirmation = await this.createConfirmationFromAI(meeting);
      return confirmation;
    }

    return {
      meeting: {
        id: meeting.id,
        title: meeting.title,
        startTime: meeting.startTime,
        endTime: meeting.endTime,
        duration: meeting.duration
      },
      decisions: meeting.confirmation.decisions,
      insights: meeting.insights.map(i => i.content),
      gaps: {
        total: meeting.confirmation.totalGaps,
        filled: meeting.confirmation.filledGaps
      }
    };
  }

  // AI ê¸°ë°˜ ê²°ì •ì‚¬í•­ ì¶”ì¶œ
  private async createConfirmationFromAI(meeting: any) {
    const decisions = await this.extractDecisionsFromTranscript(
      meeting.transcript
    );

    const confirmation = await prisma.meetingConfirmation.create({
      data: {
        meetingId: meeting.id,
        status: 'PENDING',
        totalGaps: decisions.filter(d => !d.isComplete).length,
        filledGaps: 0,
        decisions: {
          create: decisions
        }
      },
      include: {
        decisions: true
      }
    });

    return confirmation;
  }

  // ê²°ì • ì‚¬í•­ ì—…ë°ì´íŠ¸
  async updateDecision(
    decisionId: string,
    updates: { assignee?: string; deadline?: string }
  ) {
    const decision = await prisma.decision.update({
      where: { id: decisionId },
      data: {
        ...updates,
        isComplete: !!updates.assignee && !!updates.deadline,
        isEdited: true
      }
    });

    // ë¹ˆì¹¸ ìƒíƒœ ì¬ê³„ì‚°
    await this.recalculateGaps(decision.confirmationId);

    // ì´ë²¤íŠ¸ ë¡œê¹…
    AnalyticsService.track('gap_field_filled', {
      decisionId,
      field: updates.assignee ? 'assignee' : 'deadline'
    });

    return decision;
  }

  // í™•ì • ì™„ë£Œ ì²˜ë¦¬
  async confirm(
    meetingId: string,
    data: {
      decisions: Array<{ id: string; assignee: string; deadline: string }>;
      saveToNotion: boolean;
      notionWorkspaceId?: string;
    }
  ) {
    const startTime = Date.now();

    // ê²°ì •ì‚¬í•­ ì¼ê´„ ì—…ë°ì´íŠ¸
    for (const decision of data.decisions) {
      await prisma.decision.update({
        where: { id: decision.id },
        data: {
          assignee: decision.assignee,
          deadline: new Date(decision.deadline),
          isComplete: true
        }
      });
    }

    // í™•ì • ìƒíƒœë¡œ ë³€ê²½
    const confirmation = await prisma.meetingConfirmation.update({
      where: { meetingId },
      data: {
        status: 'CONFIRMED',
        confirmedAt: new Date(),
        timeToConfirm: Math.floor((Date.now() - startTime) / 1000)
      }
    });

    // Notion ì €ì¥ (ì„ íƒì )
    let notionResult = null;
    if (data.saveToNotion && data.notionWorkspaceId) {
      try {
        notionResult = await NotionService.saveMeeting(
          meetingId,
          data.notionWorkspaceId
        );

        await prisma.meetingConfirmation.update({
          where: { meetingId },
          data: {
            notionPageId: notionResult.pageId,
            notionPageUrl: notionResult.pageUrl,
            notionSavedAt: new Date()
          }
        });
      } catch (error) {
        await prisma.meetingConfirmation.update({
          where: { meetingId },
          data: {
            notionError: error.message
          }
        });
      }
    }

    // ì´ë²¤íŠ¸ ë¡œê¹…
    AnalyticsService.track('confirm_clicked', {
      meetingId,
      timeToConfirm: confirmation.timeToConfirm,
      totalDecisions: data.decisions.length,
      savedToNotion: !!notionResult
    });

    return {
      success: true,
      meeting: confirmation,
      notion: notionResult
    };
  }

  // ë‚˜ì¤‘ì— ì²˜ë¦¬
  async defer(meetingId: string) {
    const confirmation = await prisma.meetingConfirmation.update({
      where: { meetingId },
      data: {
        status: 'DEFERRED',
        deferredAt: new Date()
      }
    });

    // ë¦¬ë§ˆì¸ë” ì•Œë¦¼ ì˜ˆì•½ (3ì‹œê°„ í›„)
    await this.scheduleReminder(meetingId, 3 * 60 * 60 * 1000);

    // ì´ë²¤íŠ¸ ë¡œê¹…
    AnalyticsService.track('later_clicked', { meetingId });

    return confirmation;
  }

  // ë¹ˆì¹¸ ìƒíƒœ ì¬ê³„ì‚°
  private async recalculateGaps(confirmationId: string) {
    const decisions = await prisma.decision.findMany({
      where: { confirmationId }
    });

    const totalGaps = decisions.filter(d => !d.isComplete).length;
    const filledGaps = decisions.filter(d => d.isComplete).length;

    await prisma.meetingConfirmation.update({
      where: { id: confirmationId },
      data: { totalGaps, filledGaps }
    });
  }

  // ë¦¬ë§ˆì¸ë” ì˜ˆì•½
  private async scheduleReminder(meetingId: string, delayMs: number) {
    // Bull Queue ë˜ëŠ” Vercel Cron ì‚¬ìš©
    await queueService.add('confirmation_reminder', {
      meetingId,
      type: 'DEFERRED_MEETING'
    }, {
      delay: delayMs
    });
  }
}
```

**Part 4 í•µì‹¬ ì§€í‘œ:**
```
í™•ì • ì™„ë£Œìœ¨ = count(status = CONFIRMED) / count(meeting_ended WHERE duration > 300)
ëª©í‘œ: > 85%

í‰ê·  í™•ì • ì‹œê°„ = avg(timeToConfirm WHERE status = CONFIRMED)
ëª©í‘œ: < 180ì´ˆ

ë¹ˆì¹¸ ì±„ìš°ê¸°ìœ¨ = sum(filledGaps) / sum(totalGaps)
ëª©í‘œ: > 90%

ëª¨ë‹¬ í¬ê¸°ìœ¨ = count(status = DEFERRED OR abandoned) / count(confirmation_shown)
ëª©í‘œ: < 15%

Notion ì €ì¥ ì„±ê³µë¥  = count(notionSavedAt IS NOT NULL) / count(saveToNotion = true)
ëª©í‘œ: > 95%

ë‚˜ì¤‘ì— ë³µê·€ìœ¨ = count(DEFERRED â†’ CONFIRMED) / count(status = DEFERRED)
ëª©í‘œ: > 70%
```

---

### 4.20 ì‹œë§¨í‹± ê²€ìƒ‰ API (Part 5)

```typescript
// POST /api/search
// ì‹œë§¨í‹± ê²€ìƒ‰ ì‹¤í–‰

interface SearchRequest {
  query: string;                    // ì‚¬ìš©ì ê²€ìƒ‰ì–´ (ìì—°ì–´)
  parsedQuery?: {                   // í”„ë¡ íŠ¸ì—”ë“œì—ì„œ íŒŒì‹±ëœ ì˜ë„ (ì„ íƒ)
    timeRange?: { start: Date; end: Date };
    person?: string;
    company?: string;
    topic?: string;
    decisionElement?: 'decision' | 'action' | 'risk' | 'assumption';
    keywords: string[];
  };
  filter?: {
    dateRange: 'all' | 'week' | 'month' | '3months' | 'custom';
    customDateRange?: { start: Date; end: Date };
    companies: string[];
    persons: string[];
    decisionElements: string[];
  };
  sortBy?: 'relevance' | 'date';
  limit?: number;                   // ê¸°ë³¸ê°’: 20
  offset?: number;                  // í˜ì´ì§€ë„¤ì´ì…˜
}

interface SearchResponse {
  results: SearchResult[];
  totalCount: number;
  searchTimeMs: number;
  semanticParseResult: {
    success: boolean;
    parsedIntent: ParsedQuery | null;
    confidence: number;
  };
  suggestions?: string[];           // ê²€ìƒ‰ ê²°ê³¼ ì—†ì„ ë•Œ ì œì•ˆ
}

interface SearchResult {
  meetingId: string;
  meetingTitle: string;
  meetingDate: Date;
  company?: string;
  attendees: string[];
  snippets: Snippet[];
  decisionSummary?: string;
  mentionCount: number;
  relevanceScore: number;
}

interface Snippet {
  text: string;
  speaker?: string;
  timestamp?: Date;
  highlightRanges: Array<{ start: number; end: number }>;
}

// Request ì˜ˆì‹œ
POST /api/search
{
  "query": "3ê°œì›” ì „ Aì‚¬ CAC",
  "filter": {
    "dateRange": "all",
    "companies": [],
    "persons": [],
    "decisionElements": []
  },
  "sortBy": "relevance",
  "limit": 20,
  "offset": 0
}

// Response ì˜ˆì‹œ
{
  "results": [
    {
      "meetingId": "mtg_abc123",
      "meetingTitle": "Aì‚¬ 2ì°¨ ë¯¸íŒ…",
      "meetingDate": "2024-09-15T14:00:00Z",
      "company": "Aì‚¬",
      "attendees": ["ê¹€ëŒ€í‘œ", "ì´ê³¼ì¥", "ë¯¼ìˆ˜"],
      "snippets": [
        {
          "text": "CACëŠ” ì±„ë„ë³„ë¡œ ì˜¨ë¼ì¸ $85, ì˜¤í”„ë¼ì¸ $120ì…ë‹ˆë‹¤",
          "speaker": "ê¹€ëŒ€í‘œ",
          "timestamp": "2024-09-15T14:32:00Z",
          "highlightRanges": [{ "start": 0, "end": 3 }]
        }
      ],
      "decisionSummary": "CAC ì •ë³´ í™•ì¸: ì˜¨ë¼ì¸ $85, ì˜¤í”„ë¼ì¸ $120",
      "mentionCount": 3,
      "relevanceScore": 0.92
    }
  ],
  "totalCount": 3,
  "searchTimeMs": 156,
  "semanticParseResult": {
    "success": true,
    "parsedIntent": {
      "timeRange": {
        "start": "2024-09-01T00:00:00Z",
        "end": "2024-12-30T23:59:59Z"
      },
      "company": "Aì‚¬",
      "keywords": ["CAC"]
    },
    "confidence": 0.89
  }
}
```

---

### 4.21 ì‹œë§¨í‹± ì¿¼ë¦¬ íŒŒì‹± ì„œë¹„ìŠ¤ (Part 5)

```typescript
// src/services/search/semanticParser.ts
// AI ê¸°ë°˜ ìì—°ì–´ ì¿¼ë¦¬ íŒŒì‹± ì„œë¹„ìŠ¤

import { openai } from '@/lib/openai';

interface ParsedQuery {
  timeRange?: { start: Date; end: Date };
  person?: string;
  company?: string;
  topic?: string;
  decisionElement?: 'decision' | 'action' | 'risk' | 'assumption';
  keywords: string[];
  intent?: 'find_info' | 'find_person_said' | 'find_decision' | 'find_timeline';
}

export async function parseSemanticQuery(query: string): Promise<{
  parsed: ParsedQuery;
  confidence: number;
}> {
  // 1. ê·œì¹™ ê¸°ë°˜ íŒŒì‹± (ë¹ ë¥¸ ì²˜ë¦¬)
  const ruleBasedResult = parseWithRules(query);

  // ê·œì¹™ìœ¼ë¡œ ì¶©ë¶„íˆ íŒŒì‹±ë˜ë©´ ë°”ë¡œ ë°˜í™˜
  if (ruleBasedResult.confidence > 0.8) {
    return ruleBasedResult;
  }

  // 2. AI ê¸°ë°˜ íŒŒì‹± (ë³µì¡í•œ ì¿¼ë¦¬)
  const aiResult = await parseWithAI(query);

  // ê²°ê³¼ ë³‘í•© (ê·œì¹™ ê¸°ë°˜ + AI)
  return mergeResults(ruleBasedResult, aiResult);
}

function parseWithRules(query: string): { parsed: ParsedQuery; confidence: number } {
  const parsed: ParsedQuery = { keywords: [] };
  let matchCount = 0;
  let totalPossibleMatches = 4;

  // ì‹œê°„ í‘œí˜„ íŒŒì‹±
  const timePatterns: Array<{
    regex: RegExp;
    handler: () => { start: Date; end: Date };
  }> = [
    {
      regex: /(\d+)ê°œì›”\s*ì „/,
      handler: () => {
        const months = parseInt(query.match(/(\d+)ê°œì›”\s*ì „/)![1]);
        const end = new Date();
        const start = new Date();
        start.setMonth(start.getMonth() - months);
        return { start, end };
      }
    },
    {
      regex: /ì§€ë‚œ\s*ì£¼/,
      handler: () => {
        const end = new Date();
        const start = new Date();
        start.setDate(start.getDate() - 7);
        return { start, end };
      }
    },
    {
      regex: /ì§€ë‚œ\s*ë‹¬/,
      handler: () => {
        const end = new Date();
        const start = new Date();
        start.setMonth(start.getMonth() - 1);
        return { start, end };
      }
    },
    {
      regex: /ì´ë²ˆ\s*ì£¼/,
      handler: () => {
        const end = new Date();
        const start = new Date();
        const dayOfWeek = start.getDay();
        start.setDate(start.getDate() - dayOfWeek);
        return { start, end };
      }
    },
  ];

  for (const { regex, handler } of timePatterns) {
    if (regex.test(query)) {
      parsed.timeRange = handler();
      matchCount++;
      break;
    }
  }

  // íšŒì‚¬ëª… ì¶”ì¶œ
  const companyMatch = query.match(/([A-Zê°€-í£]+ì‚¬)/);
  if (companyMatch) {
    parsed.company = companyMatch[1];
    matchCount++;
  }

  // ì‚¬ëŒ ì´ë¦„ ì¶”ì¶œ
  const personPatterns = [
    /([ê°€-í£]{2,4})(ëŒ€í‘œ|ê³¼ì¥|ë¶€ì¥|íŒ€ì¥|ì‚¬ì¥|ì´ì‚¬|ë‹˜)/,
    /([ê°€-í£]{2,4})ê°€\s*(ë§í•œ|ì•½ì†í•œ|ì–¸ê¸‰í•œ)/,
  ];
  for (const pattern of personPatterns) {
    const match = query.match(pattern);
    if (match) {
      parsed.person = match[1] + (match[2]?.match(/ëŒ€í‘œ|ê³¼ì¥|ë¶€ì¥|íŒ€ì¥|ì‚¬ì¥|ì´ì‚¬/) ? match[2] : '');
      matchCount++;
      break;
    }
  }

  // ê²°ì • ìš”ì†Œ í‚¤ì›Œë“œ ì¶”ì¶œ
  const decisionKeywords: Record<string, ParsedQuery['decisionElement']> = {
    'ê²°ì •': 'decision',
    'ê²°ë¡ ': 'decision',
    'í•©ì˜': 'decision',
    'ì•¡ì…˜': 'action',
    'í• ì¼': 'action',
    'ì•½ì†': 'action',
    'ë¦¬ìŠ¤í¬': 'risk',
    'ìš°ë ¤': 'risk',
    'ìœ„í—˜': 'risk',
    'ë¯¸í™•ì¸': 'assumption',
    'ê°€ì •': 'assumption',
  };

  for (const [keyword, element] of Object.entries(decisionKeywords)) {
    if (query.includes(keyword)) {
      parsed.decisionElement = element;
      matchCount++;
      break;
    }
  }

  // ë‚¨ì€ í‚¤ì›Œë“œ ì¶”ì¶œ
  let cleanedQuery = query;
  if (parsed.timeRange) cleanedQuery = cleanedQuery.replace(/\d+ê°œì›”\s*ì „|ì§€ë‚œ\s*(ì£¼|ë‹¬)|ì´ë²ˆ\s*ì£¼/g, '');
  if (parsed.company) cleanedQuery = cleanedQuery.replace(parsed.company, '');
  if (parsed.person) cleanedQuery = cleanedQuery.replace(parsed.person, '');

  const keywords = cleanedQuery
    .split(/\s+/)
    .filter(k => k.length > 1 && !['ì´', 'ê·¸', 'ì €', 'ì˜', 'ë¥¼', 'ì„', 'ê°€', 'ì—', 'í•œ'].includes(k));

  if (keywords.length > 0) {
    parsed.keywords = keywords;
  }

  const confidence = matchCount / totalPossibleMatches;
  return { parsed, confidence: Math.max(confidence, 0.3) };
}

async function parseWithAI(query: string): Promise<{ parsed: ParsedQuery; confidence: number }> {
  const response = await openai.chat.completions.create({
    model: 'gpt-4-turbo-preview',
    messages: [
      {
        role: 'system',
        content: `You are a search query parser for a meeting intelligence system. Parse the user's natural language query into structured search parameters.

Output JSON with these fields:
- timeRange: { start: ISO date, end: ISO date } - if time is mentioned
- person: string - if a person's name is mentioned
- company: string - if a company is mentioned
- topic: string - the main topic being searched
- decisionElement: "decision" | "action" | "risk" | "assumption" - if a specific type is requested
- keywords: string[] - remaining important keywords
- intent: "find_info" | "find_person_said" | "find_decision" | "find_timeline"
- confidence: number 0-1`
      },
      { role: 'user', content: query }
    ],
    response_format: { type: 'json_object' },
    temperature: 0.1,
  });

  try {
    const result = JSON.parse(response.choices[0].message.content || '{}');
    return {
      parsed: {
        timeRange: result.timeRange,
        person: result.person,
        company: result.company,
        topic: result.topic,
        decisionElement: result.decisionElement,
        keywords: result.keywords || [],
        intent: result.intent,
      },
      confidence: result.confidence || 0.5,
    };
  } catch {
    return { parsed: { keywords: [query] }, confidence: 0.3 };
  }
}

function mergeResults(
  ruleBased: { parsed: ParsedQuery; confidence: number },
  aiBased: { parsed: ParsedQuery; confidence: number }
): { parsed: ParsedQuery; confidence: number } {
  // ê° í•„ë“œë³„ë¡œ ë” í™•ì‹¤í•œ ê²°ê³¼ ì„ íƒ
  const merged: ParsedQuery = {
    timeRange: ruleBased.parsed.timeRange || aiBased.parsed.timeRange,
    person: ruleBased.parsed.person || aiBased.parsed.person,
    company: ruleBased.parsed.company || aiBased.parsed.company,
    topic: aiBased.parsed.topic,
    decisionElement: ruleBased.parsed.decisionElement || aiBased.parsed.decisionElement,
    keywords: [...new Set([...ruleBased.parsed.keywords, ...aiBased.parsed.keywords])],
    intent: aiBased.parsed.intent,
  };

  const avgConfidence = (ruleBased.confidence + aiBased.confidence) / 2;
  return { parsed: merged, confidence: avgConfidence };
}
```

---

### 4.22 ë²¡í„° ê²€ìƒ‰ ì„œë¹„ìŠ¤ (Part 5)

```typescript
// src/services/search/vectorSearch.ts
// Pinecone ê¸°ë°˜ ë²¡í„° ê²€ìƒ‰ ì„œë¹„ìŠ¤

import { Pinecone } from '@pinecone-database/pinecone';
import { openai } from '@/lib/openai';

const pinecone = new Pinecone({
  apiKey: process.env.PINECONE_API_KEY!,
});

const index = pinecone.index('onno-meetings');

interface VectorSearchParams {
  query: string;
  filters?: {
    userId: string;
    teamId?: string;
    dateRange?: { start: Date; end: Date };
    companies?: string[];
    attendees?: string[];
  };
  topK?: number;
}

interface VectorSearchResult {
  meetingId: string;
  segmentId: string;
  score: number;
  text: string;
  metadata: {
    speaker?: string;
    timestamp?: Date;
    meetingTitle?: string;
    company?: string;
  };
}

export async function searchWithVectors(
  params: VectorSearchParams
): Promise<VectorSearchResult[]> {
  const { query, filters, topK = 50 } = params;

  // 1. ì¿¼ë¦¬ ì„ë² ë”© ìƒì„±
  const embedding = await generateEmbedding(query);

  // 2. Pinecone í•„í„° êµ¬ì„±
  const pineconeFilter: Record<string, any> = {
    userId: filters?.userId,
  };

  if (filters?.teamId) {
    pineconeFilter.teamId = filters.teamId;
  }

  if (filters?.dateRange) {
    pineconeFilter.meetingDate = {
      $gte: filters.dateRange.start.toISOString(),
      $lte: filters.dateRange.end.toISOString(),
    };
  }

  if (filters?.companies?.length) {
    pineconeFilter.company = { $in: filters.companies };
  }

  // 3. ë²¡í„° ê²€ìƒ‰ ì‹¤í–‰
  const results = await index.namespace('transcripts').query({
    vector: embedding,
    topK,
    filter: pineconeFilter,
    includeMetadata: true,
  });

  // 4. ê²°ê³¼ ë³€í™˜
  return results.matches?.map((match) => ({
    meetingId: match.metadata?.meetingId as string,
    segmentId: match.id,
    score: match.score || 0,
    text: match.metadata?.text as string,
    metadata: {
      speaker: match.metadata?.speaker as string | undefined,
      timestamp: match.metadata?.timestamp
        ? new Date(match.metadata.timestamp as string)
        : undefined,
      meetingTitle: match.metadata?.meetingTitle as string | undefined,
      company: match.metadata?.company as string | undefined,
    },
  })) || [];
}

async function generateEmbedding(text: string): Promise<number[]> {
  const response = await openai.embeddings.create({
    model: 'text-embedding-3-small',
    input: text,
  });
  return response.data[0].embedding;
}

// ê²€ìƒ‰ ê²°ê³¼ ë¦¬ë­í‚¹
export async function rerankResults(
  query: string,
  results: VectorSearchResult[],
  userHistory?: {
    frequentSearches: string[];
    frequentMeetings: string[];
  }
): Promise<VectorSearchResult[]> {
  // 1. ê¸°ë³¸ ë²¡í„° ìœ ì‚¬ë„ ì ìˆ˜
  const scoredResults = results.map((r) => ({
    ...r,
    adjustedScore: r.score,
  }));

  // 2. ìµœì‹ ì„± ë¶€ìŠ¤íŠ¸ (ìµœê·¼ ë¯¸íŒ… ìš°ì„ )
  const now = new Date();
  for (const result of scoredResults) {
    if (result.metadata.timestamp) {
      const daysDiff = (now.getTime() - result.metadata.timestamp.getTime()) / (1000 * 60 * 60 * 24);
      // ìµœê·¼ 30ì¼ ì´ë‚´ë©´ ì ìˆ˜ ë¶€ìŠ¤íŠ¸
      if (daysDiff < 30) {
        result.adjustedScore *= 1 + (0.25 * (30 - daysDiff) / 30);
      }
    }
  }

  // 3. ì‚¬ìš©ì íˆìŠ¤í† ë¦¬ ê¸°ë°˜ ë¶€ìŠ¤íŠ¸
  if (userHistory) {
    for (const result of scoredResults) {
      // ìì£¼ ì ‘ê·¼í•˜ëŠ” ë¯¸íŒ…ì´ë©´ ë¶€ìŠ¤íŠ¸
      if (userHistory.frequentMeetings.includes(result.meetingId)) {
        result.adjustedScore *= 1.15;
      }
    }
  }

  // 4. ì •í™• ë§¤ì¹­ ë¶€ìŠ¤íŠ¸
  const queryLower = query.toLowerCase();
  for (const result of scoredResults) {
    if (result.text.toLowerCase().includes(queryLower)) {
      result.adjustedScore *= 1.3;
    }
  }

  // 5. ì ìˆ˜ ìˆœ ì •ë ¬
  return scoredResults.sort((a, b) => b.adjustedScore - a.adjustedScore);
}

// ì„ë² ë”© ì¸ë±ì‹± (ë¯¸íŒ… ì €ì¥ ì‹œ í˜¸ì¶œ)
export async function indexMeetingSegments(
  meetingId: string,
  segments: Array<{
    id: string;
    text: string;
    speaker?: string;
    timestamp?: Date;
  }>,
  metadata: {
    userId: string;
    teamId?: string;
    meetingTitle: string;
    meetingDate: Date;
    company?: string;
    attendees: string[];
  }
): Promise<void> {
  // ì„¸ê·¸ë¨¼íŠ¸ë³„ ì„ë² ë”© ìƒì„±
  const vectors = await Promise.all(
    segments.map(async (segment) => {
      const embedding = await generateEmbedding(segment.text);
      return {
        id: segment.id,
        values: embedding,
        metadata: {
          meetingId,
          text: segment.text,
          speaker: segment.speaker,
          timestamp: segment.timestamp?.toISOString(),
          ...metadata,
        },
      };
    })
  );

  // Pineconeì— ì—…ì„œíŠ¸
  await index.namespace('transcripts').upsert(vectors);
}
```

---

### 4.23 ê²€ìƒ‰ ê²°ê³¼ ê·¸ë£¹í™” ë° ë­í‚¹ (Part 5)

```typescript
// src/services/search/resultAggregator.ts
// ê²€ìƒ‰ ê²°ê³¼ë¥¼ ë¯¸íŒ… ë‹¨ìœ„ë¡œ ê·¸ë£¹í™”í•˜ê³  ë­í‚¹

import { VectorSearchResult } from './vectorSearch';
import { prisma } from '@/lib/prisma';

interface AggregatedSearchResult {
  meetingId: string;
  meetingTitle: string;
  meetingDate: Date;
  company?: string;
  attendees: string[];
  snippets: Array<{
    text: string;
    speaker?: string;
    timestamp?: Date;
    highlightRanges: Array<{ start: number; end: number }>;
  }>;
  decisionSummary?: string;
  mentionCount: number;
  relevanceScore: number;
}

export async function aggregateSearchResults(
  vectorResults: VectorSearchResult[],
  query: string,
  sortBy: 'relevance' | 'date'
): Promise<AggregatedSearchResult[]> {
  // 1. ë¯¸íŒ… ID ë³„ë¡œ ê·¸ë£¹í™”
  const meetingGroups = new Map<string, VectorSearchResult[]>();

  for (const result of vectorResults) {
    const existing = meetingGroups.get(result.meetingId) || [];
    existing.push(result);
    meetingGroups.set(result.meetingId, existing);
  }

  // 2. ê° ë¯¸íŒ…ì˜ ìƒì„¸ ì •ë³´ ì¡°íšŒ
  const meetingIds = Array.from(meetingGroups.keys());
  const meetings = await prisma.meeting.findMany({
    where: { id: { in: meetingIds } },
    include: {
      attendees: true,
      decisions: {
        take: 3,
        orderBy: { confidence: 'desc' },
      },
    },
  });

  // 3. ê²°ê³¼ êµ¬ì„±
  const aggregatedResults: AggregatedSearchResult[] = [];

  for (const meeting of meetings) {
    const segments = meetingGroups.get(meeting.id) || [];

    // í‚¤ì›Œë“œ í•˜ì´ë¼ì´íŒ…
    const snippets = segments.slice(0, 3).map((seg) => ({
      text: seg.text,
      speaker: seg.metadata.speaker,
      timestamp: seg.metadata.timestamp,
      highlightRanges: findHighlightRanges(seg.text, query),
    }));

    // ê´€ë ¨ë„ ì ìˆ˜ ê³„ì‚° (ì„¸ê·¸ë¨¼íŠ¸ ì ìˆ˜ í‰ê· )
    const avgScore = segments.reduce((sum, s) => sum + s.score, 0) / segments.length;

    // ê²°ì • ì‚¬í•­ ìš”ì•½
    const decisionSummary = meeting.decisions.length > 0
      ? meeting.decisions.map(d => d.content).join(' | ')
      : undefined;

    aggregatedResults.push({
      meetingId: meeting.id,
      meetingTitle: meeting.title,
      meetingDate: meeting.scheduledAt,
      company: meeting.companyName || undefined,
      attendees: meeting.attendees.map(a => a.name),
      snippets,
      decisionSummary,
      mentionCount: segments.length,
      relevanceScore: avgScore,
    });
  }

  // 4. ì •ë ¬
  if (sortBy === 'relevance') {
    aggregatedResults.sort((a, b) => b.relevanceScore - a.relevanceScore);
  } else {
    aggregatedResults.sort((a, b) => b.meetingDate.getTime() - a.meetingDate.getTime());
  }

  return aggregatedResults;
}

function findHighlightRanges(
  text: string,
  query: string
): Array<{ start: number; end: number }> {
  const ranges: Array<{ start: number; end: number }> = [];
  const keywords = query.split(/\s+/).filter(k => k.length > 1);
  const textLower = text.toLowerCase();

  for (const keyword of keywords) {
    const keywordLower = keyword.toLowerCase();
    let startIndex = 0;

    while (true) {
      const index = textLower.indexOf(keywordLower, startIndex);
      if (index === -1) break;

      ranges.push({
        start: index,
        end: index + keyword.length,
      });
      startIndex = index + 1;
    }
  }

  // ì˜¤ë²„ë˜í•‘ ë²”ìœ„ ë³‘í•©
  return mergeRanges(ranges);
}

function mergeRanges(
  ranges: Array<{ start: number; end: number }>
): Array<{ start: number; end: number }> {
  if (ranges.length === 0) return [];

  ranges.sort((a, b) => a.start - b.start);
  const merged: Array<{ start: number; end: number }> = [ranges[0]];

  for (let i = 1; i < ranges.length; i++) {
    const current = ranges[i];
    const last = merged[merged.length - 1];

    if (current.start <= last.end) {
      last.end = Math.max(last.end, current.end);
    } else {
      merged.push(current);
    }
  }

  return merged;
}
```

---

### 4.24 ê´€ë ¨ ë¯¸íŒ… API (Part 5.3)

```typescript
// GET /api/meetings/:meetingId/related
// ê´€ë ¨ ë¯¸íŒ… ì¡°íšŒ

interface RelatedMeetingsResponse {
  meetings: RelatedMeeting[];
}

interface RelatedMeeting {
  meetingId: string;
  meetingTitle: string;
  meetingDate: Date;
  relationType: 'same_company' | 'same_topic' | 'same_attendees' | 'follow_up';
  relevanceScore: number;
  topicOverlap?: string[];
}

// ì„œë¹„ìŠ¤ êµ¬í˜„
export async function getRelatedMeetings(
  meetingId: string,
  userId: string,
  limit: number = 5
): Promise<RelatedMeeting[]> {
  // í˜„ì¬ ë¯¸íŒ… ì •ë³´ ì¡°íšŒ
  const currentMeeting = await prisma.meeting.findUnique({
    where: { id: meetingId },
    include: {
      attendees: true,
      decisions: true,
    },
  });

  if (!currentMeeting) return [];

  // 1. ê°™ì€ íšŒì‚¬ ë¯¸íŒ…
  const sameCompanyMeetings = currentMeeting.companyName
    ? await prisma.meeting.findMany({
        where: {
          userId,
          companyName: currentMeeting.companyName,
          id: { not: meetingId },
        },
        orderBy: { scheduledAt: 'desc' },
        take: 3,
      })
    : [];

  // 2. ê°™ì€ ì°¸ì„ì ë¯¸íŒ…
  const attendeeNames = currentMeeting.attendees.map((a) => a.name);
  const sameAttendeeMeetings = await prisma.meeting.findMany({
    where: {
      userId,
      id: { not: meetingId },
      attendees: {
        some: { name: { in: attendeeNames } },
      },
    },
    orderBy: { scheduledAt: 'desc' },
    take: 3,
  });

  // 3. ë¹„ìŠ·í•œ ì£¼ì œ ë¯¸íŒ… (ë²¡í„° ê²€ìƒ‰ í™œìš©)
  const meetingTopics = currentMeeting.decisions
    .map((d) => d.content)
    .join(' ')
    .slice(0, 500);

  const similarTopicResults = meetingTopics
    ? await searchWithVectors({
        query: meetingTopics,
        filters: { userId },
        topK: 10,
      })
    : [];

  const similarTopicMeetingIds = [
    ...new Set(
      similarTopicResults
        .filter((r) => r.meetingId !== meetingId)
        .map((r) => r.meetingId)
    ),
  ].slice(0, 3);

  // 4. ê²°ê³¼ ì¡°í•© ë° ì¤‘ë³µ ì œê±°
  const allRelated = new Map<string, RelatedMeeting>();

  for (const m of sameCompanyMeetings) {
    allRelated.set(m.id, {
      meetingId: m.id,
      meetingTitle: m.title,
      meetingDate: m.scheduledAt,
      relationType: 'same_company',
      relevanceScore: 0.9,
    });
  }

  for (const m of sameAttendeeMeetings) {
    if (!allRelated.has(m.id)) {
      allRelated.set(m.id, {
        meetingId: m.id,
        meetingTitle: m.title,
        meetingDate: m.scheduledAt,
        relationType: 'same_attendees',
        relevanceScore: 0.7,
      });
    }
  }

  for (const mId of similarTopicMeetingIds) {
    if (!allRelated.has(mId)) {
      const m = await prisma.meeting.findUnique({ where: { id: mId } });
      if (m) {
        allRelated.set(mId, {
          meetingId: m.id,
          meetingTitle: m.title,
          meetingDate: m.scheduledAt,
          relationType: 'same_topic',
          relevanceScore: 0.6,
        });
      }
    }
  }

  // ì ìˆ˜ ìˆœ ì •ë ¬ í›„ ë°˜í™˜
  return Array.from(allRelated.values())
    .sort((a, b) => b.relevanceScore - a.relevanceScore)
    .slice(0, limit);
}
```

---

### 4.25 ê²€ìƒ‰ íˆìŠ¤í† ë¦¬ ë° ì¶”ì²œ API (Part 5)

```typescript
// GET /api/search/suggestions
// ê²€ìƒ‰ ì¶”ì²œ ë° íˆìŠ¤í† ë¦¬ ì¡°íšŒ

interface SearchSuggestionsResponse {
  recentSearches: Array<{
    query: string;
    timestamp: Date;
  }>;
  suggestions: string[];
  frequentTopics: Array<{
    topic: string;
    count: number;
  }>;
}

// ì„œë¹„ìŠ¤ êµ¬í˜„
export async function getSearchSuggestions(userId: string): Promise<SearchSuggestionsResponse> {
  // 1. ìµœê·¼ ê²€ìƒ‰ ê¸°ë¡
  const recentSearches = await prisma.searchHistory.findMany({
    where: { userId },
    orderBy: { createdAt: 'desc' },
    take: 10,
    select: {
      query: true,
      createdAt: true,
    },
  });

  // 2. ìµœê·¼ ë¯¸íŒ… ê¸°ë°˜ ì¶”ì²œ ì£¼ì œ
  const recentMeetings = await prisma.meeting.findMany({
    where: { userId },
    orderBy: { scheduledAt: 'desc' },
    take: 10,
    include: {
      decisions: { select: { content: true } },
    },
  });

  // ê²°ì •ì‚¬í•­ì—ì„œ í‚¤ì›Œë“œ ì¶”ì¶œ
  const allDecisions = recentMeetings.flatMap((m) => m.decisions.map((d) => d.content));
  const keywordCounts = new Map<string, number>();

  for (const decision of allDecisions) {
    const keywords = extractKeywords(decision);
    for (const kw of keywords) {
      keywordCounts.set(kw, (keywordCounts.get(kw) || 0) + 1);
    }
  }

  // 3. ìì£¼ ê²€ìƒ‰ë˜ëŠ” ì£¼ì œ
  const frequentTopics = Array.from(keywordCounts.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10)
    .map(([topic, count]) => ({ topic, count }));

  // 4. ì¶”ì²œ ê²€ìƒ‰ì–´ (íšŒì‚¬ëª…, ì°¸ì„ìëª… ë“±)
  const companies = await prisma.meeting.findMany({
    where: { userId, companyName: { not: null } },
    distinct: ['companyName'],
    select: { companyName: true },
    take: 5,
  });

  const suggestions = [
    ...companies.map((c) => c.companyName!),
    ...frequentTopics.slice(0, 3).map((t) => t.topic),
    'ì´ë²ˆ ì£¼',
    'ë¯¸í™•ì¸',
    'ë¦¬ìŠ¤í¬',
  ];

  return {
    recentSearches: recentSearches.map((s) => ({
      query: s.query,
      timestamp: s.createdAt,
    })),
    suggestions: [...new Set(suggestions)].slice(0, 8),
    frequentTopics: frequentTopics.slice(0, 5),
  };
}

// POST /api/search/history
// ê²€ìƒ‰ ê¸°ë¡ ì €ì¥
export async function saveSearchHistory(
  userId: string,
  query: string,
  resultCount: number
): Promise<void> {
  await prisma.searchHistory.create({
    data: {
      userId,
      query,
      resultCount,
    },
  });
}

function extractKeywords(text: string): string[] {
  // ê°„ë‹¨í•œ í‚¤ì›Œë“œ ì¶”ì¶œ (ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ NLP ì‚¬ìš©)
  return text
    .split(/[\s,.]+/)
    .filter((w) => w.length > 2)
    .filter((w) => !['ê·¸ë¦¬ê³ ', 'í•˜ì§€ë§Œ', 'ê·¸ëŸ¬ë‚˜', 'ë˜í•œ', 'ë”°ë¼ì„œ'].includes(w))
    .slice(0, 3);
}
```

---

### 4.26 Part 5 ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```prisma
// Part 5 ê´€ë ¨ ì¶”ê°€ ìŠ¤í‚¤ë§ˆ

model SearchHistory {
  id          String   @id @default(cuid())
  userId      String
  query       String
  resultCount Int
  createdAt   DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId, createdAt(sort: Desc)])
}

model SearchAnalytics {
  id                String   @id @default(cuid())
  userId            String
  query             String
  queryType         String   // keyword, natural, time, person, decision_element
  semanticSuccess   Boolean
  resultCount       Int
  clickedResultIndex Int?
  timeToClickMs     Int?
  searchTimeMs      Int
  filterUsed        Boolean
  createdAt         DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId, createdAt(sort: Desc)])
  @@index([queryType])
}

model MeetingEmbedding {
  id        String @id @default(cuid())
  meetingId String
  segmentId String
  text      String @db.Text
  embedding Bytes  // ë²¡í„° ë°ì´í„° (ì‹¤ì œë¡œëŠ” Pineconeì— ì €ì¥)

  meeting Meeting @relation(fields: [meetingId], references: [id])

  @@index([meetingId])
}
```

---

**Part 5 í•µì‹¬ ì§€í‘œ:**

```sql
-- ê²€ìƒ‰ ì‚¬ìš©ë¥ 
ê²€ìƒ‰ ì‚¬ìš©ë¥  = count(search_submitted) / count(dau)
ëª©í‘œ: > 20%

-- ê²€ìƒ‰ ì„±ê³µë¥ 
ê²€ìƒ‰ ì„±ê³µë¥  = count(result_clicked) / count(search_submitted)
ëª©í‘œ: > 70%

-- ì²« ê²°ê³¼ í´ë¦­ë¥ 
ì²« ê²°ê³¼ í´ë¦­ë¥  = count(clickedResultIndex = 0) / count(result_clicked)
ëª©í‘œ: > 50%

-- ì‹œë§¨í‹± ê²€ìƒ‰ ì„±ê³µë¥ 
ì‹œë§¨í‹± ì„±ê³µë¥  = count(semanticSuccess = true) / count(search_submitted)
ëª©í‘œ: > 80%

-- í‰ê·  ê²€ìƒ‰ ì‹œê°„
í‰ê·  ê²€ìƒ‰ ì‹œê°„ = avg(timeToClickMs WHERE result_clicked)
ëª©í‘œ: < 10ì´ˆ

-- ì¬ê²€ìƒ‰ ë¹„ìœ¨
ì¬ê²€ìƒ‰ ë¹„ìœ¨ = count(search_submitted WHERE ì´ì „ ê²€ìƒ‰ 5ë¶„ ì´ë‚´) / count(search_submitted)
ëª©í‘œ: < 25%

-- í•„í„° ì‚¬ìš©ë¥ 
í•„í„° ì‚¬ìš©ë¥  = count(filterUsed = true) / count(search_completed)
ëª©í‘œ: < 30% (ì‹œë§¨í‹±ì´ ì˜ ë˜ë©´ í•„í„° ë¶ˆí•„ìš”)
```

---

### 4.27 ì„¤ì • API (Part 5.2)

```typescript
// === ì„¤ì • ê°œìš” ===
// ì„¤ì • ì² í•™: "í•„ìš”í•  ë•Œë§Œ ì°¾ê³ , ë³€ê²½ì€ ìµœì†Œí™”"
// ì„¤ì • ì§„ì…ë¥  < 10%ê°€ ì„±ê³µ ì§€í‘œ (ì˜ ë™ì‘í•˜ë©´ ì„¤ì •í•  í•„ìš” ì—†ìŒ)

// === ì„¤ì • ì¹´í…Œê³ ë¦¬ ===
// 1. í†µí•© ê´€ë¦¬ (40%) - Notion, Calendar OAuth
// 2. ì•Œë¦¼ ì„¤ì • (30%) - ë¹ˆë„, ì¹´í…Œê³ ë¦¬ë³„ on/off
// 3. í”„ë¡œí•„ (15%) - ì´ë¦„, ì´ë©”ì¼, ë¹„ë°€ë²ˆí˜¸
// 4. êµ¬ë… (10%) - í”Œëœ, ê²°ì œ
// 5. ê¸°íƒ€ (5%) - ë°ì´í„°, ë¡œê·¸ì•„ì›ƒ

// === ì„¤ì • ë©”ì¸ API ===
// GET /api/settings
export async function GET(request: NextRequest) {
  const session = await requireAuth(request);

  const settings = await prisma.userSettings.findUnique({
    where: { userId: session.userId },
    include: {
      user: {
        select: {
          id: true,
          name: true,
          email: true,
          profileImage: true,
        }
      },
      integrations: true,
      notificationSettings: true,
      subscription: true,
    }
  });

  // í†µí•© ìƒíƒœ ê³„ì‚°
  const integrationStatus = calculateIntegrationStatus(settings.integrations);

  return NextResponse.json({
    success: true,
    data: {
      profile: {
        id: settings.user.id,
        name: settings.user.name,
        email: settings.user.email,
        profileImage: settings.user.profileImage,
      },
      integrations: {
        notion: integrationStatus.notion,
        googleCalendar: integrationStatus.googleCalendar,
        outlook: integrationStatus.outlook,
        slack: { status: 'coming_soon' },
        salesforce: { status: 'coming_soon' },
      },
      notifications: settings.notificationSettings,
      subscription: {
        plan: settings.subscription?.plan || 'free',
        status: settings.subscription?.status || 'active',
        expiresAt: settings.subscription?.expiresAt,
      },
      dataPrivacy: {
        retentionDays: settings.dataRetentionDays,
        shareAnalytics: settings.shareAnalytics,
      }
    }
  });
}

// í†µí•© ìƒíƒœ ê³„ì‚° í•¨ìˆ˜
function calculateIntegrationStatus(integrations: Integration[]) {
  const statusMap: Record<string, IntegrationStatus> = {};

  const providers = ['notion', 'google_calendar', 'outlook'];

  for (const provider of providers) {
    const integration = integrations.find(i => i.provider === provider);

    if (!integration) {
      statusMap[toCamelCase(provider)] = {
        status: 'disconnected',
        isRequired: provider === 'notion' || provider === 'google_calendar',
      };
    } else if (isTokenExpired(integration)) {
      statusMap[toCamelCase(provider)] = {
        status: 'expired',
        accountEmail: integration.accountEmail,
        expiresAt: integration.tokenExpiresAt,
        isRequired: provider === 'notion' || provider === 'google_calendar',
      };
    } else {
      statusMap[toCamelCase(provider)] = {
        status: 'connected',
        accountEmail: integration.accountEmail,
        connectedAt: integration.connectedAt,
        lastSyncedAt: integration.lastSyncedAt,
      };
    }
  }

  return statusMap;
}
```

---

### 4.28 í†µí•© ê´€ë¦¬ ì„œë¹„ìŠ¤ (Part 5.2)

```typescript
// === OAuth ì—°ë™ ì‹œì‘ ===
// POST /api/settings/integrations/:provider/connect
export async function POST(
  request: NextRequest,
  { params }: { params: { provider: string } }
) {
  const session = await requireAuth(request);
  const { provider } = params;

  // ì§€ì›ë˜ëŠ” í”„ë¡œë°”ì´ë” í™•ì¸
  const supportedProviders = ['notion', 'google_calendar', 'outlook'];
  if (!supportedProviders.includes(provider)) {
    return NextResponse.json({
      success: false,
      error: {
        code: 'UNSUPPORTED_PROVIDER',
        message: `${provider}ëŠ” ì•„ì§ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤`
      }
    }, { status: 400 });
  }

  // OAuth URL ìƒì„±
  const oauthUrl = generateOAuthUrl(provider, {
    userId: session.userId,
    redirectUri: `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/callback/${provider}`,
    state: generateSecureState(session.userId),
    scopes: getProviderScopes(provider),
  });

  // ì—°ë™ ì‹œë„ ë¡œê¹…
  await prisma.integrationEvent.create({
    data: {
      userId: session.userId,
      provider,
      eventType: 'oauth_started',
      timestamp: new Date(),
    }
  });

  return NextResponse.json({
    success: true,
    data: {
      oauthUrl,
      provider,
      expiresIn: 600, // 10ë¶„
    }
  });
}

// í”„ë¡œë°”ì´ë”ë³„ OAuth URL ìƒì„±
function generateOAuthUrl(
  provider: string,
  config: OAuthConfig
): string {
  switch (provider) {
    case 'notion':
      return `https://api.notion.com/v1/oauth/authorize?${new URLSearchParams({
        client_id: process.env.NOTION_CLIENT_ID!,
        redirect_uri: config.redirectUri,
        response_type: 'code',
        state: config.state,
        owner: 'user',
      })}`;

    case 'google_calendar':
      return `https://accounts.google.com/o/oauth2/v2/auth?${new URLSearchParams({
        client_id: process.env.GOOGLE_CLIENT_ID!,
        redirect_uri: config.redirectUri,
        response_type: 'code',
        state: config.state,
        scope: config.scopes.join(' '),
        access_type: 'offline',
        prompt: 'consent',
      })}`;

    case 'outlook':
      return `https://login.microsoftonline.com/common/oauth2/v2.0/authorize?${new URLSearchParams({
        client_id: process.env.OUTLOOK_CLIENT_ID!,
        redirect_uri: config.redirectUri,
        response_type: 'code',
        state: config.state,
        scope: config.scopes.join(' '),
      })}`;

    default:
      throw new Error(`Unknown provider: ${provider}`);
  }
}

// í”„ë¡œë°”ì´ë”ë³„ ìŠ¤ì½”í”„
function getProviderScopes(provider: string): string[] {
  switch (provider) {
    case 'notion':
      return []; // Notionì€ OAuth ê³¼ì •ì—ì„œ ì‚¬ìš©ìê°€ ì„ íƒ

    case 'google_calendar':
      return [
        'https://www.googleapis.com/auth/calendar.readonly',
        'https://www.googleapis.com/auth/calendar.events.readonly',
        'openid',
        'email',
        'profile',
      ];

    case 'outlook':
      return [
        'Calendars.Read',
        'User.Read',
        'offline_access',
      ];

    default:
      return [];
  }
}

// === OAuth ì½œë°± ì²˜ë¦¬ ===
// GET /api/auth/callback/:provider
export async function handleOAuthCallback(
  request: NextRequest,
  { params }: { params: { provider: string } }
) {
  const { searchParams } = new URL(request.url);
  const code = searchParams.get('code');
  const state = searchParams.get('state');
  const error = searchParams.get('error');

  // ì—ëŸ¬ ì²˜ë¦¬
  if (error) {
    return redirectWithError(error, params.provider);
  }

  // ìƒíƒœ ê²€ì¦
  const statePayload = verifyState(state);
  if (!statePayload) {
    return redirectWithError('invalid_state', params.provider);
  }

  try {
    // í† í° êµí™˜
    const tokens = await exchangeCodeForTokens(params.provider, code);

    // ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const accountInfo = await getAccountInfo(params.provider, tokens.accessToken);

    // í†µí•© ì €ì¥/ì—…ë°ì´íŠ¸
    await prisma.integration.upsert({
      where: {
        userId_provider: {
          userId: statePayload.userId,
          provider: params.provider,
        }
      },
      update: {
        accessToken: encrypt(tokens.accessToken),
        refreshToken: tokens.refreshToken ? encrypt(tokens.refreshToken) : null,
        tokenExpiresAt: new Date(Date.now() + tokens.expiresIn * 1000),
        accountEmail: accountInfo.email,
        accountName: accountInfo.name,
        lastSyncedAt: new Date(),
      },
      create: {
        userId: statePayload.userId,
        provider: params.provider,
        accessToken: encrypt(tokens.accessToken),
        refreshToken: tokens.refreshToken ? encrypt(tokens.refreshToken) : null,
        tokenExpiresAt: new Date(Date.now() + tokens.expiresIn * 1000),
        accountEmail: accountInfo.email,
        accountName: accountInfo.name,
        connectedAt: new Date(),
        lastSyncedAt: new Date(),
      }
    });

    // ì—°ë™ ì„±ê³µ ë¡œê¹…
    await prisma.integrationEvent.create({
      data: {
        userId: statePayload.userId,
        provider: params.provider,
        eventType: 'connected',
        metadata: {
          accountEmail: accountInfo.email,
        },
        timestamp: new Date(),
      }
    });

    // Notionì¸ ê²½ìš° ê¸°ë³¸ ë°ì´í„°ë² ì´ìŠ¤ ì„ íƒ í™”ë©´ìœ¼ë¡œ
    if (params.provider === 'notion') {
      return NextResponse.redirect(
        `${process.env.NEXT_PUBLIC_APP_URL}/settings/integrations/notion/select-database`
      );
    }

    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_APP_URL}/settings/integrations?connected=${params.provider}`
    );

  } catch (error) {
    await logOAuthError(statePayload.userId, params.provider, error);
    return redirectWithError('token_exchange_failed', params.provider);
  }
}

// === í†µí•© ì—°ê²° í•´ì œ ===
// DELETE /api/settings/integrations/:provider
export async function DELETE(
  request: NextRequest,
  { params }: { params: { provider: string } }
) {
  const session = await requireAuth(request);
  const { provider } = params;

  // í•„ìˆ˜ í†µí•©ì¸ì§€ í™•ì¸
  const isRequired = ['notion', 'google_calendar'].includes(provider);

  // í•´ì œ í™•ì¸ í† í° ê²€ì¦ (ì´ì¤‘ í™•ì¸)
  const body = await request.json();
  if (!body.confirmationToken) {
    return NextResponse.json({
      success: false,
      error: {
        code: 'CONFIRMATION_REQUIRED',
        message: 'ì—°ê²° í•´ì œë¥¼ ìœ„í•´ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤',
        isRequired,
        consequences: getDisconnectionConsequences(provider),
      }
    }, { status: 400 });
  }

  // í†µí•© ì‚­ì œ
  await prisma.integration.delete({
    where: {
      userId_provider: {
        userId: session.userId,
        provider,
      }
    }
  });

  // ì—°ê²° í•´ì œ ë¡œê¹…
  await prisma.integrationEvent.create({
    data: {
      userId: session.userId,
      provider,
      eventType: 'disconnected',
      metadata: {
        reason: body.reason || 'user_initiated',
      },
      timestamp: new Date(),
    }
  });

  return NextResponse.json({
    success: true,
    data: {
      provider,
      disconnectedAt: new Date().toISOString(),
      warning: isRequired
        ? 'í•„ìˆ˜ í†µí•©ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤. ì¼ë¶€ ê¸°ëŠ¥ì´ ì œí•œë©ë‹ˆë‹¤.'
        : null,
    }
  });
}

// ì—°ê²° í•´ì œ ê²°ê³¼ ì„¤ëª…
function getDisconnectionConsequences(provider: string): string[] {
  switch (provider) {
    case 'notion':
      return [
        'ìƒˆë¡œìš´ ë¯¸íŒ… ê¸°ë¡ì´ Notionì— ì €ì¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤',
        'ê¸°ì¡´ ì €ì¥ëœ ê¸°ë¡ì€ Notionì— ìœ ì§€ë©ë‹ˆë‹¤',
        'ì¬ì—°ê²° ì‹œ ë‹¤ì‹œ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤',
      ];

    case 'google_calendar':
      return [
        'Google Calendar ë¯¸íŒ…ì´ Todayì— í‘œì‹œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤',
        'ë¯¸íŒ… ìë™ ì¤€ë¹„ ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤',
        'Outlook Calendarë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤',
      ];

    case 'outlook':
      return [
        'Outlook Calendar ë¯¸íŒ…ì´ Todayì— í‘œì‹œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤',
        'Google Calendarë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤',
      ];

    default:
      return [];
  }
}

// === Notion ë°ì´í„°ë² ì´ìŠ¤ ì„ íƒ ===
// GET /api/settings/integrations/notion/databases
export async function getNotionDatabases(request: NextRequest) {
  const session = await requireAuth(request);

  const integration = await getIntegrationWithRefresh(
    session.userId,
    'notion'
  );

  if (!integration) {
    return NextResponse.json({
      success: false,
      error: {
        code: 'NOT_CONNECTED',
        message: 'Notionì´ ì—°ê²°ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤',
      }
    }, { status: 400 });
  }

  // Notion APIë¡œ ë°ì´í„°ë² ì´ìŠ¤ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
  const notionClient = new Client({ auth: decrypt(integration.accessToken) });

  const response = await notionClient.search({
    filter: { property: 'object', value: 'database' },
    sort: { direction: 'descending', timestamp: 'last_edited_time' },
  });

  const databases = response.results
    .filter((db: any) => db.object === 'database')
    .map((db: any) => ({
      id: db.id,
      title: db.title?.[0]?.plain_text || 'Untitled',
      icon: db.icon?.emoji || db.icon?.external?.url || null,
      lastEditedAt: db.last_edited_time,
    }));

  return NextResponse.json({
    success: true,
    data: {
      databases,
      currentDatabaseId: integration.notionDatabaseId,
    }
  });
}

// POST /api/settings/integrations/notion/databases
export async function selectNotionDatabase(request: NextRequest) {
  const session = await requireAuth(request);
  const body = await request.json();

  const schema = z.object({
    databaseId: z.string().min(1),
  });

  const validated = schema.parse(body);

  // ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼ ê°€ëŠ¥í•œì§€ í™•ì¸
  const integration = await getIntegrationWithRefresh(session.userId, 'notion');
  const notionClient = new Client({ auth: decrypt(integration.accessToken) });

  try {
    await notionClient.databases.retrieve({
      database_id: validated.databaseId,
    });
  } catch (error) {
    return NextResponse.json({
      success: false,
      error: {
        code: 'DATABASE_NOT_ACCESSIBLE',
        message: 'ì„ íƒí•œ ë°ì´í„°ë² ì´ìŠ¤ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
      }
    }, { status: 400 });
  }

  // ì €ì¥
  await prisma.integration.update({
    where: {
      userId_provider: {
        userId: session.userId,
        provider: 'notion',
      }
    },
    data: {
      notionDatabaseId: validated.databaseId,
    }
  });

  return NextResponse.json({
    success: true,
    data: {
      databaseId: validated.databaseId,
      message: 'Notion ë°ì´í„°ë² ì´ìŠ¤ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤',
    }
  });
}
```

---

### 4.29 ì•Œë¦¼ ì„¤ì • ì„œë¹„ìŠ¤ (Part 5.2)

```typescript
// === ì•Œë¦¼ ì„¤ì • ì¡°íšŒ ===
// GET /api/settings/notifications
export async function GET(request: NextRequest) {
  const session = await requireAuth(request);

  const settings = await prisma.notificationSettings.findUnique({
    where: { userId: session.userId },
  });

  // ê¸°ë³¸ê°’ ë°˜í™˜
  if (!settings) {
    return NextResponse.json({
      success: true,
      data: getDefaultNotificationSettings(),
    });
  }

  return NextResponse.json({
    success: true,
    data: {
      // ì „ì²´ ë¹ˆë„ (low/medium/high)
      frequency: settings.frequency,

      // ë¯¸íŒ… ì „
      beforeMeeting: {
        prepReminder: settings.prepReminderEnabled,
        prepReminderTime: settings.prepReminderMinutes, // 15ë¶„ ì „
        calendarSync: settings.calendarSyncEnabled,
      },

      // ë¯¸íŒ… ì¤‘
      duringMeeting: {
        hudAlerts: settings.hudAlertsEnabled,
        gapDetection: settings.gapDetectionEnabled,
        suggestionLevel: settings.suggestionLevel, // minimal/balanced/proactive
      },

      // ë¯¸íŒ… í›„
      afterMeeting: {
        summaryReady: settings.summaryReadyEnabled,
        actionItemReminder: settings.actionItemReminderEnabled,
        followUpSuggestion: settings.followUpSuggestionEnabled,
      },

      // ë°©í•´ ê¸ˆì§€
      doNotDisturb: {
        enabled: settings.dndEnabled,
        startTime: settings.dndStartTime, // "22:00"
        endTime: settings.dndEndTime,     // "08:00"
        weekendsOff: settings.dndWeekendsOff,
      },

      // ì±„ë„
      channels: {
        inApp: settings.inAppEnabled,
        email: settings.emailEnabled,
        emailDigest: settings.emailDigestFrequency, // 'realtime' | 'daily' | 'weekly' | 'off'
      }
    }
  });
}

// ê¸°ë³¸ ì•Œë¦¼ ì„¤ì •
function getDefaultNotificationSettings(): NotificationSettingsResponse {
  return {
    frequency: 'medium',
    beforeMeeting: {
      prepReminder: true,
      prepReminderTime: 15,
      calendarSync: true,
    },
    duringMeeting: {
      hudAlerts: true,
      gapDetection: true,
      suggestionLevel: 'balanced',
    },
    afterMeeting: {
      summaryReady: true,
      actionItemReminder: true,
      followUpSuggestion: false,
    },
    doNotDisturb: {
      enabled: false,
      startTime: '22:00',
      endTime: '08:00',
      weekendsOff: false,
    },
    channels: {
      inApp: true,
      email: true,
      emailDigest: 'daily',
    }
  };
}

// === ì•Œë¦¼ ì„¤ì • ì—…ë°ì´íŠ¸ ===
// PATCH /api/settings/notifications
export async function PATCH(request: NextRequest) {
  const session = await requireAuth(request);
  const body = await request.json();

  const schema = z.object({
    frequency: z.enum(['low', 'medium', 'high']).optional(),

    beforeMeeting: z.object({
      prepReminder: z.boolean().optional(),
      prepReminderTime: z.number().min(5).max(60).optional(),
      calendarSync: z.boolean().optional(),
    }).optional(),

    duringMeeting: z.object({
      hudAlerts: z.boolean().optional(),
      gapDetection: z.boolean().optional(),
      suggestionLevel: z.enum(['minimal', 'balanced', 'proactive']).optional(),
    }).optional(),

    afterMeeting: z.object({
      summaryReady: z.boolean().optional(),
      actionItemReminder: z.boolean().optional(),
      followUpSuggestion: z.boolean().optional(),
    }).optional(),

    doNotDisturb: z.object({
      enabled: z.boolean().optional(),
      startTime: z.string().regex(/^\d{2}:\d{2}$/).optional(),
      endTime: z.string().regex(/^\d{2}:\d{2}$/).optional(),
      weekendsOff: z.boolean().optional(),
    }).optional(),

    channels: z.object({
      inApp: z.boolean().optional(),
      email: z.boolean().optional(),
      emailDigest: z.enum(['realtime', 'daily', 'weekly', 'off']).optional(),
    }).optional(),
  });

  const validated = schema.parse(body);

  // ë¹ˆë„ ë³€ê²½ ì‹œ ê´€ë ¨ ì„¤ì • ìë™ ì¡°ì •
  if (validated.frequency) {
    validated.duringMeeting = {
      ...validated.duringMeeting,
      ...getFrequencyPreset(validated.frequency),
    };
  }

  // Flatten for Prisma update
  const updateData = flattenNotificationSettings(validated);

  const updated = await prisma.notificationSettings.upsert({
    where: { userId: session.userId },
    update: updateData,
    create: {
      userId: session.userId,
      ...getDefaultNotificationSettingsForDb(),
      ...updateData,
    }
  });

  // ì„¤ì • ë³€ê²½ ë¡œê¹…
  await prisma.settingsEvent.create({
    data: {
      userId: session.userId,
      category: 'notification',
      action: 'updated',
      changes: validated,
      timestamp: new Date(),
    }
  });

  return NextResponse.json({
    success: true,
    data: {
      message: 'ì•Œë¦¼ ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤',
      updated: formatNotificationSettings(updated),
    }
  });
}

// ë¹ˆë„ í”„ë¦¬ì…‹
function getFrequencyPreset(frequency: 'low' | 'medium' | 'high') {
  switch (frequency) {
    case 'low':
      return {
        suggestionLevel: 'minimal' as const,
        gapDetection: false,
        followUpSuggestion: false,
      };
    case 'medium':
      return {
        suggestionLevel: 'balanced' as const,
        gapDetection: true,
        followUpSuggestion: false,
      };
    case 'high':
      return {
        suggestionLevel: 'proactive' as const,
        gapDetection: true,
        followUpSuggestion: true,
      };
  }
}

// === ì•Œë¦¼ í…ŒìŠ¤íŠ¸ ===
// POST /api/settings/notifications/test
export async function testNotification(request: NextRequest) {
  const session = await requireAuth(request);
  const body = await request.json();

  const schema = z.object({
    type: z.enum(['prep_reminder', 'hud_alert', 'summary_ready', 'action_item']),
    channel: z.enum(['in_app', 'email']),
  });

  const validated = schema.parse(body);

  // í…ŒìŠ¤íŠ¸ ì•Œë¦¼ ë°œì†¡
  await notificationService.sendTestNotification(
    session.userId,
    validated.type,
    validated.channel
  );

  return NextResponse.json({
    success: true,
    data: {
      message: 'í…ŒìŠ¤íŠ¸ ì•Œë¦¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤',
      type: validated.type,
      channel: validated.channel,
    }
  });
}
```

---

### 4.30 í”„ë¡œí•„ ë° ê³„ì • ì„œë¹„ìŠ¤ (Part 5.2)

```typescript
// === í”„ë¡œí•„ ì¡°íšŒ ===
// GET /api/settings/profile
export async function GET(request: NextRequest) {
  const session = await requireAuth(request);

  const user = await prisma.user.findUnique({
    where: { id: session.userId },
    select: {
      id: true,
      name: true,
      email: true,
      profileImage: true,
      createdAt: true,
      lastLoginAt: true,
    }
  });

  return NextResponse.json({
    success: true,
    data: {
      profile: user,
      canChangeEmail: !user.email.includes('@social'), // ì†Œì…œ ë¡œê·¸ì¸ì´ ì•„ë‹Œ ê²½ìš°ë§Œ
    }
  });
}

// === í”„ë¡œí•„ ì—…ë°ì´íŠ¸ ===
// PATCH /api/settings/profile
export async function PATCH(request: NextRequest) {
  const session = await requireAuth(request);
  const body = await request.json();

  const schema = z.object({
    name: z.string().min(1).max(50).optional(),
    profileImage: z.string().url().optional(),
  });

  const validated = schema.parse(body);

  const updated = await prisma.user.update({
    where: { id: session.userId },
    data: validated,
    select: {
      id: true,
      name: true,
      email: true,
      profileImage: true,
    }
  });

  // í”„ë¡œí•„ ë³€ê²½ ë¡œê¹…
  await prisma.settingsEvent.create({
    data: {
      userId: session.userId,
      category: 'profile',
      action: 'updated',
      changes: Object.keys(validated),
      timestamp: new Date(),
    }
  });

  return NextResponse.json({
    success: true,
    data: {
      profile: updated,
      message: 'í”„ë¡œí•„ì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤',
    }
  });
}

// === í”„ë¡œí•„ ì´ë¯¸ì§€ ì—…ë¡œë“œ ===
// POST /api/settings/profile/image
export async function uploadProfileImage(request: NextRequest) {
  const session = await requireAuth(request);
  const formData = await request.formData();
  const file = formData.get('image') as File;

  if (!file) {
    return NextResponse.json({
      success: false,
      error: { code: 'NO_FILE', message: 'íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤' }
    }, { status: 400 });
  }

  // íŒŒì¼ ìœ íš¨ì„± ê²€ì‚¬
  const maxSize = 5 * 1024 * 1024; // 5MB
  const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];

  if (file.size > maxSize) {
    return NextResponse.json({
      success: false,
      error: { code: 'FILE_TOO_LARGE', message: 'íŒŒì¼ í¬ê¸°ëŠ” 5MB ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤' }
    }, { status: 400 });
  }

  if (!allowedTypes.includes(file.type)) {
    return NextResponse.json({
      success: false,
      error: { code: 'INVALID_TYPE', message: 'JPG, PNG, WebP íŒŒì¼ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤' }
    }, { status: 400 });
  }

  // ì´ë¯¸ì§€ ë¦¬ì‚¬ì´ì¦ˆ ë° ì—…ë¡œë“œ
  const buffer = Buffer.from(await file.arrayBuffer());
  const resized = await sharp(buffer)
    .resize(200, 200, { fit: 'cover' })
    .webp({ quality: 80 })
    .toBuffer();

  const fileName = `profiles/${session.userId}/${Date.now()}.webp`;
  const url = await uploadToStorage(fileName, resized, 'image/webp');

  // í”„ë¡œí•„ ì—…ë°ì´íŠ¸
  await prisma.user.update({
    where: { id: session.userId },
    data: { profileImage: url },
  });

  return NextResponse.json({
    success: true,
    data: {
      imageUrl: url,
      message: 'í”„ë¡œí•„ ì´ë¯¸ì§€ê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤',
    }
  });
}

// === ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ ===
// POST /api/settings/password
export async function changePassword(request: NextRequest) {
  const session = await requireAuth(request);
  const body = await request.json();

  const schema = z.object({
    currentPassword: z.string().min(1),
    newPassword: z.string().min(8).regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
      'ëŒ€ì†Œë¬¸ìì™€ ìˆ«ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤'
    ),
    confirmPassword: z.string(),
  }).refine(data => data.newPassword === data.confirmPassword, {
    message: 'ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤',
    path: ['confirmPassword'],
  });

  const validated = schema.parse(body);

  // í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ í™•ì¸
  const user = await prisma.user.findUnique({
    where: { id: session.userId },
    select: { passwordHash: true },
  });

  const isValid = await bcrypt.compare(validated.currentPassword, user.passwordHash);
  if (!isValid) {
    return NextResponse.json({
      success: false,
      error: { code: 'INVALID_PASSWORD', message: 'í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤' }
    }, { status: 400 });
  }

  // ìƒˆ ë¹„ë°€ë²ˆí˜¸ í•´ì‹œ ë° ì €ì¥
  const newHash = await bcrypt.hash(validated.newPassword, 12);

  await prisma.user.update({
    where: { id: session.userId },
    data: { passwordHash: newHash },
  });

  // ë‹¤ë¥¸ ì„¸ì…˜ ëª¨ë‘ ë§Œë£Œ
  await prisma.session.deleteMany({
    where: {
      userId: session.userId,
      id: { not: session.sessionId },
    }
  });

  // ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ ë¡œê¹…
  await prisma.settingsEvent.create({
    data: {
      userId: session.userId,
      category: 'account',
      action: 'password_changed',
      metadata: { otherSessionsInvalidated: true },
      timestamp: new Date(),
    }
  });

  return NextResponse.json({
    success: true,
    data: {
      message: 'ë¹„ë°€ë²ˆí˜¸ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ê¸°ê¸°ì—ì„œ ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì•¼ í•©ë‹ˆë‹¤.',
    }
  });
}

// === ê³„ì • ì‚­ì œ ===
// DELETE /api/settings/account
export async function deleteAccount(request: NextRequest) {
  const session = await requireAuth(request);
  const body = await request.json();

  const schema = z.object({
    password: z.string().min(1),
    reason: z.string().optional(),
    confirmText: z.literal('ê³„ì • ì‚­ì œ'),
  });

  const validated = schema.parse(body);

  // ë¹„ë°€ë²ˆí˜¸ í™•ì¸
  const user = await prisma.user.findUnique({
    where: { id: session.userId },
    select: { passwordHash: true, email: true },
  });

  const isValid = await bcrypt.compare(validated.password, user.passwordHash);
  if (!isValid) {
    return NextResponse.json({
      success: false,
      error: { code: 'INVALID_PASSWORD', message: 'ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤' }
    }, { status: 400 });
  }

  // ì†Œí”„íŠ¸ ì‚­ì œ (30ì¼ ë³´ê´€ í›„ ì™„ì „ ì‚­ì œ)
  await prisma.user.update({
    where: { id: session.userId },
    data: {
      deletedAt: new Date(),
      email: `deleted_${session.userId}@deleted.onno.app`,
      name: 'Deleted User',
    }
  });

  // ëª¨ë“  ì„¸ì…˜ ì‚­ì œ
  await prisma.session.deleteMany({
    where: { userId: session.userId },
  });

  // ê³„ì • ì‚­ì œ ë¡œê¹…
  await prisma.accountDeletionLog.create({
    data: {
      userId: session.userId,
      originalEmail: user.email,
      reason: validated.reason,
      deletedAt: new Date(),
      scheduledPermanentDeleteAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
    }
  });

  return NextResponse.json({
    success: true,
    data: {
      message: 'ê³„ì •ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤. 30ì¼ ì´ë‚´ì— ë‹¤ì‹œ ë¡œê·¸ì¸í•˜ë©´ ê³„ì •ì„ ë³µêµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
      permanentDeleteAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
    }
  });
}
```

---

### 4.31 ë°ì´í„° í”„ë¼ì´ë²„ì‹œ ì„œë¹„ìŠ¤ (Part 5.2)

```typescript
// === ë°ì´í„° ì„¤ì • ì¡°íšŒ ===
// GET /api/settings/data-privacy
export async function GET(request: NextRequest) {
  const session = await requireAuth(request);

  const settings = await prisma.userSettings.findUnique({
    where: { userId: session.userId },
    select: {
      dataRetentionDays: true,
      shareAnalytics: true,
      allowAiTraining: true,
    }
  });

  const stats = await prisma.$queryRaw`
    SELECT
      COUNT(DISTINCT m.id) as meeting_count,
      COUNT(DISTINCT d.id) as decision_count,
      SUM(LENGTH(t.content)) as total_transcript_bytes
    FROM "Meeting" m
    LEFT JOIN "Decision" d ON d."meetingId" = m.id
    LEFT JOIN "Transcript" t ON t."meetingId" = m.id
    WHERE m."userId" = ${session.userId}
  `;

  return NextResponse.json({
    success: true,
    data: {
      retention: {
        days: settings?.dataRetentionDays || 365,
        options: [30, 90, 180, 365, -1], // -1 = ë¬´ì œí•œ
      },
      privacy: {
        shareAnalytics: settings?.shareAnalytics ?? true,
        allowAiTraining: settings?.allowAiTraining ?? false,
      },
      dataStats: {
        meetingCount: Number(stats[0].meeting_count),
        decisionCount: Number(stats[0].decision_count),
        storageUsedMb: Math.round(Number(stats[0].total_transcript_bytes || 0) / 1024 / 1024 * 10) / 10,
      }
    }
  });
}

// === ë°ì´í„° ì„¤ì • ì—…ë°ì´íŠ¸ ===
// PATCH /api/settings/data-privacy
export async function PATCH(request: NextRequest) {
  const session = await requireAuth(request);
  const body = await request.json();

  const schema = z.object({
    dataRetentionDays: z.number().min(-1).max(730).optional(),
    shareAnalytics: z.boolean().optional(),
    allowAiTraining: z.boolean().optional(),
  });

  const validated = schema.parse(body);

  await prisma.userSettings.upsert({
    where: { userId: session.userId },
    update: validated,
    create: {
      userId: session.userId,
      ...validated,
    }
  });

  // ë³´ì¡´ ê¸°ê°„ ë³€ê²½ ì‹œ ì •ë¦¬ ì‘ì—… ìŠ¤ì¼€ì¤„
  if (validated.dataRetentionDays && validated.dataRetentionDays > 0) {
    await scheduleDataCleanup(session.userId, validated.dataRetentionDays);
  }

  return NextResponse.json({
    success: true,
    data: {
      message: 'ë°ì´í„° ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤',
    }
  });
}

// === ë°ì´í„° ë‚´ë³´ë‚´ê¸° ===
// POST /api/settings/data-privacy/export
export async function exportData(request: NextRequest) {
  const session = await requireAuth(request);

  // ê¸°ì¡´ ì§„í–‰ ì¤‘ì¸ ë‚´ë³´ë‚´ê¸° í™•ì¸
  const existingExport = await prisma.dataExport.findFirst({
    where: {
      userId: session.userId,
      status: 'processing',
    }
  });

  if (existingExport) {
    return NextResponse.json({
      success: false,
      error: {
        code: 'EXPORT_IN_PROGRESS',
        message: 'ì´ë¯¸ ë°ì´í„° ë‚´ë³´ë‚´ê¸°ê°€ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤',
        exportId: existingExport.id,
        startedAt: existingExport.createdAt,
      }
    }, { status: 400 });
  }

  // ë‚´ë³´ë‚´ê¸° ì‘ì—… ìƒì„±
  const exportJob = await prisma.dataExport.create({
    data: {
      userId: session.userId,
      status: 'processing',
      format: 'zip',
    }
  });

  // ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ì‹œì‘
  await exportQueue.add('export-user-data', {
    exportId: exportJob.id,
    userId: session.userId,
  });

  return NextResponse.json({
    success: true,
    data: {
      exportId: exportJob.id,
      status: 'processing',
      message: 'ë°ì´í„° ë‚´ë³´ë‚´ê¸°ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ì™„ë£Œë˜ë©´ ì´ë©”ì¼ë¡œ ì•Œë ¤ë“œë¦½ë‹ˆë‹¤.',
      estimatedTime: 'ì•½ 5-10ë¶„',
    }
  });
}

// === ë°ì´í„° ë‚´ë³´ë‚´ê¸° ìƒíƒœ í™•ì¸ ===
// GET /api/settings/data-privacy/export/:exportId
export async function getExportStatus(
  request: NextRequest,
  { params }: { params: { exportId: string } }
) {
  const session = await requireAuth(request);

  const exportJob = await prisma.dataExport.findFirst({
    where: {
      id: params.exportId,
      userId: session.userId,
    }
  });

  if (!exportJob) {
    return NextResponse.json({
      success: false,
      error: { code: 'NOT_FOUND', message: 'ë‚´ë³´ë‚´ê¸° ì‘ì—…ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤' }
    }, { status: 404 });
  }

  return NextResponse.json({
    success: true,
    data: {
      exportId: exportJob.id,
      status: exportJob.status,
      downloadUrl: exportJob.status === 'completed' ? exportJob.downloadUrl : null,
      expiresAt: exportJob.expiresAt,
      createdAt: exportJob.createdAt,
      completedAt: exportJob.completedAt,
    }
  });
}

// === ë°ì´í„° ì‚­ì œ ìš”ì²­ ===
// POST /api/settings/data-privacy/delete-data
export async function requestDataDeletion(request: NextRequest) {
  const session = await requireAuth(request);
  const body = await request.json();

  const schema = z.object({
    dataType: z.enum(['meetings', 'decisions', 'transcripts', 'all']),
    dateRange: z.object({
      start: z.string().datetime().optional(),
      end: z.string().datetime().optional(),
    }).optional(),
    confirm: z.literal(true),
  });

  const validated = schema.parse(body);

  // ì‚­ì œ ì‘ì—… ìƒì„±
  const deletionJob = await prisma.dataDeletion.create({
    data: {
      userId: session.userId,
      dataType: validated.dataType,
      dateRange: validated.dateRange || null,
      status: 'pending',
      scheduledAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24ì‹œê°„ í›„
    }
  });

  // í™•ì¸ ì´ë©”ì¼ ë°œì†¡
  await sendDeletionConfirmationEmail(session.userId, deletionJob.id);

  return NextResponse.json({
    success: true,
    data: {
      deletionId: deletionJob.id,
      status: 'pending',
      message: 'ë°ì´í„° ì‚­ì œê°€ ì˜ˆì•½ë˜ì—ˆìŠµë‹ˆë‹¤. 24ì‹œê°„ ë‚´ì— í™•ì¸ ì´ë©”ì¼ì˜ ë§í¬ë¥¼ í´ë¦­í•´ì£¼ì„¸ìš”.',
      scheduledAt: deletionJob.scheduledAt,
      canCancelBefore: deletionJob.scheduledAt,
    }
  });
}
```

---

### 4.32 Part 5.2 ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```prisma
// Part 5.2 ê´€ë ¨ ì¶”ê°€ ìŠ¤í‚¤ë§ˆ

model UserSettings {
  id              String   @id @default(cuid())
  userId          String   @unique

  // ë°ì´í„° í”„ë¼ì´ë²„ì‹œ
  dataRetentionDays Int    @default(365)
  shareAnalytics    Boolean @default(true)
  allowAiTraining   Boolean @default(false)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])
}

model Integration {
  id              String   @id @default(cuid())
  userId          String
  provider        String   // 'notion' | 'google_calendar' | 'outlook'

  accessToken     String   @db.Text  // encrypted
  refreshToken    String?  @db.Text  // encrypted
  tokenExpiresAt  DateTime

  accountEmail    String?
  accountName     String?

  // Notion ì „ìš©
  notionDatabaseId String?
  notionWorkspace  String?

  connectedAt     DateTime @default(now())
  lastSyncedAt    DateTime?

  user User @relation(fields: [userId], references: [id])

  @@unique([userId, provider])
  @@index([provider])
}

model IntegrationEvent {
  id          String   @id @default(cuid())
  userId      String
  provider    String
  eventType   String   // 'oauth_started' | 'connected' | 'disconnected' | 'refresh_failed' | 'sync_completed'
  metadata    Json?
  timestamp   DateTime @default(now())

  @@index([userId, timestamp(sort: Desc)])
  @@index([provider, eventType])
}

model NotificationSettings {
  id              String   @id @default(cuid())
  userId          String   @unique

  frequency       String   @default("medium") // 'low' | 'medium' | 'high'

  // ë¯¸íŒ… ì „
  prepReminderEnabled   Boolean @default(true)
  prepReminderMinutes   Int     @default(15)
  calendarSyncEnabled   Boolean @default(true)

  // ë¯¸íŒ… ì¤‘
  hudAlertsEnabled      Boolean @default(true)
  gapDetectionEnabled   Boolean @default(true)
  suggestionLevel       String  @default("balanced") // 'minimal' | 'balanced' | 'proactive'

  // ë¯¸íŒ… í›„
  summaryReadyEnabled       Boolean @default(true)
  actionItemReminderEnabled Boolean @default(true)
  followUpSuggestionEnabled Boolean @default(false)

  // ë°©í•´ ê¸ˆì§€
  dndEnabled        Boolean @default(false)
  dndStartTime      String? // "22:00"
  dndEndTime        String? // "08:00"
  dndWeekendsOff    Boolean @default(false)

  // ì±„ë„
  inAppEnabled          Boolean @default(true)
  emailEnabled          Boolean @default(true)
  emailDigestFrequency  String  @default("daily") // 'realtime' | 'daily' | 'weekly' | 'off'

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])
}

model SettingsEvent {
  id          String   @id @default(cuid())
  userId      String
  category    String   // 'profile' | 'notification' | 'integration' | 'account' | 'data_privacy'
  action      String   // 'opened' | 'updated' | 'saved' | 'cancelled' | 'password_changed'
  changes     Json?
  metadata    Json?
  timestamp   DateTime @default(now())

  @@index([userId, timestamp(sort: Desc)])
  @@index([category, action])
}

model DataExport {
  id          String   @id @default(cuid())
  userId      String
  status      String   @default("pending") // 'pending' | 'processing' | 'completed' | 'failed'
  format      String   @default("zip")

  downloadUrl String?
  fileSizeBytes BigInt?

  createdAt   DateTime @default(now())
  completedAt DateTime?
  expiresAt   DateTime?

  @@index([userId, status])
}

model DataDeletion {
  id          String   @id @default(cuid())
  userId      String
  dataType    String   // 'meetings' | 'decisions' | 'transcripts' | 'all'
  dateRange   Json?
  status      String   @default("pending") // 'pending' | 'confirmed' | 'processing' | 'completed' | 'cancelled'

  scheduledAt DateTime
  confirmedAt DateTime?
  completedAt DateTime?
  cancelledAt DateTime?

  createdAt   DateTime @default(now())

  @@index([userId, status])
  @@index([scheduledAt, status])
}

model AccountDeletionLog {
  id                        String   @id @default(cuid())
  userId                    String
  originalEmail             String
  reason                    String?
  deletedAt                 DateTime
  scheduledPermanentDeleteAt DateTime
  permanentlyDeletedAt      DateTime?

  @@index([scheduledPermanentDeleteAt, permanentlyDeletedAt])
}
```

---

**Part 5.2 í•µì‹¬ ì§€í‘œ:**

```sql
-- ì„¤ì • ì§„ì…ë¥  (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
ì„¤ì • ì§„ì…ë¥  = count(settings_opened) / count(dau)
ëª©í‘œ: < 10% (ì˜ ë™ì‘í•˜ë©´ ì„¤ì • í•„ìš” ì—†ìŒ)

-- í‰ê·  ì„¤ì • ì²´ë¥˜ ì‹œê°„ (ì§§ì„ìˆ˜ë¡ ì¢‹ìŒ)
í‰ê·  ì²´ë¥˜ ì‹œê°„ = avg(settings_closed.timestamp - settings_opened.timestamp)
ëª©í‘œ: < 60ì´ˆ

-- í†µí•© ì—°ê²° ì„±ê³µë¥ 
í†µí•© ì„±ê³µë¥  = count(oauth_connected) / count(oauth_started)
ëª©í‘œ: > 85%

-- ì•Œë¦¼ ì„¤ì • ë³€ê²½ë¥ 
ì•Œë¦¼ ë³€ê²½ë¥  = count(notification_settings_updated) / count(settings_opened)
ëª©í‘œ: < 30% (ê¸°ë³¸ê°’ì´ ì í•©í•˜ë©´ ë³€ê²½ ë¶ˆí•„ìš”)

-- í•„ìˆ˜ í†µí•© ì—°ê²°ë¥ 
í•„ìˆ˜ ì—°ê²°ë¥  = count(users WHERE notion_connected AND calendar_connected) / count(active_users)
ëª©í‘œ: > 95%

-- ë°ì´í„° ë‚´ë³´ë‚´ê¸° ì™„ë£Œìœ¨
ë‚´ë³´ë‚´ê¸° ì™„ë£Œìœ¨ = count(export_completed) / count(export_requested)
ëª©í‘œ: > 99%

-- ê³„ì • ì‚­ì œ ì·¨ì†Œìœ¨ (ìœ ì§€ìœ¨)
ì‚­ì œ ì·¨ì†Œìœ¨ = count(deletion_cancelled) / count(deletion_requested)
ì§€í‘œ: ë†’ì„ìˆ˜ë¡ ì‚¬ìš©ì ìœ ì§€
```

---

## 5. WebSocket ì´ë²¤íŠ¸

### 5.1 ì—°ê²°

```typescript
// Client â†’ Server
socket.emit('authenticate', {
  token: 'jwt_token'
});

// Server â†’ Client
socket.emit('authenticated', {
  userId: 'usr_123'
});
```

### 5.2 ë¯¸íŒ… ê´€ë ¨

```typescript
// Client â†’ Server (ë¯¸íŒ… ì‹œì‘)
socket.emit('meeting:start', {
  meetingId: 'mtg_123'
});

// Server â†’ Client (ì „ì‚¬ ì‹¤ì‹œê°„ ìˆ˜ì‹ )
socket.on('transcript', (data) => {
  // {
  //   id: 'tr_1',
  //   timestamp: '2025-12-29T10:05:23Z',
  //   speaker: 'ê¹€ëŒ€í‘œ',
  //   text: 'MAUëŠ” 10ë§Œì…ë‹ˆë‹¤.',
  //   confidence: 0.95
  // }
});

// Server â†’ Client (ì¸ì‚¬ì´íŠ¸ ìˆ˜ì‹ )
socket.on('insight', (data) => {
  // {
  //   id: 'ins_1',
  //   type: 'METRIC',
  //   content: 'MAU 10ë§Œ',
  //   confidence: 0.88
  // }
});

// Server â†’ Client (ì•Œë¦¼ ìˆ˜ì‹ )
socket.on('alert', (data) => {
  // {
  //   id: 'alt_1',
  //   level: 2,
  //   title: 'í™•ì¸ í•„ìš”',
  //   message: 'ì˜ˆì‚° ìŠ¹ì¸ í”„ë¡œì„¸ìŠ¤ ë¯¸í™•ì¸',
  //   suggestedQuestion: 'ìŠ¹ì¸ì€ ëˆ„ê°€ í•˜ì‹œë‚˜ìš”?'
  // }
});

// Client â†’ Server (ë¯¸íŒ… ì¢…ë£Œ)
socket.emit('meeting:end', {
  meetingId: 'mtg_123'
});
```

### 5.3 HUD ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ (Part 3)

```typescript
// Server â†’ Client (HUD ì„¸ì…˜ ì‹œì‘)
socket.on('hud:session_started', (data) => {
  // {
  //   sessionId: 'hud_sess_001',
  //   meetingId: 'mtg_003',
  //   platform: 'zoom',
  //   startedAt: '2025-12-30T10:00:05Z'
  // }
});

// Server â†’ Client (ì‹¤ì‹œê°„ ì•Œë¦¼)
socket.on('hud:alert', (data) => {
  // {
  //   id: 'alt_001',
  //   level: 2,
  //   category: 'gap',
  //   icon: 'ğŸ’¡',
  //   title: 'ì •ë³´ ëˆ„ë½ ê°ì§€',
  //   message: 'ì˜ˆì‚° ë²”ìœ„ì— ëŒ€í•œ ì •ë³´ê°€ í™•ì¸ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤',
  //   suggestedQuestion: 'ì˜ˆì‚° ë²”ìœ„ê°€ ì–´ëŠ ì •ë„ ë˜ì‹¤ê¹Œìš”?',
  //   reason: ['ê°€ê²© ë…¼ì˜ê°€ ì§„í–‰ ì¤‘ì´ë‚˜ ì˜ˆì‚° ì–¸ê¸‰ ì—†ìŒ'],
  //   expiresAt: '2025-12-30T10:15:10Z'
  // }
});

// Client â†’ Server (ì•Œë¦¼ ì‘ë‹µ)
socket.emit('hud:alert_action', {
  alertId: 'alt_001',
  action: 'ask',  // 'ask' | 'defer' | 'dismiss' | 'accept_risk'
  responseTime: 2500
});

// Server â†’ Client (ì•Œë¦¼ ì‘ë‹µ ê²°ê³¼)
socket.on('hud:alert_result', (data) => {
  // {
  //   alertId: 'alt_001',
  //   action: 'ask',
  //   result: {
  //     status: 'question_copied',
  //     question: 'ì˜ˆì‚° ë²”ìœ„ê°€ ì–´ëŠ ì •ë„ ë˜ì‹¤ê¹Œìš”?'
  //   }
  // }
});

// Server â†’ Client (Gap í•´ê²° ì•Œë¦¼)
socket.on('hud:gap_resolved', (data) => {
  // {
  //   gapId: 'gap_001',
  //   alertId: 'alt_001',
  //   category: 'budget',
  //   resolvedBy: 'user_question',
  //   resolvedAt: '2025-12-30T10:18:00Z'
  // }
});

// Server â†’ Client (ì—°ê¸° í•­ëª© ì¶”ê°€)
socket.on('hud:deferred_added', (data) => {
  // {
  //   id: 'def_001',
  //   alertId: 'alt_003',
  //   question: 'ê²°ì œ ì¡°ê±´ì€ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?',
  //   category: 'gap',
  //   currentCount: 2
  // }
});

// Client â†’ Server (íˆ¬ëª…ë„ ìƒíƒœ ë³€ê²½)
socket.emit('hud:opacity_changed', {
  sessionId: 'hud_sess_001',
  opacityState: 'inactive',  // 'active' | 'default' | 'inactive'
  timestamp: '2025-12-30T10:20:00Z'
});

// Client â†’ Server (HUD í™•ì¥/ì¶•ì†Œ)
socket.emit('hud:expanded', {
  sessionId: 'hud_sess_001',
  expanded: true,
  timestamp: '2025-12-30T10:21:00Z'
});

// Server â†’ Client (ì„¸ì…˜ í†µê³„ ì—…ë°ì´íŠ¸)
socket.on('hud:stats_updated', (data) => {
  // {
  //   sessionId: 'hud_sess_001',
  //   stats: {
  //     totalAlerts: { level1: 5, level2: 2, level3: 0 },
  //     alertsActioned: 6,
  //     gapsResolved: 2,
  //     idleRatio: 0.97
  //   }
  // }
});

// Server â†’ Client (ì„¸ì…˜ ì¢…ë£Œ)
socket.on('hud:session_ended', (data) => {
  // {
  //   sessionId: 'hud_sess_001',
  //   endedAt: '2025-12-30T11:00:05Z',
  //   endReason: 'meeting_ended',
  //   finalStats: { ... },
  //   pendingActions: [{ type: 'deferred_question', count: 2 }]
  // }
});
```

### 5.4 ì—ëŸ¬ ì²˜ë¦¬

```typescript
// Server â†’ Client
socket.on('error', (error) => {
  // {
  //   code: 'STT_FAILED',
  //   message: 'STT ì„œë¹„ìŠ¤ ì˜¤ë¥˜',
  //   retryable: true
  // }
});
```

---

## 6. ì¸ì¦ ë° ì¸ê°€

### 6.1 JWT í† í°

```typescript
// src/lib/auth.ts
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET!;
const JWT_EXPIRES_IN = '7d';

export function generateToken(userId: string) {
  return jwt.sign(
    { userId },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES_IN }
  );
}

export function verifyToken(token: string) {
  try {
    const decoded = jwt.verify(token, JWT_SECRET) as { userId: string };
    return decoded;
  } catch (error) {
    return null;
  }
}
```

### 6.2 Middleware

```typescript
// src/middleware/auth.ts
import { NextRequest, NextResponse } from 'next/server';
import { verifyToken } from '@/lib/auth';

export async function authMiddleware(req: NextRequest) {
  const token = req.headers.get('Authorization')?.replace('Bearer ', '');

  if (!token) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  const decoded = verifyToken(token);

  if (!decoded) {
    return NextResponse.json(
      { error: 'Invalid token' },
      { status: 401 }
    );
  }

  // Requestì— userId ì¶”ê°€
  req.headers.set('X-User-Id', decoded.userId);

  return NextResponse.next();
}
```

### 6.3 Rate Limiting

```typescript
// src/middleware/rateLimit.ts
import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_URL!,
  token: process.env.UPSTASH_REDIS_TOKEN!,
});

export async function rateLimit(
  userId: string,
  limit: number = 100, // ìš”ì²­ ìˆ˜
  window: number = 60   // ì´ˆ
) {
  const key = `ratelimit:${userId}`;
  const current = await redis.incr(key);

  if (current === 1) {
    await redis.expire(key, window);
  }

  if (current > limit) {
    throw new Error('Rate limit exceeded');
  }

  return {
    remaining: limit - current,
    reset: window,
  };
}
```

---

## 7. AI íŒŒì´í”„ë¼ì¸

### 7.1 STT (Deepgram)

```typescript
// src/services/stt.ts
import { createClient } from '@deepgram/sdk';

const deepgram = createClient(process.env.DEEPGRAM_API_KEY!);

export async function transcribeAudio(audioUrl: string) {
  const { result } = await deepgram.listen.prerecorded.transcribeUrl(
    { url: audioUrl },
    {
      model: 'nova-2',
      language: 'ko',
      punctuate: true,
      diarize: true, // í™”ì ë¶„ë¦¬
      utterances: true,
    }
  );

  return result.results.channels[0].alternatives[0].words.map((word) => ({
    word: word.word,
    start: word.start,
    end: word.end,
    confidence: word.confidence,
    speaker: word.speaker,
  }));
}

// ì‹¤ì‹œê°„ STT (WebSocket)
export function transcribeStream() {
  const connection = deepgram.listen.live({
    model: 'nova-2',
    language: 'ko',
    punctuate: true,
    interim_results: true,
  });

  return connection;
}
```

### 7.2 ì¸ì‚¬ì´íŠ¸ ì¶”ì¶œ (GPT-4)

```typescript
// src/services/ai/insights.ts
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

export async function extractInsights(transcript: string) {
  const completion = await openai.chat.completions.create({
    model: 'gpt-4-turbo-preview',
    messages: [
      {
        role: 'system',
        content: `ë‹¹ì‹ ì€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¯¸íŒ… ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.
ì „ì‚¬ë¡ì„ ì½ê³  ë‹¤ìŒì„ ì¶”ì¶œí•˜ì„¸ìš”:
1. ìˆ«ì/ì§€í‘œ (METRIC): êµ¬ì²´ì ì¸ ìˆ˜ì¹˜
2. ì£¼ì¥/ì‚¬ì‹¤ (CLAIM): ê²€ì¦ ê°€ëŠ¥í•œ ì§„ìˆ 
3. ìš°ë ¤ì‚¬í•­ (CONCERN): ë¦¬ìŠ¤í¬, ê±±ì •
4. ì•½ì†/ì»¤ë°‹ë¨¼íŠ¸ (COMMITMENT): ì•¡ì…˜ ì•„ì´í…œ

JSON í˜•ì‹ìœ¼ë¡œ ë°˜í™˜:
{
  "insights": [
    {
      "type": "METRIC",
      "content": "MAU 10ë§Œ",
      "source": "ë°œí™” ì›ë¬¸",
      "confidence": 0.95
    }
  ]
}`,
      },
      {
        role: 'user',
        content: transcript,
      },
    ],
    response_format: { type: 'json_object' },
    temperature: 0.3,
  });

  const result = JSON.parse(completion.choices[0].message.content!);
  return result.insights;
}
```

### 7.3 ê²°ì • 8ìš”ì†Œ ì¶”ì 

```typescript
// src/services/ai/decisions.ts
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

export async function trackDecisionElements(transcript: string) {
  const completion = await openai.chat.completions.create({
    model: 'gpt-4-turbo-preview',
    messages: [
      {
        role: 'system',
        content: `ì „ì‚¬ë¡ì—ì„œ ê²°ì • 8ìš”ì†Œë¥¼ ì¶”ì í•˜ì„¸ìš”:

1. Goal (ëª©í‘œ): ë¬´ì—‡ì„ ê²°ì •í•˜ë ¤ í•˜ëŠ”ê°€?
2. Evidence (ì¦ê±°): ê²°ì •ì„ ë’·ë°›ì¹¨í•˜ëŠ” ë°ì´í„°/ì‚¬ì‹¤
3. Assumption (ê°€ì •): ì „ì œë¡œ í•˜ëŠ” ë¯¿ìŒ
4. Risk (ë¦¬ìŠ¤í¬): ì ì¬ì  ìœ„í—˜
5. Unknown (ë¯¸ì§€): ì•„ì§ ëª¨ë¥´ëŠ” ê²ƒ
6. Decision (ê²°ì •): ë‚´ë¦° ê²°ì •
7. Action (ì•¡ì…˜): ë‹¤ìŒ ë‹¨ê³„
8. Outcome (ê²°ê³¼): ê¸°ëŒ€ ê²°ê³¼

JSON í˜•ì‹:
{
  "goal": "...",
  "evidence": [...],
  "assumptions": [...],
  "risks": [...],
  "unknowns": [...],
  "decision": "...",
  "actions": [...],
  "outcome": "...",
  "completeness": 75  // 0-100
}`,
      },
      {
        role: 'user',
        content: transcript,
      },
    ],
    response_format: { type: 'json_object' },
    temperature: 0.2,
  });

  return JSON.parse(completion.choices[0].message.content!);
}
```

### 7.4 ê°­ ê°ì§€

```typescript
// src/services/ai/gapDetection.ts
export async function detectGaps(
  decisionElements: any,
  currentTime: number // íšŒì˜ ê²½ê³¼ ì‹œê°„ (ë¶„)
) {
  const gaps = [];

  // Rule 1: 30ë¶„ ì´ìƒ ì§„í–‰ + Risk í•­ëª© ì—†ìŒ
  if (currentTime > 30 && !decisionElements.risks?.length) {
    gaps.push({
      level: 2,
      title: 'í™•ì¸ í•„ìš”',
      message: 'ë¦¬ìŠ¤í¬ ë…¼ì˜ê°€ ì•„ì§ ì—†ìŠµë‹ˆë‹¤',
      suggestedQuestion: 'ì´ ê²°ì •ì˜ ì ì¬ì  ë¦¬ìŠ¤í¬ëŠ” ë¬´ì—‡ì¸ê°€ìš”?',
    });
  }

  // Rule 2: Decision ìˆëŠ”ë° Action ì—†ìŒ
  if (decisionElements.decision && !decisionElements.actions?.length) {
    gaps.push({
      level: 2,
      title: 'í™•ì¸ í•„ìš”',
      message: 'ê²°ì •ì€ ë‚´ë ¤ì¡Œìœ¼ë‚˜ ë‹¤ìŒ ë‹¨ê³„ê°€ ëª…í™•í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤',
      suggestedQuestion: 'êµ¬ì²´ì ìœ¼ë¡œ ëˆ„ê°€ ì–¸ì œê¹Œì§€ ë¬´ì—‡ì„ í•˜ë‚˜ìš”?',
    });
  }

  // Rule 3: ê³„ì•½/ë²•ì  í‚¤ì›Œë“œ + Unknown ë§ìŒ
  const hasLegalKeywords = /ê³„ì•½|í•´ì§€|ì¡°ê±´|ë²•ì /.test(
    JSON.stringify(decisionElements)
  );
  if (hasLegalKeywords && decisionElements.unknowns?.length > 3) {
    gaps.push({
      level: 3,
      title: 'ì¹˜ëª…ì  ëˆ„ë½',
      message: 'ê³„ì•½ ê´€ë ¨ ì¤‘ìš” í•­ëª©ì´ ë…¼ì˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤',
      reason: [
        'ë²•ì  ë¶„ìŸ ê°€ëŠ¥ì„±',
        `ë¯¸í™•ì¸ í•­ëª© ${decisionElements.unknowns.length}ê°œ`,
      ],
      suggestedQuestion: 'ê³„ì•½ ì¡°ê±´ì„ ëª…í™•íˆ í•  ìˆ˜ ìˆì„ê¹Œìš”?',
    });
  }

  return gaps;
}
```

### 7.5 ì„ë² ë”© & ê²€ìƒ‰

```typescript
// src/services/ai/embeddings.ts
import OpenAI from 'openai';
import { Pinecone } from '@pinecone-database/pinecone';

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });
const pinecone = new Pinecone({ apiKey: process.env.PINECONE_API_KEY! });

const index = pinecone.index('onno-meetings');

// ì „ì‚¬ë¡ â†’ ì„ë² ë”© â†’ Pinecone ì €ì¥
export async function indexMeeting(meetingId: string, transcript: string) {
  // 1. ì „ì‚¬ë¡ì„ ì²­í¬ë¡œ ë¶„í•  (512 í† í°ì”©)
  const chunks = splitIntoChunks(transcript, 512);

  // 2. ê° ì²­í¬ë¥¼ ì„ë² ë”©
  const embeddings = await Promise.all(
    chunks.map(async (chunk, idx) => {
      const response = await openai.embeddings.create({
        model: 'text-embedding-3-small',
        input: chunk,
      });

      return {
        id: `${meetingId}_${idx}`,
        values: response.data[0].embedding,
        metadata: {
          meetingId,
          chunkIndex: idx,
          text: chunk,
        },
      };
    })
  );

  // 3. Pineconeì— ì €ì¥
  await index.upsert(embeddings);
}

// ê²€ìƒ‰ ì¿¼ë¦¬ â†’ ìœ ì‚¬ ë¬¸ì„œ ë°˜í™˜
export async function searchMeetings(query: string, topK: number = 10) {
  // 1. ì¿¼ë¦¬ ì„ë² ë”©
  const response = await openai.embeddings.create({
    model: 'text-embedding-3-small',
    input: query,
  });

  // 2. Pinecone ê²€ìƒ‰
  const results = await index.query({
    vector: response.data[0].embedding,
    topK,
    includeMetadata: true,
  });

  return results.matches.map((match) => ({
    meetingId: match.metadata?.meetingId,
    text: match.metadata?.text,
    score: match.score,
  }));
}

function splitIntoChunks(text: string, maxTokens: number) {
  // ê°„ë‹¨í•œ ì²­í¬ ë¶„í•  (ì‹¤ì œë¡œëŠ” tiktoken ì‚¬ìš© ê¶Œì¥)
  const sentences = text.split(/[.!?]\s+/);
  const chunks = [];
  let currentChunk = '';

  for (const sentence of sentences) {
    if ((currentChunk + sentence).length > maxTokens * 4) {
      chunks.push(currentChunk);
      currentChunk = sentence;
    } else {
      currentChunk += ' ' + sentence;
    }
  }

  if (currentChunk) chunks.push(currentChunk);
  return chunks;
}
```

---

## 8. ì™¸ë¶€ í†µí•©

### 8.1 Notion í†µí•©

```typescript
// src/services/integrations/notion.ts
import { Client } from '@notionhq/client';
import { prisma } from '@/lib/db';

export async function createMeetingPage(userId: string, meeting: any) {
  // 1. ì‚¬ìš©ìì˜ Notion í†µí•© ì •ë³´ ê°€ì ¸ì˜¤ê¸°
  const integration = await prisma.integration.findUnique({
    where: {
      userId_platform: {
        userId,
        platform: 'NOTION',
      },
    },
  });

  if (!integration || !integration.credentials) {
    throw new Error('Notion not connected');
  }

  // 2. Notion Client ì´ˆê¸°í™”
  const notion = new Client({
    auth: decrypt(integration.credentials),
  });

  const databaseId = integration.metadata?.databaseId;

  // 3. í˜ì´ì§€ ìƒì„±
  const page = await notion.pages.create({
    parent: { database_id: databaseId },
    properties: {
      Title: {
        title: [
          {
            text: {
              content: `${meeting.company} ${meeting.title}`,
            },
          },
        ],
      },
      Date: {
        date: {
          start: meeting.startTime.toISOString(),
        },
      },
      Company: {
        select: {
          name: meeting.company,
        },
      },
    },
    children: [
      // ê²°ì • ì‚¬í•­
      {
        object: 'block',
        type: 'heading_2',
        heading_2: {
          rich_text: [{ text: { content: 'âœ… ê²°ì • ì‚¬í•­' } }],
        },
      },
      ...meeting.decisions.map((decision: any) => ({
        object: 'block',
        type: 'bulleted_list_item',
        bulleted_list_item: {
          rich_text: [{ text: { content: decision.decision } }],
        },
      })),

      // ì•¡ì…˜ ì•„ì´í…œ
      {
        object: 'block',
        type: 'heading_2',
        heading_2: {
          rich_text: [{ text: { content: 'ğŸ“‹ ì•¡ì…˜ ì•„ì´í…œ' } }],
        },
      },
      ...meeting.actions.map((action: any) => ({
        object: 'block',
        type: 'to_do',
        to_do: {
          rich_text: [
            {
              text: {
                content: `${action.title} (${action.assignee}, ${action.dueDate})`,
              },
            },
          ],
          checked: false,
        },
      })),

      // ì¸ì‚¬ì´íŠ¸
      {
        object: 'block',
        type: 'heading_2',
        heading_2: {
          rich_text: [{ text: { content: 'ğŸ’¡ ì£¼ìš” ì¸ì‚¬ì´íŠ¸' } }],
        },
      },
      ...meeting.insights.map((insight: any) => ({
        object: 'block',
        type: 'bulleted_list_item',
        bulleted_list_item: {
          rich_text: [{ text: { content: insight.content } }],
        },
      })),
    ],
  });

  return {
    pageId: page.id,
    url: page.url,
  };
}

function decrypt(encrypted: string) {
  // ì•”í˜¸í™”ëœ í† í° ë³µí˜¸í™” (crypto ì‚¬ìš©)
  // êµ¬í˜„ ìƒëµ
  return encrypted;
}
```

### 8.2 Salesforce í†µí•©

```typescript
// src/services/integrations/salesforce.ts
import jsforce from 'jsforce';

export async function updateDeal(userId: string, meeting: any) {
  const integration = await prisma.integration.findUnique({
    where: {
      userId_platform: { userId, platform: 'SALESFORCE' },
    },
  });

  if (!integration) {
    throw new Error('Salesforce not connected');
  }

  const conn = new jsforce.Connection({
    instanceUrl: integration.metadata?.instanceUrl,
    accessToken: decrypt(integration.credentials!),
  });

  // Opportunity ì—…ë°ì´íŠ¸
  const result = await conn.sobject('Opportunity').update({
    Id: meeting.metadata?.salesforceOpportunityId,
    StageName: 'Due Diligence', // DD ì§„í–‰ ì¤‘
    NextStep: meeting.actions[0]?.title || '',
    Description: meeting.decisions[0]?.decision || '',
  });

  return result;
}
```

### 8.3 Slack í†µí•©

```typescript
// src/services/integrations/slack.ts
import { WebClient } from '@slack/web-api';

export async function postToSlack(userId: string, meeting: any) {
  const integration = await prisma.integration.findUnique({
    where: {
      userId_platform: { userId, platform: 'SLACK' },
    },
  });

  if (!integration) return;

  const slack = new WebClient(decrypt(integration.credentials!));
  const channelId = integration.metadata?.channelId || '#sales';

  const message = await slack.chat.postMessage({
    channel: channelId,
    text: `${meeting.company} ë¯¸íŒ… ì™„ë£Œ`,
    blocks: [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `${meeting.company} ${meeting.title}`,
        },
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*ê²°ì •:*\n${meeting.decisions[0]?.decision || '-'}`,
          },
          {
            type: 'mrkdwn',
            text: `*ë‹¤ìŒ ë‹¨ê³„:*\n${meeting.actions[0]?.title || '-'}`,
          },
        ],
      },
      {
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `ë‹´ë‹¹: ${meeting.actions[0]?.assignee || '-'} | ê¸°í•œ: ${meeting.actions[0]?.dueDate || '-'}`,
          },
        ],
      },
    ],
  });

  return {
    messageTs: message.ts,
    permalink: await slack.chat.getPermalink({
      channel: channelId,
      message_ts: message.ts!,
    }),
  };
}
```

---

## 9. ì—ëŸ¬ ì²˜ë¦¬

### 9.1 ì—ëŸ¬ ì½”ë“œ ì •ì˜

```typescript
// src/lib/errors.ts
export enum ErrorCode {
  // Auth
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  INVALID_TOKEN = 'INVALID_TOKEN',

  // Validation
  INVALID_INPUT = 'INVALID_INPUT',
  MISSING_FIELD = 'MISSING_FIELD',

  // Resource
  NOT_FOUND = 'NOT_FOUND',
  ALREADY_EXISTS = 'ALREADY_EXISTS',

  // External
  STT_FAILED = 'STT_FAILED',
  AI_FAILED = 'AI_FAILED',
  INTEGRATION_FAILED = 'INTEGRATION_FAILED',

  // System
  INTERNAL_ERROR = 'INTERNAL_ERROR',
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',
}

export class AppError extends Error {
  constructor(
    public code: ErrorCode,
    public message: string,
    public statusCode: number = 500,
    public details?: any
  ) {
    super(message);
    this.name = 'AppError';
  }
}
```

### 9.2 ì—ëŸ¬ í•¸ë“¤ëŸ¬

```typescript
// src/app/api/middleware/errorHandler.ts
import { NextRequest, NextResponse } from 'next/server';
import { AppError, ErrorCode } from '@/lib/errors';

export function errorHandler(error: unknown) {
  if (error instanceof AppError) {
    return NextResponse.json(
      {
        error: {
          code: error.code,
          message: error.message,
          details: error.details,
        },
      },
      { status: error.statusCode }
    );
  }

  // Prisma ì—ëŸ¬
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    if (error.code === 'P2002') {
      return NextResponse.json(
        {
          error: {
            code: ErrorCode.ALREADY_EXISTS,
            message: 'Resource already exists',
          },
        },
        { status: 409 }
      );
    }
  }

  // ê¸°íƒ€ ì—ëŸ¬
  console.error('Unhandled error:', error);
  return NextResponse.json(
    {
      error: {
        code: ErrorCode.INTERNAL_ERROR,
        message: 'Internal server error',
      },
    },
    { status: 500 }
  );
}
```

### 9.3 Part 6.1: ì—ëŸ¬ ì²˜ë¦¬ - 5-Layer Framework

> **Cross-Cutting Concern**: ì—ëŸ¬ ì²˜ë¦¬ëŠ” ëª¨ë“  Partì— ê±¸ì³ ì¼ê´€ë˜ê²Œ ì ìš©ë˜ëŠ” ì‹œìŠ¤í…œ ì „ë°˜ì˜ ê´€ì‹¬ì‚¬ì…ë‹ˆë‹¤.
> "ì—ëŸ¬ëŠ” ë§‰ë‹¤ë¥¸ ê¸¸ì´ ì•„ë‹ˆë¼ ìš°íšŒë¡œ" - ì‚¬ìš©ìê°€ ì¤‘ë‹¨ ì—†ì´ ëª©í‘œë¥¼ ë‹¬ì„±í•  ìˆ˜ ìˆë„ë¡ ì§€ì›í•©ë‹ˆë‹¤.

#### 9.3.1 í™•ì¥ëœ ì—ëŸ¬ ë¶„ë¥˜ ì‹œìŠ¤í…œ

```typescript
// src/lib/errors/types.ts - Part 6.1

/**
 * ì—ëŸ¬ ì‹¬ê°ë„ ì •ì˜
 */
export type ErrorSeverity = 'critical' | 'major' | 'minor' | 'info';

/**
 * ì—ëŸ¬ ë„ë©”ì¸ ì •ì˜
 */
export type ErrorDomain =
  | 'network'      // ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë¬¸ì œ
  | 'auth'         // ì¸ì¦/ê¶Œí•œ ë¬¸ì œ
  | 'integration'  // ì™¸ë¶€ ì„œë¹„ìŠ¤ í†µí•© ë¬¸ì œ
  | 'ai'           // AI ì„œë¹„ìŠ¤ ë¬¸ì œ
  | 'media'        // ë¯¸ë””ì–´ ì²˜ë¦¬ ë¬¸ì œ
  | 'storage'      // ì €ì¥ì†Œ ë¬¸ì œ
  | 'validation';  // ì…ë ¥ ê²€ì¦ ë¬¸ì œ

/**
 * ì—ëŸ¬ íƒ€ì… ì •ì˜
 */
export type ErrorType =
  // Network errors
  | 'NETWORK_OFFLINE'
  | 'NETWORK_TIMEOUT'
  | 'NETWORK_SERVER_ERROR'
  // Auth errors
  | 'AUTH_SESSION_EXPIRED'
  | 'AUTH_TOKEN_INVALID'
  | 'AUTH_PERMISSION_DENIED'
  | 'AUTH_GOOGLE_OAUTH_FAILED'
  // Integration errors
  | 'INTEGRATION_CALENDAR_SYNC_FAILED'
  | 'INTEGRATION_NOTION_AUTH_EXPIRED'
  | 'INTEGRATION_NOTION_SAVE_FAILED'
  | 'INTEGRATION_HUBSPOT_AUTH_EXPIRED'
  | 'INTEGRATION_HUBSPOT_SYNC_FAILED'
  | 'INTEGRATION_SLACK_DISCONNECTED'
  // AI errors
  | 'AI_STT_FAILED'
  | 'AI_ANALYSIS_FAILED'
  | 'AI_RATE_LIMITED'
  | 'AI_QUOTA_EXCEEDED'
  // Media errors
  | 'MEDIA_MICROPHONE_PERMISSION_DENIED'
  | 'MEDIA_MICROPHONE_NOT_FOUND'
  | 'MEDIA_RECORDING_FAILED'
  | 'MEDIA_AUDIO_QUALITY_LOW'
  // Storage errors
  | 'STORAGE_QUOTA_EXCEEDED'
  | 'STORAGE_UPLOAD_FAILED'
  | 'STORAGE_READ_FAILED'
  // Validation errors
  | 'VALIDATION_INVALID_INPUT'
  | 'VALIDATION_MISSING_FIELD';

/**
 * í™•ì¥ëœ ì—ëŸ¬ ì¸í„°í˜ì´ìŠ¤
 */
export interface EnhancedError {
  id: string;              // UUID for tracking
  type: ErrorType;
  domain: ErrorDomain;
  severity: ErrorSeverity;
  code: string;            // e.g., 'ERR_NETWORK_001'
  message: string;         // User-friendly message (i18n key)
  technicalMessage: string; // Developer-friendly message
  timestamp: Date;
  recoverable: boolean;
  recoveryStrategy?: RecoveryStrategy;
  metadata?: Record<string, any>;
  context?: {
    userId?: string;
    sessionId?: string;
    meetingId?: string;
    part?: string;         // Which Part this error occurred in
    component?: string;
    action?: string;
  };
}

/**
 * ë³µêµ¬ ì „ëµ ì •ì˜
 */
export type RecoveryStrategy =
  | 'retry_with_backoff'   // ì§€ìˆ˜ ë°±ì˜¤í”„ë¡œ ì¬ì‹œë„
  | 'refresh_token'        // í† í° ê°±ì‹  í›„ ì¬ì‹œë„
  | 'reconnect'            // ì¬ì—°ê²° ì‹œë„
  | 'fallback'             // ëŒ€ì²´ ê¸°ëŠ¥ í™œì„±í™”
  | 'manual';              // ì‚¬ìš©ì ìˆ˜ë™ ê°œì… í•„ìš”
```

#### 9.3.2 ì—ëŸ¬ ì‘ë‹µ í‘œì¤€í™”

```typescript
// src/lib/errors/response.ts - Part 6.1

import { EnhancedError, ErrorSeverity, ErrorDomain, RecoveryStrategy } from './types';

/**
 * í‘œì¤€ ì—ëŸ¬ ì‘ë‹µ ì¸í„°í˜ì´ìŠ¤
 */
export interface ErrorResponse {
  error: {
    id: string;
    type: string;
    code: string;
    message: string;
    severity: ErrorSeverity;
    domain: ErrorDomain;
    recoverable: boolean;
    recovery?: {
      strategy: RecoveryStrategy;
      retryAfter?: number;    // seconds
      retryCount?: number;
      maxRetries?: number;
      fallbackAvailable?: boolean;
      ctaLabel?: string;      // i18n key
      ctaAction?: string;     // action identifier
    };
    details?: Record<string, any>;
    helpUrl?: string;
    timestamp: string;
  };
}

/**
 * ì—ëŸ¬ ì‘ë‹µ ìƒì„± í•¨ìˆ˜
 */
export function createErrorResponse(
  error: EnhancedError,
  includeDetails: boolean = false
): ErrorResponse {
  return {
    error: {
      id: error.id,
      type: error.type,
      code: error.code,
      message: error.message,
      severity: error.severity,
      domain: error.domain,
      recoverable: error.recoverable,
      recovery: error.recoveryStrategy ? {
        strategy: error.recoveryStrategy,
        retryAfter: getRetryAfterSeconds(error),
        maxRetries: getMaxRetries(error),
        fallbackAvailable: hasFallback(error),
        ctaLabel: getCtaLabel(error),
        ctaAction: getCtaAction(error),
      } : undefined,
      details: includeDetails ? error.metadata : undefined,
      helpUrl: getHelpUrl(error),
      timestamp: error.timestamp.toISOString(),
    },
  };
}

/**
 * HTTP ìƒíƒœ ì½”ë“œ ë§¤í•‘
 */
export function getHttpStatusCode(error: EnhancedError): number {
  const statusMap: Record<string, number> = {
    // Network
    NETWORK_OFFLINE: 503,
    NETWORK_TIMEOUT: 504,
    NETWORK_SERVER_ERROR: 500,
    // Auth
    AUTH_SESSION_EXPIRED: 401,
    AUTH_TOKEN_INVALID: 401,
    AUTH_PERMISSION_DENIED: 403,
    AUTH_GOOGLE_OAUTH_FAILED: 401,
    // Integration
    INTEGRATION_CALENDAR_SYNC_FAILED: 502,
    INTEGRATION_NOTION_AUTH_EXPIRED: 401,
    INTEGRATION_NOTION_SAVE_FAILED: 502,
    INTEGRATION_HUBSPOT_AUTH_EXPIRED: 401,
    INTEGRATION_HUBSPOT_SYNC_FAILED: 502,
    INTEGRATION_SLACK_DISCONNECTED: 502,
    // AI
    AI_STT_FAILED: 502,
    AI_ANALYSIS_FAILED: 502,
    AI_RATE_LIMITED: 429,
    AI_QUOTA_EXCEEDED: 429,
    // Media
    MEDIA_MICROPHONE_PERMISSION_DENIED: 403,
    MEDIA_MICROPHONE_NOT_FOUND: 404,
    MEDIA_RECORDING_FAILED: 500,
    MEDIA_AUDIO_QUALITY_LOW: 422,
    // Storage
    STORAGE_QUOTA_EXCEEDED: 507,
    STORAGE_UPLOAD_FAILED: 500,
    STORAGE_READ_FAILED: 500,
    // Validation
    VALIDATION_INVALID_INPUT: 400,
    VALIDATION_MISSING_FIELD: 400,
  };

  return statusMap[error.type] || 500;
}
```

#### 9.3.3 ì—ëŸ¬ íŒ©í† ë¦¬

```typescript
// src/lib/errors/factory.ts - Part 6.1

import { v4 as uuidv4 } from 'uuid';
import {
  EnhancedError,
  ErrorType,
  ErrorDomain,
  ErrorSeverity,
  RecoveryStrategy
} from './types';

/**
 * ì—ëŸ¬ êµ¬ì„± ì •ì˜
 */
interface ErrorConfig {
  domain: ErrorDomain;
  severity: ErrorSeverity;
  recoverable: boolean;
  recoveryStrategy?: RecoveryStrategy;
  defaultMessage: string;
  code: string;
}

/**
 * ì—ëŸ¬ íƒ€ì…ë³„ êµ¬ì„±
 */
const ERROR_CONFIGS: Record<ErrorType, ErrorConfig> = {
  // Network errors
  NETWORK_OFFLINE: {
    domain: 'network',
    severity: 'major',
    recoverable: true,
    recoveryStrategy: 'reconnect',
    defaultMessage: 'error.network.offline',
    code: 'ERR_NET_001',
  },
  NETWORK_TIMEOUT: {
    domain: 'network',
    severity: 'minor',
    recoverable: true,
    recoveryStrategy: 'retry_with_backoff',
    defaultMessage: 'error.network.timeout',
    code: 'ERR_NET_002',
  },
  NETWORK_SERVER_ERROR: {
    domain: 'network',
    severity: 'major',
    recoverable: true,
    recoveryStrategy: 'retry_with_backoff',
    defaultMessage: 'error.network.server',
    code: 'ERR_NET_003',
  },
  // Auth errors
  AUTH_SESSION_EXPIRED: {
    domain: 'auth',
    severity: 'major',
    recoverable: true,
    recoveryStrategy: 'refresh_token',
    defaultMessage: 'error.auth.session_expired',
    code: 'ERR_AUTH_001',
  },
  AUTH_TOKEN_INVALID: {
    domain: 'auth',
    severity: 'critical',
    recoverable: true,
    recoveryStrategy: 'manual',
    defaultMessage: 'error.auth.token_invalid',
    code: 'ERR_AUTH_002',
  },
  AUTH_PERMISSION_DENIED: {
    domain: 'auth',
    severity: 'major',
    recoverable: false,
    defaultMessage: 'error.auth.permission_denied',
    code: 'ERR_AUTH_003',
  },
  AUTH_GOOGLE_OAUTH_FAILED: {
    domain: 'auth',
    severity: 'critical',
    recoverable: true,
    recoveryStrategy: 'manual',
    defaultMessage: 'error.auth.google_oauth_failed',
    code: 'ERR_AUTH_004',
  },
  // Integration errors
  INTEGRATION_CALENDAR_SYNC_FAILED: {
    domain: 'integration',
    severity: 'minor',
    recoverable: true,
    recoveryStrategy: 'retry_with_backoff',
    defaultMessage: 'error.integration.calendar_sync',
    code: 'ERR_INT_001',
  },
  INTEGRATION_NOTION_AUTH_EXPIRED: {
    domain: 'integration',
    severity: 'major',
    recoverable: true,
    recoveryStrategy: 'manual',
    defaultMessage: 'error.integration.notion_auth',
    code: 'ERR_INT_002',
  },
  INTEGRATION_NOTION_SAVE_FAILED: {
    domain: 'integration',
    severity: 'minor',
    recoverable: true,
    recoveryStrategy: 'retry_with_backoff',
    defaultMessage: 'error.integration.notion_save',
    code: 'ERR_INT_003',
  },
  INTEGRATION_HUBSPOT_AUTH_EXPIRED: {
    domain: 'integration',
    severity: 'major',
    recoverable: true,
    recoveryStrategy: 'manual',
    defaultMessage: 'error.integration.hubspot_auth',
    code: 'ERR_INT_004',
  },
  INTEGRATION_HUBSPOT_SYNC_FAILED: {
    domain: 'integration',
    severity: 'minor',
    recoverable: true,
    recoveryStrategy: 'retry_with_backoff',
    defaultMessage: 'error.integration.hubspot_sync',
    code: 'ERR_INT_005',
  },
  INTEGRATION_SLACK_DISCONNECTED: {
    domain: 'integration',
    severity: 'minor',
    recoverable: true,
    recoveryStrategy: 'manual',
    defaultMessage: 'error.integration.slack_disconnected',
    code: 'ERR_INT_006',
  },
  // AI errors
  AI_STT_FAILED: {
    domain: 'ai',
    severity: 'major',
    recoverable: true,
    recoveryStrategy: 'retry_with_backoff',
    defaultMessage: 'error.ai.stt_failed',
    code: 'ERR_AI_001',
  },
  AI_ANALYSIS_FAILED: {
    domain: 'ai',
    severity: 'minor',
    recoverable: true,
    recoveryStrategy: 'retry_with_backoff',
    defaultMessage: 'error.ai.analysis_failed',
    code: 'ERR_AI_002',
  },
  AI_RATE_LIMITED: {
    domain: 'ai',
    severity: 'minor',
    recoverable: true,
    recoveryStrategy: 'retry_with_backoff',
    defaultMessage: 'error.ai.rate_limited',
    code: 'ERR_AI_003',
  },
  AI_QUOTA_EXCEEDED: {
    domain: 'ai',
    severity: 'major',
    recoverable: false,
    defaultMessage: 'error.ai.quota_exceeded',
    code: 'ERR_AI_004',
  },
  // Media errors
  MEDIA_MICROPHONE_PERMISSION_DENIED: {
    domain: 'media',
    severity: 'critical',
    recoverable: true,
    recoveryStrategy: 'manual',
    defaultMessage: 'error.media.mic_permission',
    code: 'ERR_MED_001',
  },
  MEDIA_MICROPHONE_NOT_FOUND: {
    domain: 'media',
    severity: 'critical',
    recoverable: false,
    defaultMessage: 'error.media.mic_not_found',
    code: 'ERR_MED_002',
  },
  MEDIA_RECORDING_FAILED: {
    domain: 'media',
    severity: 'major',
    recoverable: true,
    recoveryStrategy: 'retry_with_backoff',
    defaultMessage: 'error.media.recording_failed',
    code: 'ERR_MED_003',
  },
  MEDIA_AUDIO_QUALITY_LOW: {
    domain: 'media',
    severity: 'info',
    recoverable: true,
    recoveryStrategy: 'fallback',
    defaultMessage: 'error.media.audio_quality',
    code: 'ERR_MED_004',
  },
  // Storage errors
  STORAGE_QUOTA_EXCEEDED: {
    domain: 'storage',
    severity: 'major',
    recoverable: false,
    defaultMessage: 'error.storage.quota_exceeded',
    code: 'ERR_STR_001',
  },
  STORAGE_UPLOAD_FAILED: {
    domain: 'storage',
    severity: 'minor',
    recoverable: true,
    recoveryStrategy: 'retry_with_backoff',
    defaultMessage: 'error.storage.upload_failed',
    code: 'ERR_STR_002',
  },
  STORAGE_READ_FAILED: {
    domain: 'storage',
    severity: 'minor',
    recoverable: true,
    recoveryStrategy: 'retry_with_backoff',
    defaultMessage: 'error.storage.read_failed',
    code: 'ERR_STR_003',
  },
  // Validation errors
  VALIDATION_INVALID_INPUT: {
    domain: 'validation',
    severity: 'info',
    recoverable: true,
    recoveryStrategy: 'manual',
    defaultMessage: 'error.validation.invalid_input',
    code: 'ERR_VAL_001',
  },
  VALIDATION_MISSING_FIELD: {
    domain: 'validation',
    severity: 'info',
    recoverable: true,
    recoveryStrategy: 'manual',
    defaultMessage: 'error.validation.missing_field',
    code: 'ERR_VAL_002',
  },
};

/**
 * ì—ëŸ¬ ìƒì„± í•¨ìˆ˜
 */
export function createError(
  type: ErrorType,
  technicalMessage: string,
  context?: EnhancedError['context'],
  metadata?: Record<string, any>
): EnhancedError {
  const config = ERROR_CONFIGS[type];

  return {
    id: uuidv4(),
    type,
    domain: config.domain,
    severity: config.severity,
    code: config.code,
    message: config.defaultMessage,
    technicalMessage,
    timestamp: new Date(),
    recoverable: config.recoverable,
    recoveryStrategy: config.recoveryStrategy,
    context,
    metadata,
  };
}
```

#### 9.3.4 ë³µêµ¬ ì„œë¹„ìŠ¤

```typescript
// src/lib/errors/recovery.ts - Part 6.1

import { EnhancedError, RecoveryStrategy } from './types';
import { prisma } from '@/lib/prisma';

/**
 * ë³µêµ¬ ê²°ê³¼ ì¸í„°í˜ì´ìŠ¤
 */
export interface RecoveryResult {
  success: boolean;
  error?: EnhancedError;
  retryCount?: number;
  fallbackActivated?: boolean;
}

/**
 * ì§€ìˆ˜ ë°±ì˜¤í”„ ì„¤ì •
 */
interface BackoffConfig {
  initialDelayMs: number;
  maxDelayMs: number;
  maxRetries: number;
  multiplier: number;
}

const DEFAULT_BACKOFF: BackoffConfig = {
  initialDelayMs: 1000,
  maxDelayMs: 30000,
  maxRetries: 3,
  multiplier: 2,
};

/**
 * ì§€ìˆ˜ ë°±ì˜¤í”„ë¡œ ì¬ì‹œë„
 */
export async function retryWithBackoff<T>(
  operation: () => Promise<T>,
  errorType: string,
  config: BackoffConfig = DEFAULT_BACKOFF
): Promise<{ data?: T; error?: EnhancedError; retryCount: number }> {
  let lastError: any;
  let delay = config.initialDelayMs;

  for (let attempt = 1; attempt <= config.maxRetries; attempt++) {
    try {
      const data = await operation();
      return { data, retryCount: attempt };
    } catch (error) {
      lastError = error;

      // ë§ˆì§€ë§‰ ì‹œë„ê°€ ì•„ë‹ˆë©´ ëŒ€ê¸°
      if (attempt < config.maxRetries) {
        await sleep(delay);
        delay = Math.min(delay * config.multiplier, config.maxDelayMs);
      }
    }
  }

  return {
    error: createError(
      errorType as any,
      `Failed after ${config.maxRetries} retries: ${lastError.message}`,
      undefined,
      { lastError: lastError.message, retries: config.maxRetries }
    ),
    retryCount: config.maxRetries,
  };
}

/**
 * í† í° ê°±ì‹  ì„œë¹„ìŠ¤
 */
export async function refreshAuthToken(
  userId: string,
  provider: 'google' | 'notion' | 'hubspot' | 'slack'
): Promise<RecoveryResult> {
  try {
    const token = await prisma.oAuthToken.findUnique({
      where: {
        userId_provider: { userId, provider },
      },
    });

    if (!token?.refreshToken) {
      return {
        success: false,
        error: createError(
          'AUTH_TOKEN_INVALID',
          `No refresh token available for ${provider}`
        ),
      };
    }

    // Providerë³„ í† í° ê°±ì‹ 
    const newTokens = await refreshProviderToken(provider, token.refreshToken);

    await prisma.oAuthToken.update({
      where: { id: token.id },
      data: {
        accessToken: newTokens.accessToken,
        refreshToken: newTokens.refreshToken || token.refreshToken,
        expiresAt: newTokens.expiresAt,
      },
    });

    return { success: true };
  } catch (error: any) {
    return {
      success: false,
      error: createError(
        'AUTH_TOKEN_INVALID',
        `Token refresh failed: ${error.message}`
      ),
    };
  }
}

/**
 * Providerë³„ í† í° ê°±ì‹ 
 */
async function refreshProviderToken(
  provider: string,
  refreshToken: string
): Promise<{
  accessToken: string;
  refreshToken?: string;
  expiresAt: Date;
}> {
  const endpoints: Record<string, string> = {
    google: 'https://oauth2.googleapis.com/token',
    notion: 'https://api.notion.com/v1/oauth/token',
    hubspot: 'https://api.hubapi.com/oauth/v1/token',
    slack: 'https://slack.com/api/oauth.v2.access',
  };

  const clientIds: Record<string, string> = {
    google: process.env.GOOGLE_CLIENT_ID!,
    notion: process.env.NOTION_CLIENT_ID!,
    hubspot: process.env.HUBSPOT_CLIENT_ID!,
    slack: process.env.SLACK_CLIENT_ID!,
  };

  const clientSecrets: Record<string, string> = {
    google: process.env.GOOGLE_CLIENT_SECRET!,
    notion: process.env.NOTION_CLIENT_SECRET!,
    hubspot: process.env.HUBSPOT_CLIENT_SECRET!,
    slack: process.env.SLACK_CLIENT_SECRET!,
  };

  const response = await fetch(endpoints[provider], {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: new URLSearchParams({
      grant_type: 'refresh_token',
      refresh_token: refreshToken,
      client_id: clientIds[provider],
      client_secret: clientSecrets[provider],
    }),
  });

  if (!response.ok) {
    throw new Error(`Token refresh failed: ${response.status}`);
  }

  const data = await response.json();

  return {
    accessToken: data.access_token,
    refreshToken: data.refresh_token,
    expiresAt: new Date(Date.now() + data.expires_in * 1000),
  };
}

/**
 * ì¬ì—°ê²° ì„œë¹„ìŠ¤
 */
export async function reconnect(
  userId: string,
  sessionId: string
): Promise<RecoveryResult> {
  try {
    // WebSocket ì¬ì—°ê²° ë¡œì§
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” Redis pub/subì„ í†µí•´ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì¬ì—°ê²° ìš”ì²­

    await prisma.hudSession.update({
      where: { id: sessionId },
      data: {
        status: 'RECONNECTING',
        lastReconnectAttempt: new Date(),
      },
    });

    return { success: true };
  } catch (error: any) {
    return {
      success: false,
      error: createError(
        'NETWORK_OFFLINE',
        `Reconnection failed: ${error.message}`
      ),
    };
  }
}

/**
 * í´ë°± í™œì„±í™”
 */
export async function activateFallback(
  errorType: string,
  userId: string,
  sessionId?: string
): Promise<RecoveryResult> {
  const fallbackMap: Record<string, () => Promise<void>> = {
    AI_STT_FAILED: async () => {
      // STT ì‹¤íŒ¨ ì‹œ ë¡œì»¬ ë²„í¼ë§ ëª¨ë“œ í™œì„±í™”
      if (sessionId) {
        await prisma.hudSession.update({
          where: { id: sessionId },
          data: {
            fallbackMode: 'LOCAL_BUFFER',
            fallbackActivatedAt: new Date(),
          },
        });
      }
    },
    AI_ANALYSIS_FAILED: async () => {
      // ë¶„ì„ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ìš”ì•½ë§Œ ì œê³µ
      if (sessionId) {
        await prisma.hudSession.update({
          where: { id: sessionId },
          data: {
            fallbackMode: 'BASIC_SUMMARY',
            fallbackActivatedAt: new Date(),
          },
        });
      }
    },
    NETWORK_OFFLINE: async () => {
      // ì˜¤í”„ë¼ì¸ ëª¨ë“œ í™œì„±í™”
      // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì²˜ë¦¬ (ì„œë²„ì—ì„œëŠ” ìƒíƒœë§Œ ê¸°ë¡)
    },
    MEDIA_AUDIO_QUALITY_LOW: async () => {
      // ì €í’ˆì§ˆ ì˜¤ë””ì˜¤ ëª¨ë“œ í™œì„±í™”
      if (sessionId) {
        await prisma.hudSession.update({
          where: { id: sessionId },
          data: {
            audioQualityMode: 'LOW',
            fallbackActivatedAt: new Date(),
          },
        });
      }
    },
  };

  const fallbackFn = fallbackMap[errorType];

  if (!fallbackFn) {
    return {
      success: false,
      error: createError(
        errorType as any,
        `No fallback available for ${errorType}`
      ),
      fallbackActivated: false,
    };
  }

  try {
    await fallbackFn();
    return { success: true, fallbackActivated: true };
  } catch (error: any) {
    return {
      success: false,
      error: createError(
        errorType as any,
        `Fallback activation failed: ${error.message}`
      ),
      fallbackActivated: false,
    };
  }
}

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

#### 9.3.5 ì—ëŸ¬ ë¡œê¹… ì„œë¹„ìŠ¤

```typescript
// src/lib/errors/logging.ts - Part 6.1

import { EnhancedError } from './types';
import { prisma } from '@/lib/prisma';

/**
 * ì—ëŸ¬ ë¡œê·¸ ì¸í„°í˜ì´ìŠ¤
 */
export interface ErrorLog {
  id: string;
  errorId: string;
  type: string;
  domain: string;
  severity: string;
  code: string;
  message: string;
  technicalMessage: string;
  userId?: string;
  sessionId?: string;
  meetingId?: string;
  part?: string;
  component?: string;
  action?: string;
  metadata?: Record<string, any>;
  stackTrace?: string;
  recoveryAttempted: boolean;
  recoveryStrategy?: string;
  recoveryResult?: string;
  userAgent?: string;
  ipAddress?: string;
  createdAt: Date;
}

/**
 * ì—ëŸ¬ ë¡œê¹… í•¨ìˆ˜
 */
export async function logError(
  error: EnhancedError,
  additionalContext?: {
    stackTrace?: string;
    userAgent?: string;
    ipAddress?: string;
  }
): Promise<void> {
  try {
    await prisma.errorLog.create({
      data: {
        errorId: error.id,
        type: error.type,
        domain: error.domain,
        severity: error.severity,
        code: error.code,
        message: error.message,
        technicalMessage: error.technicalMessage,
        userId: error.context?.userId,
        sessionId: error.context?.sessionId,
        meetingId: error.context?.meetingId,
        part: error.context?.part,
        component: error.context?.component,
        action: error.context?.action,
        metadata: error.metadata,
        stackTrace: additionalContext?.stackTrace,
        recoveryAttempted: false,
        recoveryStrategy: error.recoveryStrategy,
        userAgent: additionalContext?.userAgent,
        ipAddress: additionalContext?.ipAddress,
      },
    });
  } catch (logError) {
    // ë¡œê¹… ì‹¤íŒ¨ ì‹œ ì½˜ì†”ì— ê¸°ë¡ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
    console.error('Failed to log error:', logError);
    console.error('Original error:', error);
  }
}

/**
 * ë³µêµ¬ ê²°ê³¼ ë¡œê¹…
 */
export async function logRecoveryResult(
  errorId: string,
  success: boolean,
  details?: string
): Promise<void> {
  try {
    await prisma.errorLog.update({
      where: { errorId },
      data: {
        recoveryAttempted: true,
        recoveryResult: success ? 'SUCCESS' : 'FAILED',
        recoveryDetails: details,
        recoveryAttemptedAt: new Date(),
      },
    });
  } catch (error) {
    console.error('Failed to log recovery result:', error);
  }
}

/**
 * ì—ëŸ¬ í†µê³„ ì§‘ê³„
 */
export async function getErrorStats(
  userId: string,
  timeRange: { start: Date; end: Date }
): Promise<{
  totalErrors: number;
  byDomain: Record<string, number>;
  bySeverity: Record<string, number>;
  recoveryRate: number;
  topErrors: Array<{ type: string; count: number }>;
}> {
  const [total, byDomain, bySeverity, recovered, topErrors] = await Promise.all([
    // ì´ ì—ëŸ¬ ìˆ˜
    prisma.errorLog.count({
      where: {
        userId,
        createdAt: { gte: timeRange.start, lte: timeRange.end },
      },
    }),
    // ë„ë©”ì¸ë³„ ì§‘ê³„
    prisma.errorLog.groupBy({
      by: ['domain'],
      where: {
        userId,
        createdAt: { gte: timeRange.start, lte: timeRange.end },
      },
      _count: true,
    }),
    // ì‹¬ê°ë„ë³„ ì§‘ê³„
    prisma.errorLog.groupBy({
      by: ['severity'],
      where: {
        userId,
        createdAt: { gte: timeRange.start, lte: timeRange.end },
      },
      _count: true,
    }),
    // ë³µêµ¬ ì„±ê³µ ìˆ˜
    prisma.errorLog.count({
      where: {
        userId,
        createdAt: { gte: timeRange.start, lte: timeRange.end },
        recoveryResult: 'SUCCESS',
      },
    }),
    // ìƒìœ„ ì—ëŸ¬ íƒ€ì…
    prisma.errorLog.groupBy({
      by: ['type'],
      where: {
        userId,
        createdAt: { gte: timeRange.start, lte: timeRange.end },
      },
      _count: true,
      orderBy: { _count: { type: 'desc' } },
      take: 5,
    }),
  ]);

  return {
    totalErrors: total,
    byDomain: Object.fromEntries(
      byDomain.map(d => [d.domain, d._count])
    ),
    bySeverity: Object.fromEntries(
      bySeverity.map(s => [s.severity, s._count])
    ),
    recoveryRate: total > 0 ? recovered / total : 0,
    topErrors: topErrors.map(e => ({ type: e.type, count: e._count })),
  };
}
```

#### 9.3.6 ì—ëŸ¬ API ì—”ë“œí¬ì¸íŠ¸

```typescript
// src/app/api/v1/errors/route.ts - Part 6.1

import { NextRequest, NextResponse } from 'next/server';
import { getAuthUser } from '@/lib/auth';
import { logError, getErrorStats } from '@/lib/errors/logging';
import { createError } from '@/lib/errors/factory';
import { z } from 'zod';

/**
 * POST /api/v1/errors - í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬ ë¡œê¹…
 */
export async function POST(req: NextRequest) {
  try {
    const user = await getAuthUser(req);
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();

    const schema = z.object({
      type: z.string(),
      message: z.string(),
      technicalMessage: z.string().optional(),
      context: z.object({
        sessionId: z.string().optional(),
        meetingId: z.string().optional(),
        part: z.string().optional(),
        component: z.string().optional(),
        action: z.string().optional(),
      }).optional(),
      metadata: z.record(z.any()).optional(),
      stackTrace: z.string().optional(),
    });

    const parsed = schema.parse(body);

    const error = createError(
      parsed.type as any,
      parsed.technicalMessage || parsed.message,
      { userId: user.id, ...parsed.context },
      parsed.metadata
    );

    await logError(error, {
      stackTrace: parsed.stackTrace,
      userAgent: req.headers.get('user-agent') || undefined,
      ipAddress: req.headers.get('x-forwarded-for') || req.ip,
    });

    return NextResponse.json({
      success: true,
      errorId: error.id
    });
  } catch (error) {
    console.error('Error logging failed:', error);
    return NextResponse.json(
      { error: 'Failed to log error' },
      { status: 500 }
    );
  }
}

/**
 * GET /api/v1/errors/stats - ì—ëŸ¬ í†µê³„ ì¡°íšŒ
 */
export async function GET(req: NextRequest) {
  try {
    const user = await getAuthUser(req);
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(req.url);
    const range = searchParams.get('range') || '7d';

    const now = new Date();
    const start = new Date();

    switch (range) {
      case '24h':
        start.setHours(start.getHours() - 24);
        break;
      case '7d':
        start.setDate(start.getDate() - 7);
        break;
      case '30d':
        start.setDate(start.getDate() - 30);
        break;
      default:
        start.setDate(start.getDate() - 7);
    }

    const stats = await getErrorStats(user.id, { start, end: now });

    return NextResponse.json({ data: stats });
  } catch (error) {
    console.error('Error stats fetch failed:', error);
    return NextResponse.json(
      { error: 'Failed to fetch error stats' },
      { status: 500 }
    );
  }
}
```

```typescript
// src/app/api/v1/errors/[errorId]/recovery/route.ts - Part 6.1

import { NextRequest, NextResponse } from 'next/server';
import { getAuthUser } from '@/lib/auth';
import {
  retryWithBackoff,
  refreshAuthToken,
  reconnect,
  activateFallback
} from '@/lib/errors/recovery';
import { logRecoveryResult } from '@/lib/errors/logging';
import { z } from 'zod';

/**
 * POST /api/v1/errors/:errorId/recovery - ì—ëŸ¬ ë³µêµ¬ ì‹œë„
 */
export async function POST(
  req: NextRequest,
  { params }: { params: { errorId: string } }
) {
  try {
    const user = await getAuthUser(req);
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();

    const schema = z.object({
      strategy: z.enum([
        'retry_with_backoff',
        'refresh_token',
        'reconnect',
        'fallback',
      ]),
      errorType: z.string(),
      sessionId: z.string().optional(),
      provider: z.enum(['google', 'notion', 'hubspot', 'slack']).optional(),
    });

    const { strategy, errorType, sessionId, provider } = schema.parse(body);

    let result;

    switch (strategy) {
      case 'refresh_token':
        if (!provider) {
          return NextResponse.json(
            { error: 'Provider required for token refresh' },
            { status: 400 }
          );
        }
        result = await refreshAuthToken(user.id, provider);
        break;

      case 'reconnect':
        if (!sessionId) {
          return NextResponse.json(
            { error: 'Session ID required for reconnect' },
            { status: 400 }
          );
        }
        result = await reconnect(user.id, sessionId);
        break;

      case 'fallback':
        result = await activateFallback(errorType, user.id, sessionId);
        break;

      case 'retry_with_backoff':
        // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì¬ì‹œë„ ë¡œì§ ì‹¤í–‰
        // ì„œë²„ì—ì„œëŠ” ë³µêµ¬ ì‹œë„ ê¸°ë¡ë§Œ
        result = { success: true };
        break;

      default:
        return NextResponse.json(
          { error: 'Invalid recovery strategy' },
          { status: 400 }
        );
    }

    // ë³µêµ¬ ê²°ê³¼ ë¡œê¹…
    await logRecoveryResult(
      params.errorId,
      result.success,
      result.error?.technicalMessage
    );

    return NextResponse.json({
      success: result.success,
      fallbackActivated: result.fallbackActivated,
      error: result.error ? {
        type: result.error.type,
        message: result.error.message,
      } : undefined,
    });
  } catch (error) {
    console.error('Recovery failed:', error);
    return NextResponse.json(
      { error: 'Recovery attempt failed' },
      { status: 500 }
    );
  }
}
```

#### 9.3.7 ì—ëŸ¬ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```prisma
// prisma/schema.prisma - Part 6.1 ì¶”ê°€

model ErrorLog {
  id                  String    @id @default(uuid())
  errorId             String    @unique
  type                String
  domain              String
  severity            String
  code                String
  message             String
  technicalMessage    String
  userId              String?
  sessionId           String?
  meetingId           String?
  part                String?
  component           String?
  action              String?
  metadata            Json?
  stackTrace          String?   @db.Text
  recoveryAttempted   Boolean   @default(false)
  recoveryStrategy    String?
  recoveryResult      String?   // 'SUCCESS' | 'FAILED' | null
  recoveryDetails     String?
  recoveryAttemptedAt DateTime?
  userAgent           String?
  ipAddress           String?
  createdAt           DateTime  @default(now())

  // Relations
  user                User?     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([domain])
  @@index([severity])
  @@index([type])
  @@index([createdAt])
  @@index([code])
}

// HudSession ëª¨ë¸ì— í´ë°± í•„ë“œ ì¶”ê°€
model HudSession {
  // ... ê¸°ì¡´ í•„ë“œ

  // Part 6.1: í´ë°± ëª¨ë“œ í•„ë“œ
  fallbackMode          String?   // 'LOCAL_BUFFER' | 'BASIC_SUMMARY' | null
  fallbackActivatedAt   DateTime?
  audioQualityMode      String?   // 'HIGH' | 'LOW' | 'AUTO'
  lastReconnectAttempt  DateTime?
}
```

#### 9.3.8 ì—ëŸ¬ ë¯¸ë“¤ì›¨ì–´

```typescript
// src/middleware/errorMiddleware.ts - Part 6.1

import { NextRequest, NextResponse } from 'next/server';
import { createError } from '@/lib/errors/factory';
import { createErrorResponse, getHttpStatusCode } from '@/lib/errors/response';
import { logError } from '@/lib/errors/logging';

/**
 * ê¸€ë¡œë²Œ ì—ëŸ¬ ë¯¸ë“¤ì›¨ì–´
 */
export async function withErrorHandling(
  handler: (req: NextRequest) => Promise<NextResponse>,
  req: NextRequest
): Promise<NextResponse> {
  try {
    return await handler(req);
  } catch (error: any) {
    // ì´ë¯¸ ì²˜ë¦¬ëœ ì—ëŸ¬ì¸ ê²½ìš°
    if (error.id && error.type && error.domain) {
      const enhancedError = error;
      await logError(enhancedError, {
        userAgent: req.headers.get('user-agent') || undefined,
        ipAddress: req.headers.get('x-forwarded-for') || req.ip,
      });

      return NextResponse.json(
        createErrorResponse(enhancedError),
        { status: getHttpStatusCode(enhancedError) }
      );
    }

    // ì•Œ ìˆ˜ ì—†ëŠ” ì—ëŸ¬ ì²˜ë¦¬
    const unknownError = createError(
      'NETWORK_SERVER_ERROR',
      error.message || 'Unknown error occurred',
      {
        action: req.nextUrl.pathname,
      },
      { originalError: error.toString() }
    );

    await logError(unknownError, {
      stackTrace: error.stack,
      userAgent: req.headers.get('user-agent') || undefined,
      ipAddress: req.headers.get('x-forwarded-for') || req.ip,
    });

    return NextResponse.json(
      createErrorResponse(unknownError),
      { status: 500 }
    );
  }
}

/**
 * API Route ë˜í¼
 */
export function withErrorHandler(
  handler: (req: NextRequest) => Promise<NextResponse>
) {
  return async (req: NextRequest) => {
    return withErrorHandling(handler, req);
  };
}
```

#### 9.3.9 ì—ëŸ¬ ë©”ì‹œì§€ êµ­ì œí™”

```typescript
// src/lib/errors/i18n.ts - Part 6.1

/**
 * ì—ëŸ¬ ë©”ì‹œì§€ ë²ˆì—­ í‚¤
 */
export const ERROR_MESSAGES: Record<string, Record<string, string>> = {
  ko: {
    // Network
    'error.network.offline': 'ì¸í„°ë„· ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.',
    'error.network.timeout': 'ìš”ì²­ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    'error.network.server': 'ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',

    // Auth
    'error.auth.session_expired': 'ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.',
    'error.auth.token_invalid': 'ì¸ì¦ ì •ë³´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.',
    'error.auth.permission_denied': 'ì´ ì‘ì—…ì„ ìˆ˜í–‰í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.',
    'error.auth.google_oauth_failed': 'Google ë¡œê·¸ì¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',

    // Integration
    'error.integration.calendar_sync': 'ìº˜ë¦°ë” ë™ê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    'error.integration.notion_auth': 'Notion ì—°ê²°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì—°ê²°í•´ì£¼ì„¸ìš”.',
    'error.integration.notion_save': 'Notion ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    'error.integration.hubspot_auth': 'HubSpot ì—°ê²°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì—°ê²°í•´ì£¼ì„¸ìš”.',
    'error.integration.hubspot_sync': 'HubSpot ë™ê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    'error.integration.slack_disconnected': 'Slack ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì—°ê²°í•´ì£¼ì„¸ìš”.',

    // AI
    'error.ai.stt_failed': 'ìŒì„± ì¸ì‹ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë§ˆì´í¬ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.',
    'error.ai.analysis_failed': 'AI ë¶„ì„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    'error.ai.rate_limited': 'ìš”ì²­ì´ ë„ˆë¬´ ë§ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    'error.ai.quota_exceeded': 'AI ì‚¬ìš©ëŸ‰ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. í”Œëœì„ ì—…ê·¸ë ˆì´ë“œí•´ì£¼ì„¸ìš”.',

    // Media
    'error.media.mic_permission': 'ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ í—ˆìš©í•´ì£¼ì„¸ìš”.',
    'error.media.mic_not_found': 'ë§ˆì´í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë§ˆì´í¬ë¥¼ ì—°ê²°í•´ì£¼ì„¸ìš”.',
    'error.media.recording_failed': 'ë…¹ìŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    'error.media.audio_quality': 'ì˜¤ë””ì˜¤ í’ˆì§ˆì´ ë‚®ìŠµë‹ˆë‹¤. ë§ˆì´í¬ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.',

    // Storage
    'error.storage.quota_exceeded': 'ì €ì¥ ê³µê°„ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ë¶ˆí•„ìš”í•œ íŒŒì¼ì„ ì‚­ì œí•´ì£¼ì„¸ìš”.',
    'error.storage.upload_failed': 'íŒŒì¼ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    'error.storage.read_failed': 'íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',

    // Validation
    'error.validation.invalid_input': 'ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. í™•ì¸ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    'error.validation.missing_field': 'í•„ìˆ˜ í•­ëª©ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤. ëª¨ë“  í•­ëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.',

    // CTA Labels
    'error.cta.retry': 'ë‹¤ì‹œ ì‹œë„',
    'error.cta.reconnect': 'ë‹¤ì‹œ ì—°ê²°',
    'error.cta.login': 'ë¡œê·¸ì¸',
    'error.cta.settings': 'ì„¤ì •ìœ¼ë¡œ ì´ë™',
    'error.cta.upgrade': 'í”Œëœ ì—…ê·¸ë ˆì´ë“œ',
    'error.cta.dismiss': 'ë‹«ê¸°',
  },
  en: {
    // Network
    'error.network.offline': 'You are offline. Please check your connection.',
    'error.network.timeout': 'Request timed out. Please try again.',
    'error.network.server': 'Cannot connect to server. Please try again later.',

    // Auth
    'error.auth.session_expired': 'Your session has expired. Please log in again.',
    'error.auth.token_invalid': 'Authentication invalid. Please log in again.',
    'error.auth.permission_denied': 'You don\'t have permission for this action.',
    'error.auth.google_oauth_failed': 'Google login failed. Please try again.',

    // ... ë‚˜ë¨¸ì§€ ì˜ì–´ ë²ˆì—­
  },
};

/**
 * ì—ëŸ¬ ë©”ì‹œì§€ ë²ˆì—­ í•¨ìˆ˜
 */
export function translateErrorMessage(
  key: string,
  locale: string = 'ko'
): string {
  return ERROR_MESSAGES[locale]?.[key] || ERROR_MESSAGES['ko'][key] || key;
}
```

#### 9.3.10 ì—ëŸ¬ ì²˜ë¦¬ ì„±ëŠ¥ ì§€í‘œ

```typescript
// src/lib/errors/metrics.ts - Part 6.1

/**
 * Part 6.1 ì—ëŸ¬ ì²˜ë¦¬ ëª©í‘œ ì§€í‘œ
 */
export const ERROR_METRICS_TARGETS = {
  // ì—ëŸ¬ìœ¨
  errorRate: {
    target: 0.01, // 1% ë¯¸ë§Œ
    warning: 0.02,
    critical: 0.05,
  },

  // ìë™ ë³µêµ¬ìœ¨
  autoRecoveryRate: {
    target: 0.7, // 70% ì´ìƒ
    warning: 0.5,
    critical: 0.3,
  },

  // ì‚¬ìš©ì ë³µêµ¬ìœ¨
  userRecoveryRate: {
    target: 0.6, // 60% ì´ìƒ
    warning: 0.4,
    critical: 0.2,
  },

  // ì—ëŸ¬ ì´íƒˆìœ¨
  errorChurnRate: {
    target: 0.1, // 10% ë¯¸ë§Œ
    warning: 0.2,
    critical: 0.3,
  },

  // ì—ëŸ¬ í‘œì‹œ ì‹œê°„
  errorDisplayTime: {
    target: 100, // 100ms ì´ë‚´
    warning: 200,
    critical: 500,
  },

  // ë³µêµ¬ ì‹œë„ ì‹œê°„
  recoveryAttemptTime: {
    target: 1000, // 1ì´ˆ ì´ë‚´
    warning: 3000,
    critical: 5000,
  },
};

/**
 * ì—ëŸ¬ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ í•¨ìˆ˜
 */
export async function collectErrorMetrics(
  userId: string,
  timeRange: { start: Date; end: Date }
): Promise<{
  errorRate: number;
  autoRecoveryRate: number;
  userRecoveryRate: number;
  errorChurnRate: number;
  status: 'healthy' | 'warning' | 'critical';
}> {
  const stats = await getErrorStats(userId, timeRange);

  // ì „ì²´ ìš”ì²­ ìˆ˜ ëŒ€ë¹„ ì—ëŸ¬ìœ¨ ê³„ì‚°
  // (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì´ ìš”ì²­ ìˆ˜ ì¶”ì  í•„ìš”)
  const errorRate = stats.totalErrors / 1000; // ì˜ˆì‹œ

  const autoRecoveryRate = stats.recoveryRate;

  // ì‚¬ìš©ì ë³µêµ¬ìœ¨ (CTA í´ë¦­ í›„ ì„±ê³µ)
  // (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë³„ë„ ì¶”ì  í•„ìš”)
  const userRecoveryRate = 0.65; // ì˜ˆì‹œ

  // ì—ëŸ¬ ë°œìƒ í›„ ì´íƒˆìœ¨
  // (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì„¸ì…˜ ì¶”ì  í•„ìš”)
  const errorChurnRate = 0.08; // ì˜ˆì‹œ

  // ìƒíƒœ íŒë‹¨
  let status: 'healthy' | 'warning' | 'critical' = 'healthy';

  if (
    errorRate > ERROR_METRICS_TARGETS.errorRate.critical ||
    autoRecoveryRate < ERROR_METRICS_TARGETS.autoRecoveryRate.critical ||
    errorChurnRate > ERROR_METRICS_TARGETS.errorChurnRate.critical
  ) {
    status = 'critical';
  } else if (
    errorRate > ERROR_METRICS_TARGETS.errorRate.warning ||
    autoRecoveryRate < ERROR_METRICS_TARGETS.autoRecoveryRate.warning ||
    errorChurnRate > ERROR_METRICS_TARGETS.errorChurnRate.warning
  ) {
    status = 'warning';
  }

  return {
    errorRate,
    autoRecoveryRate,
    userRecoveryRate,
    errorChurnRate,
    status,
  };
}
```

---

## 10. ì„±ëŠ¥ ë° í™•ì¥ì„±

### 10.1 ìºì‹± ì „ëµ

```typescript
// src/lib/cache.ts
import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_URL!,
  token: process.env.UPSTASH_REDIS_TOKEN!,
});

export async function getCached<T>(
  key: string,
  fetcher: () => Promise<T>,
  ttl: number = 300 // 5ë¶„
): Promise<T> {
  // 1. ìºì‹œì—ì„œ í™•ì¸
  const cached = await redis.get(key);
  if (cached) {
    return cached as T;
  }

  // 2. ì—†ìœ¼ë©´ fetcher ì‹¤í–‰
  const data = await fetcher();

  // 3. ìºì‹œì— ì €ì¥
  await redis.set(key, data, { ex: ttl });

  return data;
}

// ì‚¬ìš© ì˜ˆì‹œ
export async function getMeetings(userId: string) {
  return getCached(
    `meetings:${userId}`,
    () => prisma.meeting.findMany({ where: { userId } }),
    300
  );
}
```

### 10.2 ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”

```typescript
// 1. ì»¤ë„¥ì…˜ í’€ ì„¤ì •
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  relationMode = "prisma"
}

// .env
DATABASE_URL="postgresql://user:pass@host:5432/db?connection_limit=10"

// 2. ì¿¼ë¦¬ ìµœì í™” (N+1 ë°©ì§€)
const meetings = await prisma.meeting.findMany({
  where: { userId },
  include: {
    decisions: true,
    insights: true,
    actions: true,
  },
  take: 20,
  orderBy: { startTime: 'desc' },
});
```

### 10.3 ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…

```typescript
// src/lib/queue.ts (í–¥í›„ BullMQ ë„ì… ê¶Œì¥)
export async function processAsync<T>(
  task: () => Promise<T>
): Promise<void> {
  // ë¹„ë™ê¸°ë¡œ ì‹¤í–‰ (ì‘ë‹µ ì¦‰ì‹œ ë°˜í™˜)
  task().catch((error) => {
    console.error('Background task failed:', error);
    // Sentry ë“± ì—ëŸ¬ íŠ¸ë˜í‚¹
  });
}

// ì‚¬ìš© ì˜ˆì‹œ: í†µí•© ì‘ì—…ì€ ë°±ê·¸ë¼ìš´ë“œì—ì„œ
export async function confirmMeeting(meetingId: string) {
  // 1. ì¦‰ì‹œ ì‘ë‹µ
  const meeting = await prisma.meeting.update({
    where: { id: meetingId },
    data: { status: 'COMPLETED' },
  });

  // 2. í†µí•© ì‘ì—…ì€ ë°±ê·¸ë¼ìš´ë“œ
  processAsync(async () => {
    await createMeetingPage(meeting.userId, meeting);
    await updateDeal(meeting.userId, meeting);
    await postToSlack(meeting.userId, meeting);
  });

  return meeting;
}
```

### 10.4 Part 6.2: ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ API (Streaming Response)

```typescript
// src/lib/streaming.ts
// 5-Layer Framework: Structure/Logic Layer - ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ êµ¬í˜„

import { NextResponse } from 'next/server';

// ============================================
// 10.4.1 ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ íƒ€ì… ì •ì˜
// ============================================

type StreamingChunkType =
  | 'start'           // ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘
  | 'chunk'           // ë°ì´í„° ì²­í¬
  | 'progress'        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
  | 'metadata'        // ë©”íƒ€ë°ì´í„°
  | 'complete'        // ì™„ë£Œ
  | 'error';          // ì—ëŸ¬

interface StreamingChunk<T = unknown> {
  type: StreamingChunkType;
  data?: T;
  progress?: number;        // 0-100
  estimatedTimeMs?: number; // ë‚¨ì€ ì˜ˆìƒ ì‹œê°„
  timestamp: number;
  chunkIndex: number;
}

interface StreamingOptions {
  onStart?: () => void;
  onChunk?: (chunk: StreamingChunk) => void;
  onProgress?: (progress: number) => void;
  onComplete?: () => void;
  onError?: (error: Error) => void;
  chunkDelay?: number;  // ì²­í¬ ê°„ ìµœì†Œ ë”œë ˆì´ (ms)
}

// ============================================
// 10.4.2 ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ìœ í‹¸ë¦¬í‹°
// ============================================

export function createStreamingResponse(
  generator: AsyncGenerator<StreamingChunk>,
  options?: { contentType?: string }
): Response {
  const encoder = new TextEncoder();

  const stream = new ReadableStream({
    async start(controller) {
      let chunkIndex = 0;

      try {
        // ì‹œì‘ ì²­í¬ ì „ì†¡
        const startChunk: StreamingChunk = {
          type: 'start',
          timestamp: Date.now(),
          chunkIndex: chunkIndex++,
        };
        controller.enqueue(
          encoder.encode(`data: ${JSON.stringify(startChunk)}\n\n`)
        );

        // ë°ì´í„° ì²­í¬ ì „ì†¡
        for await (const chunk of generator) {
          const enrichedChunk = {
            ...chunk,
            chunkIndex: chunkIndex++,
            timestamp: chunk.timestamp || Date.now(),
          };
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify(enrichedChunk)}\n\n`)
          );
        }

        // ì™„ë£Œ ì²­í¬ ì „ì†¡
        const completeChunk: StreamingChunk = {
          type: 'complete',
          timestamp: Date.now(),
          chunkIndex: chunkIndex++,
        };
        controller.enqueue(
          encoder.encode(`data: ${JSON.stringify(completeChunk)}\n\n`)
        );

      } catch (error) {
        // ì—ëŸ¬ ì²­í¬ ì „ì†¡
        const errorChunk: StreamingChunk = {
          type: 'error',
          data: error instanceof Error ? error.message : 'Unknown error',
          timestamp: Date.now(),
          chunkIndex: chunkIndex++,
        };
        controller.enqueue(
          encoder.encode(`data: ${JSON.stringify(errorChunk)}\n\n`)
        );
      } finally {
        controller.close();
      }
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': options?.contentType || 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'X-Accel-Buffering': 'no', // Nginx ë²„í¼ë§ ë¹„í™œì„±í™”
    },
  });
}

// ============================================
// 10.4.3 AI ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ (GPT/Claude)
// ============================================

export async function* streamAIResponse(
  prompt: string,
  context: { userId: string; meetingId?: string }
): AsyncGenerator<StreamingChunk> {
  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

  const stream = await openai.chat.completions.create({
    model: 'gpt-4-turbo',
    messages: [{ role: 'user', content: prompt }],
    stream: true,
  });

  let totalTokens = 0;
  const estimatedTotalTokens = Math.ceil(prompt.length / 4) * 3; // ëŒ€ëµì  ì¶”ì •

  for await (const chunk of stream) {
    const content = chunk.choices[0]?.delta?.content || '';
    totalTokens += content.length / 4; // ëŒ€ëµì  í† í° ì¶”ì •

    if (content) {
      yield {
        type: 'chunk',
        data: content,
        progress: Math.min(99, Math.round((totalTokens / estimatedTotalTokens) * 100)),
        timestamp: Date.now(),
        chunkIndex: 0, // ì‹¤ì œ chunkIndexëŠ” createStreamingResponseì—ì„œ ì„¤ì •
      };
    }
  }
}

// ============================================
// 10.4.4 ìŠ¤íŠ¸ë¦¬ë° API ì—”ë“œí¬ì¸íŠ¸
// ============================================

// POST /api/ai/stream
export async function POST(req: NextRequest) {
  const { userId } = await validateSession(req);
  const { prompt, meetingId } = await req.json();

  const generator = streamAIResponse(prompt, { userId, meetingId });
  return createStreamingResponse(generator);
}

// ì‹¤ì‹œê°„ ë¯¸íŒ… ë¶„ì„ ìŠ¤íŠ¸ë¦¬ë°
// POST /api/meetings/[id]/analyze/stream
export async function streamMeetingAnalysis(
  meetingId: string,
  userId: string
): AsyncGenerator<StreamingChunk> {
  const meeting = await prisma.meeting.findUnique({
    where: { id: meetingId },
    include: { transcript: true },
  });

  if (!meeting) throw new Error('Meeting not found');

  const stages = [
    { name: 'ì „ì‚¬ ë¶„ì„', weight: 20 },
    { name: 'í•µì‹¬ ì£¼ì œ ì¶”ì¶œ', weight: 30 },
    { name: 'ê²°ì • ì‚¬í•­ ì‹ë³„', weight: 30 },
    { name: 'ì•¡ì…˜ ì•„ì´í…œ ì •ë¦¬', weight: 20 },
  ];

  let currentProgress = 0;

  for (const stage of stages) {
    // ìŠ¤í…Œì´ì§€ ì‹œì‘ ë©”íƒ€ë°ì´í„°
    yield {
      type: 'metadata',
      data: { stage: stage.name },
      progress: currentProgress,
      timestamp: Date.now(),
      chunkIndex: 0,
    };

    // AI ë¶„ì„ ìŠ¤íŠ¸ë¦¬ë°
    const stageGenerator = streamAIResponse(
      `Analyze ${stage.name} for meeting: ${meeting.transcript?.content}`,
      { userId, meetingId }
    );

    for await (const chunk of stageGenerator) {
      const adjustedProgress = currentProgress +
        ((chunk.progress || 0) / 100) * stage.weight;

      yield {
        ...chunk,
        progress: Math.round(adjustedProgress),
      };
    }

    currentProgress += stage.weight;
  }
}
```

### 10.5 Part 6.2: ì§„í–‰ë¥  ì¶”ì  API (Progress Tracking)

```typescript
// src/lib/progress-tracker.ts
// 5-Layer Framework: Structure/Logic Layer - ì§„í–‰ë¥  ì¶”ì 

import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_URL!,
  token: process.env.UPSTASH_REDIS_TOKEN!,
});

// ============================================
// 10.5.1 ì§„í–‰ë¥  ìƒíƒœ íƒ€ì…
// ============================================

type ProgressStatus =
  | 'pending'       // ëŒ€ê¸° ì¤‘
  | 'processing'    // ì²˜ë¦¬ ì¤‘
  | 'completed'     // ì™„ë£Œ
  | 'failed'        // ì‹¤íŒ¨
  | 'cancelled';    // ì·¨ì†Œë¨

interface ProgressState {
  id: string;
  status: ProgressStatus;
  progress: number;           // 0-100
  currentStep: string;        // í˜„ì¬ ë‹¨ê³„ ì„¤ëª…
  totalSteps: number;         // ì „ì²´ ë‹¨ê³„ ìˆ˜
  currentStepIndex: number;   // í˜„ì¬ ë‹¨ê³„ ì¸ë±ìŠ¤
  startedAt: number;          // ì‹œì‘ ì‹œê°„ (timestamp)
  updatedAt: number;          // ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ (timestamp)
  estimatedCompletionMs?: number; // ì˜ˆìƒ ë‚¨ì€ ì‹œê°„
  metadata?: Record<string, unknown>;
  error?: {
    code: string;
    message: string;
  };
}

// ============================================
// 10.5.2 ì§„í–‰ë¥  ì¶”ì  ì„œë¹„ìŠ¤
// ============================================

export class ProgressTracker {
  private readonly keyPrefix = 'progress:';
  private readonly ttl = 3600; // 1ì‹œê°„

  async create(id: string, totalSteps: number, metadata?: Record<string, unknown>): Promise<ProgressState> {
    const state: ProgressState = {
      id,
      status: 'pending',
      progress: 0,
      currentStep: 'ì¤€ë¹„ ì¤‘...',
      totalSteps,
      currentStepIndex: 0,
      startedAt: Date.now(),
      updatedAt: Date.now(),
      metadata,
    };

    await redis.set(
      `${this.keyPrefix}${id}`,
      JSON.stringify(state),
      { ex: this.ttl }
    );

    // WebSocketìœ¼ë¡œ ì´ˆê¸° ìƒíƒœ ë¸Œë¡œë“œìºìŠ¤íŠ¸
    await this.broadcastProgress(id, state);

    return state;
  }

  async update(
    id: string,
    updates: Partial<Pick<ProgressState, 'progress' | 'currentStep' | 'currentStepIndex' | 'status' | 'estimatedCompletionMs'>>
  ): Promise<ProgressState | null> {
    const key = `${this.keyPrefix}${id}`;
    const existing = await redis.get(key);

    if (!existing) return null;

    const state = JSON.parse(existing as string) as ProgressState;
    const updatedState: ProgressState = {
      ...state,
      ...updates,
      updatedAt: Date.now(),
    };

    await redis.set(key, JSON.stringify(updatedState), { ex: this.ttl });

    // WebSocketìœ¼ë¡œ ì—…ë°ì´íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸
    await this.broadcastProgress(id, updatedState);

    return updatedState;
  }

  async complete(id: string, metadata?: Record<string, unknown>): Promise<ProgressState | null> {
    return this.update(id, {
      status: 'completed',
      progress: 100,
      currentStep: 'ì™„ë£Œ',
      ...(metadata && { metadata }),
    } as Partial<ProgressState>);
  }

  async fail(id: string, error: { code: string; message: string }): Promise<ProgressState | null> {
    const key = `${this.keyPrefix}${id}`;
    const existing = await redis.get(key);

    if (!existing) return null;

    const state = JSON.parse(existing as string) as ProgressState;
    const updatedState: ProgressState = {
      ...state,
      status: 'failed',
      updatedAt: Date.now(),
      error,
    };

    await redis.set(key, JSON.stringify(updatedState), { ex: this.ttl });
    await this.broadcastProgress(id, updatedState);

    return updatedState;
  }

  async get(id: string): Promise<ProgressState | null> {
    const existing = await redis.get(`${this.keyPrefix}${id}`);
    return existing ? JSON.parse(existing as string) : null;
  }

  async cancel(id: string): Promise<ProgressState | null> {
    return this.update(id, {
      status: 'cancelled',
      currentStep: 'ì·¨ì†Œë¨',
    });
  }

  private async broadcastProgress(id: string, state: ProgressState): Promise<void> {
    // Redis Pub/Subë¥¼ í†µí•œ WebSocket ë¸Œë¡œë“œìºìŠ¤íŠ¸
    await redis.publish('progress-updates', JSON.stringify({
      id,
      state,
    }));
  }
}

export const progressTracker = new ProgressTracker();

// ============================================
// 10.5.3 ì§„í–‰ë¥  ì¶”ì  API ì—”ë“œí¬ì¸íŠ¸
// ============================================

// GET /api/progress/[id]
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const { userId } = await validateSession(req);
  const progress = await progressTracker.get(params.id);

  if (!progress) {
    return NextResponse.json(
      { error: { code: 'NOT_FOUND', message: 'Progress not found' } },
      { status: 404 }
    );
  }

  return NextResponse.json({
    success: true,
    data: progress,
  });
}

// DELETE /api/progress/[id] - ì‘ì—… ì·¨ì†Œ
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const { userId } = await validateSession(req);
  const progress = await progressTracker.cancel(params.id);

  if (!progress) {
    return NextResponse.json(
      { error: { code: 'NOT_FOUND', message: 'Progress not found' } },
      { status: 404 }
    );
  }

  return NextResponse.json({
    success: true,
    data: progress,
  });
}
```

### 10.6 Part 6.2: ì¥ê¸° ì‹¤í–‰ ì‘ì—… íŒ¨í„´ (Long-Running Operations)

```typescript
// src/lib/long-running-operations.ts
// 5-Layer Framework: Structure/Logic Layer - ì¥ê¸° ì‹¤í–‰ ì‘ì—…

import { v4 as uuidv4 } from 'uuid';
import { progressTracker } from './progress-tracker';

// ============================================
// 10.6.1 ì¥ê¸° ì‹¤í–‰ ì‘ì—… íƒ€ì…
// ============================================

type OperationType =
  | 'meeting_analysis'      // ë¯¸íŒ… ë¶„ì„
  | 'bulk_export'           // ëŒ€ëŸ‰ ë‚´ë³´ë‚´ê¸°
  | 'notion_sync'           // Notion ë™ê¸°í™”
  | 'salesforce_sync'       // Salesforce ë™ê¸°í™”
  | 'search_reindex'        // ê²€ìƒ‰ ì¬ìƒ‰ì¸
  | 'audio_transcription';  // ì˜¤ë””ì˜¤ ì „ì‚¬

interface LongRunningOperation {
  id: string;
  type: OperationType;
  userId: string;
  status: 'queued' | 'processing' | 'completed' | 'failed' | 'cancelled';
  progress: number;
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
  result?: unknown;
  error?: { code: string; message: string };
  metadata?: Record<string, unknown>;
}

// ============================================
// 10.6.2 ì¥ê¸° ì‹¤í–‰ ì‘ì—… ì„œë¹„ìŠ¤
// ============================================

export class LongRunningOperationService {

  async createOperation(
    type: OperationType,
    userId: string,
    metadata?: Record<string, unknown>
  ): Promise<LongRunningOperation> {
    const operationId = uuidv4();

    const operation: LongRunningOperation = {
      id: operationId,
      type,
      userId,
      status: 'queued',
      progress: 0,
      createdAt: new Date(),
      metadata,
    };

    // DBì— ì €ì¥
    await prisma.longRunningOperation.create({
      data: {
        id: operationId,
        type,
        userId,
        status: 'queued',
        progress: 0,
        metadata: metadata || {},
      },
    });

    // ì§„í–‰ë¥  ì¶”ì  ì‹œì‘
    await progressTracker.create(operationId, this.getStepsForType(type), {
      type,
      userId,
    });

    return operation;
  }

  async startOperation(
    operationId: string,
    executor: (onProgress: (progress: number, step: string) => Promise<void>) => Promise<unknown>
  ): Promise<void> {
    // ìƒíƒœ ì—…ë°ì´íŠ¸: processing
    await prisma.longRunningOperation.update({
      where: { id: operationId },
      data: { status: 'processing', startedAt: new Date() },
    });

    await progressTracker.update(operationId, {
      status: 'processing',
      currentStep: 'ì²˜ë¦¬ ì‹œì‘...',
    });

    try {
      const result = await executor(async (progress, step) => {
        await progressTracker.update(operationId, {
          progress,
          currentStep: step,
        });
      });

      // ì™„ë£Œ ì²˜ë¦¬
      await prisma.longRunningOperation.update({
        where: { id: operationId },
        data: {
          status: 'completed',
          completedAt: new Date(),
          result: result || {},
        },
      });

      await progressTracker.complete(operationId);

    } catch (error) {
      // ì‹¤íŒ¨ ì²˜ë¦¬
      const errorInfo = {
        code: 'OPERATION_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      };

      await prisma.longRunningOperation.update({
        where: { id: operationId },
        data: {
          status: 'failed',
          error: errorInfo,
        },
      });

      await progressTracker.fail(operationId, errorInfo);
    }
  }

  private getStepsForType(type: OperationType): number {
    const stepMap: Record<OperationType, number> = {
      meeting_analysis: 4,     // ì „ì‚¬ ë¶„ì„ â†’ ì£¼ì œ ì¶”ì¶œ â†’ ê²°ì • ì‹ë³„ â†’ ì•¡ì…˜ ì •ë¦¬
      bulk_export: 3,          // ë°ì´í„° ìˆ˜ì§‘ â†’ í¬ë§· ë³€í™˜ â†’ íŒŒì¼ ìƒì„±
      notion_sync: 5,          // ì¸ì¦ í™•ì¸ â†’ ë°ì´í„° ìˆ˜ì§‘ â†’ ë³€í™˜ â†’ ì—…ë¡œë“œ â†’ ê²€ì¦
      salesforce_sync: 5,      // ë™ì¼
      search_reindex: 3,       // ë¬¸ì„œ ìˆ˜ì§‘ â†’ ì„ë² ë”© ìƒì„± â†’ ì¸ë±ì‹±
      audio_transcription: 4,  // ì˜¤ë””ì˜¤ ì²˜ë¦¬ â†’ ì „ì‚¬ â†’ ì •ë¦¬ â†’ ì €ì¥
    };
    return stepMap[type] || 3;
  }

  async getOperation(operationId: string): Promise<LongRunningOperation | null> {
    return prisma.longRunningOperation.findUnique({
      where: { id: operationId },
    });
  }

  async cancelOperation(operationId: string): Promise<void> {
    await prisma.longRunningOperation.update({
      where: { id: operationId },
      data: { status: 'cancelled' },
    });
    await progressTracker.cancel(operationId);
  }

  async getUserOperations(
    userId: string,
    options?: { status?: string; limit?: number }
  ): Promise<LongRunningOperation[]> {
    return prisma.longRunningOperation.findMany({
      where: {
        userId,
        ...(options?.status && { status: options.status }),
      },
      take: options?.limit || 10,
      orderBy: { createdAt: 'desc' },
    });
  }
}

export const longRunningOperationService = new LongRunningOperationService();

// ============================================
// 10.6.3 ì¥ê¸° ì‹¤í–‰ ì‘ì—… API ì—”ë“œí¬ì¸íŠ¸
// ============================================

// POST /api/operations
export async function POST(req: NextRequest) {
  const { userId } = await validateSession(req);
  const { type, metadata } = await req.json();

  const operation = await longRunningOperationService.createOperation(
    type,
    userId,
    metadata
  );

  // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‘ì—… ì‹œì‘
  processAsync(async () => {
    await longRunningOperationService.startOperation(
      operation.id,
      async (onProgress) => {
        // ì‹¤ì œ ì‘ì—… ë¡œì§ (typeì— ë”°ë¼ ë¶„ê¸°)
        return executeOperation(operation.type, operation.metadata, onProgress);
      }
    );
  });

  // ì¦‰ì‹œ ì‘ë‹µ (operation ID ë°˜í™˜)
  return NextResponse.json({
    success: true,
    data: {
      operationId: operation.id,
      status: 'queued',
      progressUrl: `/api/progress/${operation.id}`,
      streamUrl: `/api/operations/${operation.id}/stream`,
    },
  });
}

// GET /api/operations/[id]
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const { userId } = await validateSession(req);
  const operation = await longRunningOperationService.getOperation(params.id);

  if (!operation || operation.userId !== userId) {
    return NextResponse.json(
      { error: { code: 'NOT_FOUND', message: 'Operation not found' } },
      { status: 404 }
    );
  }

  return NextResponse.json({
    success: true,
    data: operation,
  });
}

// GET /api/operations - ì‚¬ìš©ìì˜ ëª¨ë“  ì‘ì—… ëª©ë¡
export async function GET(req: NextRequest) {
  const { userId } = await validateSession(req);
  const { searchParams } = new URL(req.url);
  const status = searchParams.get('status') || undefined;
  const limit = parseInt(searchParams.get('limit') || '10');

  const operations = await longRunningOperationService.getUserOperations(
    userId,
    { status, limit }
  );

  return NextResponse.json({
    success: true,
    data: operations,
  });
}
```

### 10.7 Part 6.2: ë¡œë”© íŒíŠ¸ ì‘ë‹µ ë©”íƒ€ë°ì´í„°

```typescript
// src/lib/loading-hints.ts
// 5-Layer Framework: Strategy Layer - í”„ë¡ íŠ¸ì—”ë“œì—ê²Œ ë¡œë”© íŒíŠ¸ ì œê³µ

// ============================================
// 10.7.1 ë¡œë”© íŒíŠ¸ íƒ€ì…
// ============================================

type LoadingHintType =
  | 'instant'           // ì¦‰ì‹œ ì™„ë£Œ (< 100ms)
  | 'fast'              // ë¹ ë¦„ (100-500ms)
  | 'moderate'          // ë³´í†µ (500ms-2s)
  | 'slow'              // ëŠë¦¼ (2-10s)
  | 'long_running'      // ì¥ê¸° ì‹¤í–‰ (> 10s)
  | 'streaming';        // ìŠ¤íŠ¸ë¦¬ë°

interface LoadingHint {
  type: LoadingHintType;
  estimatedDurationMs?: number;
  displayType: 'none' | 'skeleton' | 'spinner' | 'progress' | 'streaming';
  cancellable: boolean;
  retryable: boolean;
  progressTracking?: {
    enabled: boolean;
    pollingIntervalMs?: number;
    streamUrl?: string;
  };
}

// ============================================
// 10.7.2 APIë³„ ë¡œë”© íŒíŠ¸ ë§¤í•‘
// ============================================

const LOADING_HINTS: Record<string, LoadingHint> = {
  // ì¦‰ì‹œ ì‘ë‹µ API
  'GET /api/user/profile': {
    type: 'instant',
    displayType: 'none',
    cancellable: false,
    retryable: true,
  },

  // ë¹ ë¥¸ ì‘ë‹µ API
  'GET /api/meetings': {
    type: 'fast',
    estimatedDurationMs: 200,
    displayType: 'skeleton',
    cancellable: false,
    retryable: true,
  },

  // ë³´í†µ ì‘ë‹µ API
  'POST /api/search': {
    type: 'moderate',
    estimatedDurationMs: 1000,
    displayType: 'skeleton',
    cancellable: true,
    retryable: true,
  },

  // ëŠë¦° ì‘ë‹µ API
  'POST /api/meetings/[id]/analyze': {
    type: 'slow',
    estimatedDurationMs: 5000,
    displayType: 'progress',
    cancellable: true,
    retryable: true,
    progressTracking: {
      enabled: true,
      pollingIntervalMs: 1000,
    },
  },

  // ì¥ê¸° ì‹¤í–‰ API
  'POST /api/integrations/notion/sync': {
    type: 'long_running',
    estimatedDurationMs: 30000,
    displayType: 'progress',
    cancellable: true,
    retryable: true,
    progressTracking: {
      enabled: true,
      pollingIntervalMs: 2000,
    },
  },

  // ìŠ¤íŠ¸ë¦¬ë° API
  'POST /api/ai/stream': {
    type: 'streaming',
    displayType: 'streaming',
    cancellable: true,
    retryable: false,
    progressTracking: {
      enabled: true,
      streamUrl: '/api/ai/stream',
    },
  },
};

// ============================================
// 10.7.3 ë¡œë”© íŒíŠ¸ ë¯¸ë“¤ì›¨ì–´
// ============================================

export function withLoadingHints(handler: NextHandler): NextHandler {
  return async (req: NextRequest, context: NextContext) => {
    const response = await handler(req, context);

    // API ê²½ë¡œ í‚¤ ìƒì„±
    const method = req.method;
    const pathname = new URL(req.url).pathname
      .replace(/\/[a-f0-9-]{36}/g, '/[id]')  // UUIDë¥¼ [id]ë¡œ ì¹˜í™˜
      .replace(/\/\d+/g, '/[id]');            // ìˆ«ìë„ [id]ë¡œ ì¹˜í™˜

    const hintKey = `${method} ${pathname}`;
    const hint = LOADING_HINTS[hintKey];

    if (hint) {
      // í—¤ë”ì— ë¡œë”© íŒíŠ¸ ì¶”ê°€
      const headers = new Headers(response.headers);
      headers.set('X-Loading-Hint', JSON.stringify(hint));
      headers.set('X-Estimated-Duration-Ms', String(hint.estimatedDurationMs || 0));
      headers.set('X-Cancellable', String(hint.cancellable));

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers,
      });
    }

    return response;
  };
}

// ============================================
// 10.7.4 ì‘ë‹µ ì—”ë²¨ë¡œí”„ì— ë¡œë”© íŒíŠ¸ í¬í•¨
// ============================================

interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: { code: string; message: string };
  meta?: {
    loadingHint?: LoadingHint;
    timing?: {
      startedAt: number;
      completedAt: number;
      durationMs: number;
    };
    pagination?: {
      page: number;
      pageSize: number;
      totalCount: number;
      hasMore: boolean;
    };
  };
}

export function createApiResponse<T>(
  data: T,
  options?: {
    loadingHint?: LoadingHint;
    startTime?: number;
    pagination?: { page: number; pageSize: number; totalCount: number };
  }
): ApiResponse<T> {
  const completedAt = Date.now();

  return {
    success: true,
    data,
    meta: {
      ...(options?.loadingHint && { loadingHint: options.loadingHint }),
      ...(options?.startTime && {
        timing: {
          startedAt: options.startTime,
          completedAt,
          durationMs: completedAt - options.startTime,
        },
      }),
      ...(options?.pagination && {
        pagination: {
          ...options.pagination,
          hasMore: options.pagination.page * options.pagination.pageSize < options.pagination.totalCount,
        },
      }),
    },
  };
}
```

### 10.8 Part 6.2: ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… í´ë§ API

```typescript
// src/app/api/operations/[id]/poll/route.ts
// 5-Layer Framework: Structure/Logic Layer - í´ë§ API

import { NextRequest, NextResponse } from 'next/server';
import { progressTracker } from '@/lib/progress-tracker';

// ============================================
// 10.8.1 í´ë§ ì—”ë“œí¬ì¸íŠ¸
// ============================================

// GET /api/operations/[id]/poll
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const { userId } = await validateSession(req);
  const { searchParams } = new URL(req.url);

  // ë¡± í´ë§ íƒ€ì„ì•„ì›ƒ (ê¸°ë³¸ 30ì´ˆ, ìµœëŒ€ 60ì´ˆ)
  const timeoutMs = Math.min(
    parseInt(searchParams.get('timeout') || '30000'),
    60000
  );

  // ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ (ë³€ê²½ ê°ì§€ìš©)
  const lastUpdatedAt = parseInt(searchParams.get('lastUpdatedAt') || '0');

  const startTime = Date.now();
  let progress = await progressTracker.get(params.id);

  // ë¡± í´ë§: ë³€ê²½ì´ ìˆì„ ë•Œê¹Œì§€ ëŒ€ê¸°
  while (
    progress &&
    progress.updatedAt <= lastUpdatedAt &&
    progress.status !== 'completed' &&
    progress.status !== 'failed' &&
    progress.status !== 'cancelled' &&
    Date.now() - startTime < timeoutMs
  ) {
    await new Promise(resolve => setTimeout(resolve, 500)); // 500ms ê°„ê²©ìœ¼ë¡œ ì²´í¬
    progress = await progressTracker.get(params.id);
  }

  if (!progress) {
    return NextResponse.json(
      { error: { code: 'NOT_FOUND', message: 'Operation not found' } },
      { status: 404 }
    );
  }

  // ìºì‹œ ë°©ì§€ í—¤ë”
  return NextResponse.json(
    {
      success: true,
      data: progress,
      meta: {
        polledAt: Date.now(),
        changed: progress.updatedAt > lastUpdatedAt,
      },
    },
    {
      headers: {
        'Cache-Control': 'no-store, no-cache, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0',
      },
    }
  );
}

// ============================================
// 10.8.2 ë°°ì¹˜ í´ë§ ì—”ë“œí¬ì¸íŠ¸
// ============================================

// POST /api/operations/poll-batch
export async function POST(req: NextRequest) {
  const { userId } = await validateSession(req);
  const { operationIds } = await req.json();

  if (!Array.isArray(operationIds) || operationIds.length === 0) {
    return NextResponse.json(
      { error: { code: 'INVALID_INPUT', message: 'operationIds required' } },
      { status: 400 }
    );
  }

  // ìµœëŒ€ 10ê°œê¹Œì§€ë§Œ í—ˆìš©
  const limitedIds = operationIds.slice(0, 10);

  const results = await Promise.all(
    limitedIds.map(async (id) => {
      const progress = await progressTracker.get(id);
      return { id, progress };
    })
  );

  return NextResponse.json({
    success: true,
    data: results.reduce((acc, { id, progress }) => {
      if (progress) acc[id] = progress;
      return acc;
    }, {} as Record<string, ProgressState>),
  });
}
```

### 10.9 Part 6.2: ë¡œë”© ì„±ëŠ¥ ë©”íŠ¸ë¦­

```typescript
// src/lib/loading-metrics.ts
// 5-Layer Framework: Metrics Layer - ë¡œë”© ì„±ëŠ¥ ì¸¡ì •

// ============================================
// 10.9.1 ë¡œë”© ë©”íŠ¸ë¦­ íƒ€ì…
// ============================================

interface LoadingMetric {
  endpoint: string;
  method: string;
  duration: number;            // ì‘ë‹µ ì‹œê°„ (ms)
  status: 'success' | 'error' | 'cancelled' | 'timeout';
  timestamp: number;
  metadata?: {
    userId?: string;
    operationType?: string;
    dataSize?: number;         // ì‘ë‹µ í¬ê¸° (bytes)
    cacheHit?: boolean;        // ìºì‹œ íˆíŠ¸ ì—¬ë¶€
  };
}

// ë¡œë”© ë©”íŠ¸ë¦­ ëª©í‘œê°’
const LOADING_METRICS_TARGETS = {
  // ì‘ë‹µ ì‹œê°„ ëª©í‘œ (ms)
  responseTime: {
    p50: 200,    // 50% ìš”ì²­ì´ 200ms ì´ë‚´
    p90: 500,    // 90% ìš”ì²­ì´ 500ms ì´ë‚´
    p99: 2000,   // 99% ìš”ì²­ì´ 2ì´ˆ ì´ë‚´
  },

  // ë¡œë”© abandon rate (ì‚¬ìš©ìê°€ ë¡œë”© ì¤‘ ì´íƒˆ)
  abandonRate: {
    target: 0.05,    // 5% ë¯¸ë§Œ
    warning: 0.10,   // 10% ê²½ê³ 
    critical: 0.20,  // 20% ì‹¬ê°
  },

  // ë¡œë”© cancel rate (ì‚¬ìš©ìê°€ ì·¨ì†Œ)
  cancelRate: {
    target: 0.10,    // 10% ë¯¸ë§Œ
    warning: 0.20,   // 20% ê²½ê³ 
    critical: 0.30,  // 30% ì‹¬ê°
  },

  // Optimistic UI ë¡¤ë°±ë¥ 
  optimisticRollbackRate: {
    target: 0.02,    // 2% ë¯¸ë§Œ
    warning: 0.05,   // 5% ê²½ê³ 
    critical: 0.10,  // 10% ì‹¬ê°
  },

  // ìŠ¤íŠ¸ë¦¬ë° ì™„ë£Œìœ¨
  streamingCompletionRate: {
    target: 0.95,    // 95% ì´ìƒ
    warning: 0.85,   // 85% ê²½ê³ 
    critical: 0.70,  // 70% ì‹¬ê°
  },
};

// ============================================
// 10.9.2 ë¡œë”© ë©”íŠ¸ë¦­ ì„œë¹„ìŠ¤
// ============================================

export class LoadingMetricsService {
  private metrics: LoadingMetric[] = [];

  record(metric: LoadingMetric): void {
    this.metrics.push(metric);

    // ë²„í¼ê°€ ì°¨ë©´ Analytics ì„œë¹„ìŠ¤ë¡œ ì „ì†¡
    if (this.metrics.length >= 100) {
      this.flush();
    }
  }

  async flush(): Promise<void> {
    if (this.metrics.length === 0) return;

    const batch = [...this.metrics];
    this.metrics = [];

    // Analytics ì„œë¹„ìŠ¤ë¡œ ì „ì†¡ (ì˜ˆ: Mixpanel, Amplitude)
    await fetch('/api/analytics/batch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        events: batch.map(m => ({
          event: 'api_loading_metric',
          properties: m,
        })),
      }),
    });
  }

  calculatePercentiles(durations: number[]): {
    p50: number;
    p90: number;
    p99: number;
    mean: number;
  } {
    if (durations.length === 0) {
      return { p50: 0, p90: 0, p99: 0, mean: 0 };
    }

    const sorted = [...durations].sort((a, b) => a - b);
    const mean = sorted.reduce((a, b) => a + b, 0) / sorted.length;

    return {
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p90: sorted[Math.floor(sorted.length * 0.9)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
      mean,
    };
  }
}

export const loadingMetricsService = new LoadingMetricsService();

// ============================================
// 10.9.3 ë¡œë”© ë©”íŠ¸ë¦­ ë¯¸ë“¤ì›¨ì–´
// ============================================

export function withLoadingMetrics(handler: NextHandler): NextHandler {
  return async (req: NextRequest, context: NextContext) => {
    const startTime = Date.now();
    const userId = req.headers.get('x-user-id') || undefined;

    try {
      const response = await handler(req, context);

      loadingMetricsService.record({
        endpoint: new URL(req.url).pathname,
        method: req.method,
        duration: Date.now() - startTime,
        status: response.ok ? 'success' : 'error',
        timestamp: Date.now(),
        metadata: {
          userId,
          dataSize: parseInt(response.headers.get('content-length') || '0'),
          cacheHit: response.headers.get('x-cache') === 'HIT',
        },
      });

      return response;
    } catch (error) {
      loadingMetricsService.record({
        endpoint: new URL(req.url).pathname,
        method: req.method,
        duration: Date.now() - startTime,
        status: 'error',
        timestamp: Date.now(),
        metadata: { userId },
      });

      throw error;
    }
  };
}

// ============================================
// 10.9.4 ë¡œë”© ëŒ€ì‹œë³´ë“œ API
// ============================================

// GET /api/admin/loading-metrics
export async function GET(req: NextRequest) {
  const { isAdmin } = await validateAdminSession(req);
  if (!isAdmin) {
    return NextResponse.json(
      { error: { code: 'FORBIDDEN', message: 'Admin access required' } },
      { status: 403 }
    );
  }

  const { searchParams } = new URL(req.url);
  const hours = parseInt(searchParams.get('hours') || '24');

  // ì§€ì • ì‹œê°„ ë‚´ ë©”íŠ¸ë¦­ ì¡°íšŒ
  const since = new Date(Date.now() - hours * 60 * 60 * 1000);

  const metrics = await prisma.loadingMetric.groupBy({
    by: ['endpoint', 'method'],
    where: {
      timestamp: { gte: since },
    },
    _avg: { duration: true },
    _count: true,
    _min: { duration: true },
    _max: { duration: true },
  });

  // ìƒíƒœë³„ í†µê³„
  const statusStats = await prisma.loadingMetric.groupBy({
    by: ['status'],
    where: {
      timestamp: { gte: since },
    },
    _count: true,
  });

  return NextResponse.json({
    success: true,
    data: {
      byEndpoint: metrics,
      byStatus: statusStats,
      targets: LOADING_METRICS_TARGETS,
      period: { hours, since },
    },
  });
}
```

### 10.10 Part 6.2: ì¥ê¸° ì‹¤í–‰ ì‘ì—… DB ìŠ¤í‚¤ë§ˆ

```prisma
// prisma/schema.prisma (ì¶”ê°€)

// ============================================
// 10.10.1 ì¥ê¸° ì‹¤í–‰ ì‘ì—… ëª¨ë¸
// ============================================

model LongRunningOperation {
  id          String   @id @default(uuid())
  type        String   // meeting_analysis, bulk_export, notion_sync ë“±
  userId      String
  status      String   @default("queued") // queued, processing, completed, failed, cancelled
  progress    Int      @default(0) // 0-100
  metadata    Json?    // ì‘ì—…ë³„ ì¶”ê°€ ë°ì´í„°
  result      Json?    // ì™„ë£Œ ì‹œ ê²°ê³¼
  error       Json?    // ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ì •ë³´
  createdAt   DateTime @default(now())
  startedAt   DateTime?
  completedAt DateTime?

  user        User     @relation(fields: [userId], references: [id])

  @@index([userId, status])
  @@index([createdAt])
  @@index([type, status])
}

// ============================================
// 10.10.2 ë¡œë”© ë©”íŠ¸ë¦­ ëª¨ë¸
// ============================================

model LoadingMetric {
  id          String   @id @default(uuid())
  endpoint    String
  method      String
  duration    Int      // ë°€ë¦¬ì´ˆ
  status      String   // success, error, cancelled, timeout
  timestamp   DateTime @default(now())
  userId      String?
  operationType String?
  dataSize    Int?     // bytes
  cacheHit    Boolean  @default(false)

  @@index([endpoint, timestamp])
  @@index([userId, timestamp])
  @@index([status, timestamp])
}

// ============================================
// 10.10.3 ë‚™ê´€ì  UI ë¡¤ë°± ì¶”ì  ëª¨ë¸
// ============================================

model OptimisticRollback {
  id          String   @id @default(uuid())
  userId      String
  action      String   // ì›ë˜ ì•¡ì…˜ (update_decision, confirm_action ë“±)
  entityType  String   // ì—”í‹°í‹° íƒ€ì… (decision, action, meeting ë“±)
  entityId    String   // ì—”í‹°í‹° ID
  originalData Json    // ë¡¤ë°±ëœ ì›ë³¸ ë°ì´í„°
  attemptedData Json   // ì‹œë„í–ˆë˜ ë°ì´í„°
  errorCode   String   // ì‹¤íŒ¨ ì‚¬ìœ 
  errorMessage String
  rolledBackAt DateTime @default(now())

  @@index([userId, rolledBackAt])
  @@index([entityType, entityId])
  @@index([errorCode])
}
```

### 10.11 Part 6.3: ë¹ˆ ìƒíƒœ ì½˜í…ì¸  API (Empty State Content)

```typescript
// src/app/api/empty-state/content/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { z } from 'zod';

// ============================================
// 10.11.1 ë¹ˆ ìƒíƒœ ì½˜í…ì¸  íƒ€ì… ì •ì˜
// ============================================

type EmptyStateReason =
  | 'first_time'         // ì²« ì‚¬ìš© - ë°ì´í„° ìƒì„± ì „
  | 'no_data'            // ì¡°ê±´ ë§Œì¡± ë°ì´í„° ì—†ìŒ
  | 'filtered_out'       // í•„í„°ë§ìœ¼ë¡œ ì¸í•œ ë¹ˆ ê²°ê³¼
  | 'search_no_match'    // ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ
  | 'completed_all'      // ëª¨ë“  í•­ëª© ì™„ë£Œ
  | 'temporal_gap'       // íŠ¹ì • ê¸°ê°„ì— ë°ì´í„° ì—†ìŒ
  | 'permission_limited' // ê¶Œí•œ ë¶€ì¡±ìœ¼ë¡œ ì ‘ê·¼ ë¶ˆê°€
  | 'feature_not_setup'; // ê¸°ëŠ¥ ë¯¸ì„¤ì •

type EmptyStateContext =
  | 'today_meetings'
  | 'past_meetings'
  | 'search_results'
  | 'decisions_list'
  | 'actions_list'
  | 'insights_list'
  | 'notifications'
  | 'integrations'
  | 'hud_idle'
  | 'filter_results';

type EmptyStateTone = 'neutral' | 'positive' | 'encouraging' | 'helpful';

interface EmptyStateAction {
  label: string;
  action: string; // navigate:/path, open:modal, reset:filters, oauth:provider
  variant: 'primary' | 'secondary' | 'text';
}

interface EmptyStateContent {
  context: EmptyStateContext;
  reason: EmptyStateReason;
  illustration: {
    type: 'icon' | 'illustration' | 'animation';
    asset: string;
    size: 'sm' | 'md' | 'lg';
  };
  title: string;
  description: string;
  tone: EmptyStateTone;
  actions: EmptyStateAction[];
  suggestions?: string[];
  metadata?: Record<string, unknown>;
}

// ============================================
// 10.11.2 ë¹ˆ ìƒíƒœ ì½˜í…ì¸  ë ˆì§€ìŠ¤íŠ¸ë¦¬
// ============================================

const EMPTY_STATE_REGISTRY: Record<string, EmptyStateContent> = {
  // Today í™”ë©´ - ì²« ì‚¬ìš©
  'today_meetings:first_time': {
    context: 'today_meetings',
    reason: 'first_time',
    illustration: { type: 'illustration', asset: 'welcome-calendar', size: 'lg' },
    title: 'Onnoì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!',
    description: 'ì²« ë¯¸íŒ…ì„ ì‹œì‘í•˜ë©´ AIê°€ ìë™ìœ¼ë¡œ ì¤‘ìš”í•œ ë‚´ìš©ì„ ì •ë¦¬í•´ë“œë¦½ë‹ˆë‹¤.',
    tone: 'encouraging',
    actions: [
      { label: 'ìº˜ë¦°ë” ì—°ê²°í•˜ê¸°', action: 'oauth:google', variant: 'primary' },
      { label: 'ì‚¬ìš©ë²• ì•Œì•„ë³´ê¸°', action: 'open:onboarding', variant: 'secondary' },
    ],
    suggestions: ['Google ìº˜ë¦°ë”', 'Outlook ì—°ë™', 'ìƒ˜í”Œ ë¯¸íŒ… ë³´ê¸°'],
  },

  // Today í™”ë©´ - ì˜¤ëŠ˜ ë¯¸íŒ… ì—†ìŒ
  'today_meetings:no_data': {
    context: 'today_meetings',
    reason: 'no_data',
    illustration: { type: 'illustration', asset: 'relax-coffee', size: 'md' },
    title: 'ì˜¤ëŠ˜ì€ ë¯¸íŒ…ì´ ì—†ìŠµë‹ˆë‹¤',
    description: 'ì—¬ìœ ë¡œìš´ í•˜ë£¨ ë³´ë‚´ì„¸ìš”! ê³¼ê±° ë¯¸íŒ… ê¸°ë¡ì„ í™•ì¸í•˜ê±°ë‚˜ ìƒˆ ë¯¸íŒ…ì„ ì¤€ë¹„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
    tone: 'positive',
    actions: [
      { label: 'ê³¼ê±° ë¯¸íŒ… ë³´ê¸°', action: 'navigate:/past', variant: 'primary' },
    ],
    suggestions: ['ì§€ë‚œì£¼ ë¯¸íŒ…', 'ì¤‘ìš” ê²°ì • ì‚¬í•­', 'ë¯¸ì™„ë£Œ ì•¡ì…˜'],
  },

  // ê²€ìƒ‰ - ì´ˆê¸° ìƒíƒœ
  'search_results:first_time': {
    context: 'search_results',
    reason: 'first_time',
    illustration: { type: 'icon', asset: 'search', size: 'md' },
    title: 'ë¯¸íŒ… ê¸°ë¡ì„ ê²€ìƒ‰í•´ë³´ì„¸ìš”',
    description: '"ê¹€ì² ìˆ˜ ì–¸ê¸‰í•œ ì˜ˆì‚° ë…¼ì˜" ê°™ì´ ìì—°ìŠ¤ëŸ¬ìš´ ë¬¸ì¥ìœ¼ë¡œ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
    tone: 'helpful',
    actions: [],
    suggestions: ['ì§€ë‚œ ë¶„ê¸° ë§¤ì¶œ', 'ê¹€ì² ìˆ˜ ì–¸ê¸‰í•œ ë‚´ìš©', 'Q4 ëª©í‘œ'],
  },

  // ê²€ìƒ‰ - ê²°ê³¼ ì—†ìŒ
  'search_results:search_no_match': {
    context: 'search_results',
    reason: 'search_no_match',
    illustration: { type: 'illustration', asset: 'no-results', size: 'md' },
    title: 'ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤',
    description: 'ë‹¤ë¥¸ í‚¤ì›Œë“œë¡œ ê²€ìƒ‰í•´ë³´ì‹œê±°ë‚˜, í•„í„°ë¥¼ ì¡°ì •í•´ë³´ì„¸ìš”.',
    tone: 'neutral',
    actions: [
      { label: 'í•„í„° ì´ˆê¸°í™”', action: 'reset:filters', variant: 'secondary' },
    ],
    suggestions: ['ë” ë„“ì€ ê¸°ê°„', 'ìœ ì‚¬ í‚¤ì›Œë“œ', 'í•„í„° í•´ì œ'],
  },

  // í•„í„° ê²°ê³¼ ì—†ìŒ
  'filter_results:filtered_out': {
    context: 'filter_results',
    reason: 'filtered_out',
    illustration: { type: 'icon', asset: 'filter-x', size: 'sm' },
    title: 'í•„í„° ì¡°ê±´ì— ë§ëŠ” ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤',
    description: 'í•„í„° ì¡°ê±´ì„ ë³€ê²½í•˜ê±°ë‚˜ ì´ˆê¸°í™”í•´ë³´ì„¸ìš”.',
    tone: 'neutral',
    actions: [
      { label: 'í•„í„° ì´ˆê¸°í™”', action: 'reset:filters', variant: 'primary' },
    ],
  },

  // ê²°ì • ì‚¬í•­ - ì—†ìŒ
  'decisions_list:no_data': {
    context: 'decisions_list',
    reason: 'no_data',
    illustration: { type: 'icon', asset: 'clipboard-check', size: 'sm' },
    title: 'ì´ ë¯¸íŒ…ì—ì„œ ë„ì¶œëœ ê²°ì • ì‚¬í•­ì´ ì—†ìŠµë‹ˆë‹¤',
    description: 'AIê°€ ëª…í™•í•œ ê²°ì • ì‚¬í•­ì„ ê°ì§€í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.',
    tone: 'neutral',
    actions: [],
  },

  // ì•¡ì…˜ ì•„ì´í…œ - ëª¨ë‘ ì™„ë£Œ
  'actions_list:completed_all': {
    context: 'actions_list',
    reason: 'completed_all',
    illustration: { type: 'illustration', asset: 'celebration', size: 'md' },
    title: 'ëª¨ë“  ì•¡ì…˜ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤! ğŸ‰',
    description: 'í›Œë¥­í•´ìš”! ëª¨ë“  í•  ì¼ì„ ë§ˆì³¤ìŠµë‹ˆë‹¤.',
    tone: 'positive',
    actions: [
      { label: 'ì™„ë£Œëœ í•­ëª© ë³´ê¸°', action: 'open:completed', variant: 'text' },
    ],
  },

  // í†µí•© ì„¤ì • - ì—°ê²°ëœ ì„œë¹„ìŠ¤ ì—†ìŒ
  'integrations:feature_not_setup': {
    context: 'integrations',
    reason: 'feature_not_setup',
    illustration: { type: 'illustration', asset: 'connect-services', size: 'lg' },
    title: 'ì„œë¹„ìŠ¤ë¥¼ ì—°ê²°í•´ë³´ì„¸ìš”',
    description: 'Notion, Salesforce ë“±ê³¼ ì—°ë™í•˜ë©´ ë¯¸íŒ… ê²°ê³¼ë¥¼ ìë™ìœ¼ë¡œ ì •ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
    tone: 'encouraging',
    actions: [
      { label: 'Notion ì—°ê²°', action: 'oauth:notion', variant: 'primary' },
      { label: 'Salesforce ì—°ê²°', action: 'oauth:salesforce', variant: 'secondary' },
    ],
  },

  // HUD - ëŒ€ê¸° ì¤‘
  'hud_idle:temporal_gap': {
    context: 'hud_idle',
    reason: 'temporal_gap',
    illustration: { type: 'animation', asset: 'waiting-pulse', size: 'sm' },
    title: 'ë¯¸íŒ… ëŒ€ê¸° ì¤‘',
    description: 'ëŒ€í™”ê°€ ê°ì§€ë˜ë©´ ìë™ìœ¼ë¡œ ë¶„ì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.',
    tone: 'neutral',
    actions: [],
  },

  // ì•Œë¦¼ - ì—†ìŒ
  'notifications:no_data': {
    context: 'notifications',
    reason: 'no_data',
    illustration: { type: 'icon', asset: 'bell-off', size: 'sm' },
    title: 'ìƒˆë¡œìš´ ì•Œë¦¼ì´ ì—†ìŠµë‹ˆë‹¤',
    description: 'ëª¨ë“  ì•Œë¦¼ì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤.',
    tone: 'neutral',
    actions: [],
  },
};

// ============================================
// 10.11.3 ë¹ˆ ìƒíƒœ ì½˜í…ì¸  ìš”ì²­ ìŠ¤í‚¤ë§ˆ
// ============================================

const getContentSchema = z.object({
  context: z.enum([
    'today_meetings', 'past_meetings', 'search_results',
    'decisions_list', 'actions_list', 'insights_list',
    'notifications', 'integrations', 'hud_idle', 'filter_results',
  ]),
  reason: z.enum([
    'first_time', 'no_data', 'filtered_out', 'search_no_match',
    'completed_all', 'temporal_gap', 'permission_limited', 'feature_not_setup',
  ]),
  locale: z.string().default('ko'),
  metadata: z.record(z.unknown()).optional(),
});

// ============================================
// 10.11.4 ë¹ˆ ìƒíƒœ ì½˜í…ì¸  API ì—”ë“œí¬ì¸íŠ¸
// ============================================

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const context = searchParams.get('context');
  const reason = searchParams.get('reason');

  const parsed = getContentSchema.safeParse({
    context,
    reason,
    locale: searchParams.get('locale') || 'ko',
  });

  if (!parsed.success) {
    return NextResponse.json(
      { error: 'Invalid parameters', details: parsed.error.errors },
      { status: 400 }
    );
  }

  const key = `${parsed.data.context}:${parsed.data.reason}`;
  const content = EMPTY_STATE_REGISTRY[key];

  if (!content) {
    // ê¸°ë³¸ ë¹ˆ ìƒíƒœ ì½˜í…ì¸  ë°˜í™˜
    return NextResponse.json({
      success: true,
      data: {
        context: parsed.data.context,
        reason: parsed.data.reason,
        illustration: { type: 'icon', asset: 'inbox', size: 'md' },
        title: 'í‘œì‹œí•  ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤',
        description: 'ì¡°ê±´ì— ë§ëŠ” ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.',
        tone: 'neutral' as EmptyStateTone,
        actions: [],
      },
    });
  }

  return NextResponse.json({
    success: true,
    data: content,
  });
}

// ============================================
// 10.11.5 ë¹ˆ ìƒíƒœ ì½˜í…ì¸  ë²Œí¬ ì¡°íšŒ
// ============================================

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const body = await request.json();
  const contexts = z.array(z.object({
    context: z.string(),
    reason: z.string(),
  })).safeParse(body.contexts);

  if (!contexts.success) {
    return NextResponse.json(
      { error: 'Invalid request body' },
      { status: 400 }
    );
  }

  const results: Record<string, EmptyStateContent | null> = {};

  for (const item of contexts.data) {
    const key = `${item.context}:${item.reason}`;
    results[key] = EMPTY_STATE_REGISTRY[key] || null;
  }

  return NextResponse.json({
    success: true,
    data: results,
  });
}
```

### 10.12 Part 6.3: ì²« ì‚¬ìš©ì ê°ì§€ ì„œë¹„ìŠ¤ (First-Time User Detection)

```typescript
// src/services/first-time-user.service.ts

import { prisma } from '@/lib/prisma';
import { redis } from '@/lib/redis';

// ============================================
// 10.12.1 ì²« ì‚¬ìš©ì ìƒíƒœ íƒ€ì…
// ============================================

interface FirstTimeStatus {
  isFirstTime: boolean;
  hasCompletedOnboarding: boolean;
  hasConnectedCalendar: boolean;
  hasFirstMeeting: boolean;
  hasFirstDecision: boolean;
  hasConnectedIntegration: boolean;
  onboardingProgress: number; // 0-100
  createdAt: Date;
  lastActivityAt: Date | null;
}

interface FirstTimeCheckResult {
  context: string;
  isFirstTime: boolean;
  reason: string;
  suggestedContent?: {
    title: string;
    description: string;
    action: string;
  };
}

// ============================================
// 10.12.2 ìºì‹œ í‚¤ ìƒì„±
// ============================================

function getFirstTimeStatusCacheKey(userId: string): string {
  return `first_time_status:${userId}`;
}

// ============================================
// 10.12.3 ì²« ì‚¬ìš©ì ìƒíƒœ ì¡°íšŒ í•¨ìˆ˜
// ============================================

export async function getFirstTimeStatus(userId: string): Promise<FirstTimeStatus> {
  // ìºì‹œ í™•ì¸
  const cacheKey = getFirstTimeStatusCacheKey(userId);
  const cached = await redis.get(cacheKey);

  if (cached) {
    return JSON.parse(cached);
  }

  // ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      _count: {
        select: {
          meetings: true,
          decisions: true,
          integrations: true,
        },
      },
      onboarding: true,
      integrations: {
        where: { type: 'GOOGLE_CALENDAR' },
        take: 1,
      },
    },
  });

  if (!user) {
    throw new Error('User not found');
  }

  const status: FirstTimeStatus = {
    isFirstTime: user._count.meetings === 0,
    hasCompletedOnboarding: user.onboarding?.completed || false,
    hasConnectedCalendar: user.integrations.length > 0,
    hasFirstMeeting: user._count.meetings > 0,
    hasFirstDecision: user._count.decisions > 0,
    hasConnectedIntegration: (await prisma.integration.count({
      where: { userId, type: { in: ['NOTION', 'SALESFORCE', 'SLACK'] } },
    })) > 0,
    onboardingProgress: calculateOnboardingProgress(user),
    createdAt: user.createdAt,
    lastActivityAt: user.lastActivityAt,
  };

  // ìºì‹œì— ì €ì¥ (5ë¶„)
  await redis.set(cacheKey, JSON.stringify(status), 'EX', 300);

  return status;
}

// ============================================
// 10.12.4 ì˜¨ë³´ë”© ì§„í–‰ë¥  ê³„ì‚°
// ============================================

function calculateOnboardingProgress(user: any): number {
  let progress = 0;
  const steps = [
    { check: user.onboarding?.profileCompleted, weight: 20 },
    { check: user.integrations?.length > 0, weight: 25 },
    { check: user._count.meetings > 0, weight: 25 },
    { check: user._count.decisions > 0, weight: 15 },
    { check: user.onboarding?.tutorialCompleted, weight: 15 },
  ];

  for (const step of steps) {
    if (step.check) {
      progress += step.weight;
    }
  }

  return progress;
}

// ============================================
// 10.12.5 ì»¨í…ìŠ¤íŠ¸ë³„ ì²« ì‚¬ìš©ì í™•ì¸
// ============================================

export async function checkFirstTimeForContext(
  userId: string,
  context: string
): Promise<FirstTimeCheckResult> {
  const status = await getFirstTimeStatus(userId);

  const contextChecks: Record<string, () => FirstTimeCheckResult> = {
    today_meetings: () => {
      if (!status.hasConnectedCalendar) {
        return {
          context,
          isFirstTime: true,
          reason: 'no_calendar_connected',
          suggestedContent: {
            title: 'ìº˜ë¦°ë”ë¥¼ ì—°ê²°í•´ì£¼ì„¸ìš”',
            description: 'Google ìº˜ë¦°ë”ë¥¼ ì—°ê²°í•˜ë©´ ë¯¸íŒ…ì´ ìë™ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤.',
            action: 'oauth:google',
          },
        };
      }
      if (!status.hasFirstMeeting) {
        return {
          context,
          isFirstTime: true,
          reason: 'no_meetings_yet',
          suggestedContent: {
            title: 'ì²« ë¯¸íŒ…ì„ ì‹œì‘í•´ë³´ì„¸ìš”',
            description: 'ë¯¸íŒ…ì„ ì‹œì‘í•˜ë©´ AIê°€ ìë™ìœ¼ë¡œ ë‚´ìš©ì„ ì •ë¦¬í•©ë‹ˆë‹¤.',
            action: 'open:tutorial',
          },
        };
      }
      return { context, isFirstTime: false, reason: 'has_data' };
    },

    search_results: () => {
      if (!status.hasFirstMeeting) {
        return {
          context,
          isFirstTime: true,
          reason: 'no_meetings_to_search',
          suggestedContent: {
            title: 'ê²€ìƒ‰í•  ë¯¸íŒ…ì´ ì—†ìŠµë‹ˆë‹¤',
            description: 'ë¯¸íŒ…ì„ ì§„í–‰í•˜ë©´ ì—¬ê¸°ì„œ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
            action: 'navigate:/',
          },
        };
      }
      return { context, isFirstTime: false, reason: 'has_searchable_data' };
    },

    integrations: () => {
      if (!status.hasConnectedIntegration) {
        return {
          context,
          isFirstTime: true,
          reason: 'no_integrations',
          suggestedContent: {
            title: 'ì„œë¹„ìŠ¤ë¥¼ ì—°ê²°í•´ë³´ì„¸ìš”',
            description: 'Notion, Salesforceì™€ ì—°ë™í•˜ì—¬ ìƒì‚°ì„±ì„ ë†’ì´ì„¸ìš”.',
            action: 'navigate:/settings/integrations',
          },
        };
      }
      return { context, isFirstTime: false, reason: 'has_integrations' };
    },

    hud: () => ({
      context,
      isFirstTime: !status.hasFirstMeeting,
      reason: status.hasFirstMeeting ? 'experienced_user' : 'first_hud_use',
    }),
  };

  const checker = contextChecks[context];
  if (!checker) {
    return { context, isFirstTime: false, reason: 'unknown_context' };
  }

  return checker();
}

// ============================================
// 10.12.6 ì²« ì‚¬ìš©ì ìƒíƒœ ë¬´íš¨í™” (ìºì‹œ)
// ============================================

export async function invalidateFirstTimeStatus(userId: string): Promise<void> {
  const cacheKey = getFirstTimeStatusCacheKey(userId);
  await redis.del(cacheKey);
}
```

```typescript
// src/app/api/user/first-time-status/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import {
  getFirstTimeStatus,
  checkFirstTimeForContext,
} from '@/services/first-time-user.service';

// ============================================
// 10.12.7 ì²« ì‚¬ìš©ì ìƒíƒœ API
// ============================================

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const context = searchParams.get('context');

  if (context) {
    // íŠ¹ì • ì»¨í…ìŠ¤íŠ¸ì— ëŒ€í•œ ì²« ì‚¬ìš©ì í™•ì¸
    const result = await checkFirstTimeForContext(session.user.id, context);
    return NextResponse.json({ success: true, data: result });
  }

  // ì „ì²´ ì²« ì‚¬ìš©ì ìƒíƒœ ì¡°íšŒ
  const status = await getFirstTimeStatus(session.user.id);
  return NextResponse.json({ success: true, data: status });
}
```

### 10.13 Part 6.3: ë¹ˆ ìƒíƒœ Analytics API

```typescript
// src/app/api/analytics/empty-state/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { z } from 'zod';

// ============================================
// 10.13.1 ë¹ˆ ìƒíƒœ ì´ë²¤íŠ¸ íƒ€ì…
// ============================================

type EmptyStateEventType =
  | 'empty_state_shown'
  | 'empty_state_cta_clicked'
  | 'empty_state_dismissed'
  | 'empty_state_navigated'
  | 'empty_state_bounced'
  | 'first_time_onboarding_started'
  | 'first_time_onboarding_completed'
  | 'search_suggestion_clicked'
  | 'filter_reset_clicked';

// ============================================
// 10.13.2 ì´ë²¤íŠ¸ ë¡œê¹… ìŠ¤í‚¤ë§ˆ
// ============================================

const emptyStateEventSchema = z.object({
  eventType: z.enum([
    'empty_state_shown',
    'empty_state_cta_clicked',
    'empty_state_dismissed',
    'empty_state_navigated',
    'empty_state_bounced',
    'first_time_onboarding_started',
    'first_time_onboarding_completed',
    'search_suggestion_clicked',
    'filter_reset_clicked',
  ]),
  context: z.string(),
  reason: z.string(),
  action: z.string().optional(),
  metadata: z.record(z.unknown()).optional(),
  sessionId: z.string().optional(),
  dwellTimeMs: z.number().optional(),
});

// ============================================
// 10.13.3 ë¹ˆ ìƒíƒœ ì´ë²¤íŠ¸ ë¡œê¹… API
// ============================================

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const body = await request.json();
  const parsed = emptyStateEventSchema.safeParse(body);

  if (!parsed.success) {
    return NextResponse.json(
      { error: 'Invalid event data', details: parsed.error.errors },
      { status: 400 }
    );
  }

  const event = await prisma.emptyStateEvent.create({
    data: {
      userId: session.user.id,
      eventType: parsed.data.eventType,
      context: parsed.data.context,
      reason: parsed.data.reason,
      action: parsed.data.action,
      metadata: parsed.data.metadata || {},
      sessionId: parsed.data.sessionId,
      dwellTimeMs: parsed.data.dwellTimeMs,
    },
  });

  return NextResponse.json({ success: true, data: { id: event.id } });
}

// ============================================
// 10.13.4 ë¹ˆ ìƒíƒœ ë©”íŠ¸ë¦­ ì¡°íšŒ API
// ============================================

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const hours = parseInt(searchParams.get('hours') || '24', 10);
  const context = searchParams.get('context');

  const since = new Date(Date.now() - hours * 60 * 60 * 1000);

  // ì»¨í…ìŠ¤íŠ¸ë³„ í†µê³„
  const contextStats = await prisma.emptyStateEvent.groupBy({
    by: ['context', 'eventType'],
    where: {
      timestamp: { gte: since },
      ...(context ? { context } : {}),
    },
    _count: true,
  });

  // CTA í´ë¦­ë¥  ê³„ì‚°
  const shownEvents = await prisma.emptyStateEvent.count({
    where: {
      eventType: 'empty_state_shown',
      timestamp: { gte: since },
      ...(context ? { context } : {}),
    },
  });

  const ctaClickedEvents = await prisma.emptyStateEvent.count({
    where: {
      eventType: 'empty_state_cta_clicked',
      timestamp: { gte: since },
      ...(context ? { context } : {}),
    },
  });

  const bouncedEvents = await prisma.emptyStateEvent.count({
    where: {
      eventType: 'empty_state_bounced',
      timestamp: { gte: since },
      ...(context ? { context } : {}),
    },
  });

  const navigatedEvents = await prisma.emptyStateEvent.count({
    where: {
      eventType: 'empty_state_navigated',
      timestamp: { gte: since },
      ...(context ? { context } : {}),
    },
  });

  // í‰ê·  ì²´ë¥˜ ì‹œê°„
  const avgDwellTime = await prisma.emptyStateEvent.aggregate({
    where: {
      eventType: 'empty_state_dismissed',
      timestamp: { gte: since },
      dwellTimeMs: { not: null },
      ...(context ? { context } : {}),
    },
    _avg: { dwellTimeMs: true },
  });

  // ì˜¨ë³´ë”© ì™„ë£Œìœ¨
  const onboardingStarted = await prisma.emptyStateEvent.count({
    where: {
      eventType: 'first_time_onboarding_started',
      timestamp: { gte: since },
    },
  });

  const onboardingCompleted = await prisma.emptyStateEvent.count({
    where: {
      eventType: 'first_time_onboarding_completed',
      timestamp: { gte: since },
    },
  });

  // ë©”íŠ¸ë¦­ ê³„ì‚°
  const metrics = {
    conversionRate: shownEvents > 0 ? (ctaClickedEvents / shownEvents) * 100 : 0,
    bounceRate: shownEvents > 0 ? (bouncedEvents / shownEvents) * 100 : 0,
    explorationRate: shownEvents > 0 ? (navigatedEvents / shownEvents) * 100 : 0,
    averageDwellTimeMs: avgDwellTime._avg.dwellTimeMs || 0,
    onboardingCompletionRate: onboardingStarted > 0
      ? (onboardingCompleted / onboardingStarted) * 100
      : 0,
  };

  // ëª©í‘œ ëŒ€ë¹„ ì„±ê³¼
  const targets = {
    conversionRate: { target: 30, current: metrics.conversionRate, met: metrics.conversionRate >= 30 },
    bounceRate: { target: 20, current: metrics.bounceRate, met: metrics.bounceRate <= 20 },
    explorationRate: { target: 50, current: metrics.explorationRate, met: metrics.explorationRate >= 50 },
    onboardingCompletionRate: { target: 60, current: metrics.onboardingCompletionRate, met: metrics.onboardingCompletionRate >= 60 },
  };

  return NextResponse.json({
    success: true,
    data: {
      byContext: contextStats,
      metrics,
      targets,
      period: { hours, since },
      totals: {
        shown: shownEvents,
        ctaClicked: ctaClickedEvents,
        bounced: bouncedEvents,
        navigated: navigatedEvents,
      },
    },
  });
}
```

```typescript
// src/app/api/analytics/empty-state/by-context/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

// ============================================
// 10.13.5 ì»¨í…ìŠ¤íŠ¸ë³„ ë¹ˆ ìƒíƒœ ìƒì„¸ ë©”íŠ¸ë¦­
// ============================================

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const hours = parseInt(searchParams.get('hours') || '24', 10);
  const since = new Date(Date.now() - hours * 60 * 60 * 1000);

  // ì»¨í…ìŠ¤íŠ¸ë³„ ì´ë²¤íŠ¸ ì§‘ê³„
  const contexts = [
    'today_meetings', 'past_meetings', 'search_results',
    'decisions_list', 'actions_list', 'insights_list',
    'notifications', 'integrations', 'hud_idle', 'filter_results',
  ];

  const contextMetrics = await Promise.all(
    contexts.map(async (context) => {
      const [shown, ctaClicked, bounced, navigated] = await Promise.all([
        prisma.emptyStateEvent.count({
          where: { context, eventType: 'empty_state_shown', timestamp: { gte: since } },
        }),
        prisma.emptyStateEvent.count({
          where: { context, eventType: 'empty_state_cta_clicked', timestamp: { gte: since } },
        }),
        prisma.emptyStateEvent.count({
          where: { context, eventType: 'empty_state_bounced', timestamp: { gte: since } },
        }),
        prisma.emptyStateEvent.count({
          where: { context, eventType: 'empty_state_navigated', timestamp: { gte: since } },
        }),
      ]);

      return {
        context,
        shown,
        ctaClicked,
        bounced,
        navigated,
        conversionRate: shown > 0 ? ((ctaClicked / shown) * 100).toFixed(1) : '0.0',
        bounceRate: shown > 0 ? ((bounced / shown) * 100).toFixed(1) : '0.0',
      };
    })
  );

  // ì„±ê³¼ ìˆœìœ„
  const ranked = [...contextMetrics]
    .filter((m) => m.shown > 0)
    .sort((a, b) => parseFloat(b.conversionRate) - parseFloat(a.conversionRate));

  return NextResponse.json({
    success: true,
    data: {
      contexts: contextMetrics,
      topPerforming: ranked.slice(0, 3),
      needsImprovement: ranked.slice(-3).reverse(),
      period: { hours, since },
    },
  });
}
```

### 10.14 Part 6.3: ë¹ˆ ìƒíƒœ DB ìŠ¤í‚¤ë§ˆ

```prisma
// prisma/schema.prisma (ì¶”ê°€)

// ============================================
// 10.14.1 ë¹ˆ ìƒíƒœ ì´ë²¤íŠ¸ ëª¨ë¸
// ============================================

model EmptyStateEvent {
  id          String   @id @default(uuid())
  userId      String
  eventType   String   // empty_state_shown, cta_clicked, dismissed, navigated, bounced ë“±
  context     String   // today_meetings, search_results, decisions_list ë“±
  reason      String   // first_time, no_data, filtered_out, search_no_match ë“±
  action      String?  // í´ë¦­ëœ CTA ì•¡ì…˜ (navigate:/, oauth:google ë“±)
  metadata    Json?    // ì¶”ê°€ ë©”íƒ€ë°ì´í„°
  sessionId   String?  // ì„¸ì…˜ ID (ë™ì¼ ì„¸ì…˜ ì¶”ì ìš©)
  dwellTimeMs Int?     // ì²´ë¥˜ ì‹œê°„ (ë°€ë¦¬ì´ˆ)
  timestamp   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id])

  @@index([userId, timestamp])
  @@index([context, timestamp])
  @@index([eventType, timestamp])
  @@index([reason, timestamp])
  @@index([sessionId])
}

// ============================================
// 10.14.2 ì‚¬ìš©ì ì˜¨ë³´ë”© ìƒíƒœ ëª¨ë¸
// ============================================

model UserOnboarding {
  id                String   @id @default(uuid())
  userId            String   @unique
  completed         Boolean  @default(false)
  profileCompleted  Boolean  @default(false)
  tutorialCompleted Boolean  @default(false)
  calendarConnected Boolean  @default(false)
  firstMeetingDone  Boolean  @default(false)
  integrationsDone  Boolean  @default(false)
  progress          Int      @default(0) // 0-100
  startedAt         DateTime @default(now())
  completedAt       DateTime?
  skippedAt         DateTime?
  lastStepAt        DateTime?
  currentStep       String?  // í˜„ì¬ ì˜¨ë³´ë”© ë‹¨ê³„

  user              User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([completed])
}

// ============================================
// 10.14.3 ì²« ì‚¬ìš©ì ë§ˆì¼ìŠ¤í†¤ ëª¨ë¸
// ============================================

model FirstTimeMilestone {
  id          String   @id @default(uuid())
  userId      String
  milestone   String   // first_meeting, first_decision, first_integration ë“±
  achievedAt  DateTime @default(now())
  metadata    Json?    // ë§ˆì¼ìŠ¤í†¤ë³„ ì¶”ê°€ ì •ë³´

  user        User     @relation(fields: [userId], references: [id])

  @@unique([userId, milestone])
  @@index([userId])
  @@index([milestone])
}

// ============================================
// 10.14.4 ë¹ˆ ìƒíƒœ A/B í…ŒìŠ¤íŠ¸ ë°°ì • ëª¨ë¸
// ============================================

model EmptyStateExperiment {
  id            String   @id @default(uuid())
  userId        String
  experimentId  String   // ì‹¤í—˜ ID (empty_state_cta_v2 ë“±)
  variant       String   // control, variant_a, variant_b ë“±
  context       String   // ì ìš© ì»¨í…ìŠ¤íŠ¸
  assignedAt    DateTime @default(now())
  convertedAt   DateTime?
  converted     Boolean  @default(false)
  metadata      Json?

  user          User     @relation(fields: [userId], references: [id])

  @@unique([userId, experimentId, context])
  @@index([experimentId, variant])
  @@index([userId])
}
```

```typescript
// src/lib/empty-state-experiment.ts

import { prisma } from '@/lib/prisma';

// ============================================
// 10.14.5 A/B í…ŒìŠ¤íŠ¸ ë°°ì • ì„œë¹„ìŠ¤
// ============================================

interface ExperimentConfig {
  id: string;
  variants: string[];
  weights: number[]; // ê° variant ë¹„ìœ¨ (í•©ê³„ = 1)
  contexts: string[];
}

const ACTIVE_EXPERIMENTS: ExperimentConfig[] = [
  {
    id: 'empty_state_cta_style_v1',
    variants: ['control', 'variant_a', 'variant_b'],
    weights: [0.34, 0.33, 0.33],
    contexts: ['today_meetings', 'search_results', 'integrations'],
  },
  {
    id: 'empty_state_illustration_v1',
    variants: ['icon', 'illustration'],
    weights: [0.5, 0.5],
    contexts: ['today_meetings', 'integrations'],
  },
];

export async function getExperimentVariant(
  userId: string,
  experimentId: string,
  context: string
): Promise<string | null> {
  const config = ACTIVE_EXPERIMENTS.find((e) => e.id === experimentId);
  if (!config || !config.contexts.includes(context)) {
    return null;
  }

  // ê¸°ì¡´ ë°°ì • í™•ì¸
  const existing = await prisma.emptyStateExperiment.findUnique({
    where: {
      userId_experimentId_context: { userId, experimentId, context },
    },
  });

  if (existing) {
    return existing.variant;
  }

  // ìƒˆ ë°°ì • (ê°€ì¤‘ì¹˜ ê¸°ë°˜ ëœë¤)
  const random = Math.random();
  let cumulative = 0;
  let variant = config.variants[0];

  for (let i = 0; i < config.variants.length; i++) {
    cumulative += config.weights[i];
    if (random <= cumulative) {
      variant = config.variants[i];
      break;
    }
  }

  // ë°°ì • ì €ì¥
  await prisma.emptyStateExperiment.create({
    data: {
      userId,
      experimentId,
      variant,
      context,
    },
  });

  return variant;
}

export async function recordExperimentConversion(
  userId: string,
  experimentId: string,
  context: string
): Promise<void> {
  await prisma.emptyStateExperiment.updateMany({
    where: {
      userId,
      experimentId,
      context,
      converted: false,
    },
    data: {
      converted: true,
      convertedAt: new Date(),
    },
  });
}
```

---

### 10.15 Part 6.4: ì ‘ê·¼ì„± ì„¤ì • API (Accessibility Settings)

```typescript
// src/types/accessibility.ts

// 10.15.1 ì ‘ê·¼ì„± ì„¤ì • íƒ€ì… ì •ì˜
export type AccessibilityFeature =
  | 'screen_reader'
  | 'keyboard_nav'
  | 'focus_management'
  | 'color_contrast'
  | 'reduced_motion'
  | 'text_scaling'
  | 'high_contrast'
  | 'skip_link'
  | 'aria_live';

export interface AccessibilitySettings {
  id: string;
  userId: string;

  // ëª¨ì…˜ ì„¤ì •
  reduceMotion: boolean;
  reduceTransparency: boolean;

  // ì‹œê° ì„¤ì •
  highContrast: boolean;
  largeText: boolean;
  textScaleFactor: number; // 1.0 - 2.0

  // í¬ì»¤ìŠ¤ ì„¤ì •
  showFocusOutline: boolean;
  focusOutlineWidth: 'normal' | 'thick';

  // ìŠ¤í¬ë¦° ë¦¬ë” ì„¤ì •
  verboseMode: boolean;
  announceStatusChanges: boolean;

  // í‚¤ë³´ë“œ ì„¤ì •
  keyboardShortcutsEnabled: boolean;
  customShortcuts: Record<string, string>;
  stickyKeys: boolean;

  // ë©”íƒ€ë°ì´í„°
  createdAt: Date;
  updatedAt: Date;
}

// 10.15.2 í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì„¤ì • íƒ€ì…
export type ShortcutScope =
  | 'global'
  | 'today'
  | 'hud'
  | 'search'
  | 'modal'
  | 'settings';

export interface KeyboardShortcut {
  id: string;
  action: string;
  key: string;
  modifiers: ('ctrl' | 'alt' | 'shift' | 'meta')[];
  scope: ShortcutScope;
  description: string;
  isCustom: boolean;
  isEnabled: boolean;
}

export interface UserShortcutOverride {
  id: string;
  userId: string;
  shortcutId: string;
  customKey: string;
  customModifiers: string[];
  isEnabled: boolean;
  createdAt: Date;
}
```

```typescript
// src/app/api/accessibility/settings/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';
import { z } from 'zod';

// 10.15.3 ì ‘ê·¼ì„± ì„¤ì • ìŠ¤í‚¤ë§ˆ
const accessibilitySettingsSchema = z.object({
  reduceMotion: z.boolean().optional(),
  reduceTransparency: z.boolean().optional(),
  highContrast: z.boolean().optional(),
  largeText: z.boolean().optional(),
  textScaleFactor: z.number().min(1.0).max(2.0).optional(),
  showFocusOutline: z.boolean().optional(),
  focusOutlineWidth: z.enum(['normal', 'thick']).optional(),
  verboseMode: z.boolean().optional(),
  announceStatusChanges: z.boolean().optional(),
  keyboardShortcutsEnabled: z.boolean().optional(),
  customShortcuts: z.record(z.string()).optional(),
  stickyKeys: z.boolean().optional(),
});

// 10.15.4 ì ‘ê·¼ì„± ì„¤ì • ì¡°íšŒ API
export async function GET(req: NextRequest) {
  const session = await getServerSession();

  if (!session?.user?.id) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    let settings = await prisma.accessibilitySettings.findUnique({
      where: { userId: session.user.id },
    });

    // ì„¤ì •ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ìƒì„±
    if (!settings) {
      settings = await prisma.accessibilitySettings.create({
        data: {
          userId: session.user.id,
          reduceMotion: false,
          reduceTransparency: false,
          highContrast: false,
          largeText: false,
          textScaleFactor: 1.0,
          showFocusOutline: true,
          focusOutlineWidth: 'normal',
          verboseMode: false,
          announceStatusChanges: true,
          keyboardShortcutsEnabled: true,
          customShortcuts: {},
          stickyKeys: false,
        },
      });
    }

    return NextResponse.json({
      success: true,
      data: settings,
    });
  } catch (error) {
    console.error('Failed to fetch accessibility settings:', error);
    return NextResponse.json(
      { error: 'Failed to fetch settings' },
      { status: 500 }
    );
  }
}

// 10.15.5 ì ‘ê·¼ì„± ì„¤ì • ì—…ë°ì´íŠ¸ API
export async function PATCH(req: NextRequest) {
  const session = await getServerSession();

  if (!session?.user?.id) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const body = await req.json();
    const validated = accessibilitySettingsSchema.parse(body);

    const settings = await prisma.accessibilitySettings.upsert({
      where: { userId: session.user.id },
      update: {
        ...validated,
        updatedAt: new Date(),
      },
      create: {
        userId: session.user.id,
        reduceMotion: validated.reduceMotion ?? false,
        reduceTransparency: validated.reduceTransparency ?? false,
        highContrast: validated.highContrast ?? false,
        largeText: validated.largeText ?? false,
        textScaleFactor: validated.textScaleFactor ?? 1.0,
        showFocusOutline: validated.showFocusOutline ?? true,
        focusOutlineWidth: validated.focusOutlineWidth ?? 'normal',
        verboseMode: validated.verboseMode ?? false,
        announceStatusChanges: validated.announceStatusChanges ?? true,
        keyboardShortcutsEnabled: validated.keyboardShortcutsEnabled ?? true,
        customShortcuts: validated.customShortcuts ?? {},
        stickyKeys: validated.stickyKeys ?? false,
      },
    });

    // ì ‘ê·¼ì„± ì„¤ì • ë³€ê²½ ì´ë²¤íŠ¸ ê¸°ë¡
    await prisma.accessibilityEvent.create({
      data: {
        userId: session.user.id,
        eventType: 'setting_changed',
        properties: {
          changedFields: Object.keys(validated),
          newValues: validated,
        },
      },
    });

    return NextResponse.json({
      success: true,
      data: settings,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }
    console.error('Failed to update accessibility settings:', error);
    return NextResponse.json(
      { error: 'Failed to update settings' },
      { status: 500 }
    );
  }
}
```

```typescript
// src/app/api/accessibility/shortcuts/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';

// 10.15.6 ê¸°ë³¸ í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì •ì˜
const DEFAULT_SHORTCUTS: KeyboardShortcut[] = [
  // Global
  { id: 'global_search', action: 'openSearch', key: 'k', modifiers: ['ctrl'], scope: 'global', description: 'ê²€ìƒ‰ ì—´ê¸°', isCustom: false, isEnabled: true },
  { id: 'global_home', action: 'goToToday', key: 'h', modifiers: ['ctrl', 'shift'], scope: 'global', description: 'Todayë¡œ ì´ë™', isCustom: false, isEnabled: true },
  { id: 'global_settings', action: 'openSettings', key: ',', modifiers: ['ctrl'], scope: 'global', description: 'ì„¤ì • ì—´ê¸°', isCustom: false, isEnabled: true },
  { id: 'global_help', action: 'showHelp', key: '?', modifiers: ['shift'], scope: 'global', description: 'ë„ì›€ë§', isCustom: false, isEnabled: true },

  // Today
  { id: 'today_next', action: 'nextCard', key: 'j', modifiers: [], scope: 'today', description: 'ë‹¤ìŒ ì¹´ë“œ', isCustom: false, isEnabled: true },
  { id: 'today_prev', action: 'prevCard', key: 'k', modifiers: [], scope: 'today', description: 'ì´ì „ ì¹´ë“œ', isCustom: false, isEnabled: true },
  { id: 'today_enter', action: 'enterMeeting', key: 'Enter', modifiers: [], scope: 'today', description: 'ë¯¸íŒ… ì…ì¥', isCustom: false, isEnabled: true },
  { id: 'today_refresh', action: 'refreshCards', key: 'r', modifiers: [], scope: 'today', description: 'ìƒˆë¡œê³ ì¹¨', isCustom: false, isEnabled: true },

  // HUD
  { id: 'hud_toggle', action: 'toggleHUD', key: 'Escape', modifiers: [], scope: 'hud', description: 'HUD ìµœì†Œí™”', isCustom: false, isEnabled: true },
  { id: 'hud_save', action: 'saveNote', key: 's', modifiers: ['ctrl'], scope: 'hud', description: 'ë…¸íŠ¸ ì €ì¥', isCustom: false, isEnabled: true },
  { id: 'hud_capture', action: 'captureDecision', key: 'd', modifiers: ['ctrl'], scope: 'hud', description: 'ê²°ì • ìº¡ì²˜', isCustom: false, isEnabled: true },
  { id: 'hud_navigate', action: 'navigateSections', key: 'Tab', modifiers: [], scope: 'hud', description: 'ì„¹ì…˜ ì´ë™', isCustom: false, isEnabled: true },

  // Search
  { id: 'search_close', action: 'closeSearch', key: 'Escape', modifiers: [], scope: 'search', description: 'ê²€ìƒ‰ ë‹«ê¸°', isCustom: false, isEnabled: true },
  { id: 'search_next', action: 'nextResult', key: 'ArrowDown', modifiers: [], scope: 'search', description: 'ë‹¤ìŒ ê²°ê³¼', isCustom: false, isEnabled: true },
  { id: 'search_prev', action: 'prevResult', key: 'ArrowUp', modifiers: [], scope: 'search', description: 'ì´ì „ ê²°ê³¼', isCustom: false, isEnabled: true },
  { id: 'search_select', action: 'selectResult', key: 'Enter', modifiers: [], scope: 'search', description: 'ê²°ê³¼ ì„ íƒ', isCustom: false, isEnabled: true },

  // Modal
  { id: 'modal_close', action: 'closeModal', key: 'Escape', modifiers: [], scope: 'modal', description: 'ëª¨ë‹¬ ë‹«ê¸°', isCustom: false, isEnabled: true },
  { id: 'modal_confirm', action: 'confirmModal', key: 'Enter', modifiers: ['ctrl'], scope: 'modal', description: 'í™•ì¸', isCustom: false, isEnabled: true },
];

// 10.15.7 í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì¡°íšŒ API
export async function GET(req: NextRequest) {
  const session = await getServerSession();

  if (!session?.user?.id) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    // ì‚¬ìš©ì ì»¤ìŠ¤í…€ ë‹¨ì¶•í‚¤ ì˜¤ë²„ë¼ì´ë“œ ì¡°íšŒ
    const overrides = await prisma.userShortcutOverride.findMany({
      where: { userId: session.user.id },
    });

    const overrideMap = new Map(
      overrides.map(o => [o.shortcutId, o])
    );

    // ê¸°ë³¸ ë‹¨ì¶•í‚¤ì™€ ì˜¤ë²„ë¼ì´ë“œ ë³‘í•©
    const shortcuts = DEFAULT_SHORTCUTS.map(shortcut => {
      const override = overrideMap.get(shortcut.id);
      if (override) {
        return {
          ...shortcut,
          key: override.customKey || shortcut.key,
          modifiers: override.customModifiers || shortcut.modifiers,
          isEnabled: override.isEnabled,
          isCustom: true,
        };
      }
      return shortcut;
    });

    return NextResponse.json({
      success: true,
      data: {
        shortcuts,
        scopes: ['global', 'today', 'hud', 'search', 'modal', 'settings'],
      },
    });
  } catch (error) {
    console.error('Failed to fetch shortcuts:', error);
    return NextResponse.json(
      { error: 'Failed to fetch shortcuts' },
      { status: 500 }
    );
  }
}

// 10.15.8 í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì»¤ìŠ¤í„°ë§ˆì´ì¦ˆ API
export async function PUT(req: NextRequest) {
  const session = await getServerSession();

  if (!session?.user?.id) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const { shortcutId, customKey, customModifiers, isEnabled } = await req.json();

    // ë‹¨ì¶•í‚¤ ì¶©ëŒ ê²€ì‚¬
    const existingOverrides = await prisma.userShortcutOverride.findMany({
      where: { userId: session.user.id },
    });

    const conflicts = existingOverrides.filter(o =>
      o.shortcutId !== shortcutId &&
      o.customKey === customKey &&
      JSON.stringify(o.customModifiers) === JSON.stringify(customModifiers) &&
      o.isEnabled
    );

    if (conflicts.length > 0) {
      return NextResponse.json(
        {
          error: 'Shortcut conflict',
          conflictWith: conflicts[0].shortcutId
        },
        { status: 409 }
      );
    }

    const override = await prisma.userShortcutOverride.upsert({
      where: {
        userId_shortcutId: {
          userId: session.user.id,
          shortcutId,
        },
      },
      update: {
        customKey,
        customModifiers,
        isEnabled,
      },
      create: {
        userId: session.user.id,
        shortcutId,
        customKey,
        customModifiers,
        isEnabled,
      },
    });

    // ë‹¨ì¶•í‚¤ ë³€ê²½ ì´ë²¤íŠ¸ ê¸°ë¡
    await prisma.accessibilityEvent.create({
      data: {
        userId: session.user.id,
        eventType: 'shortcut_customized',
        properties: {
          shortcutId,
          customKey,
          customModifiers,
          isEnabled,
        },
      },
    });

    return NextResponse.json({
      success: true,
      data: override,
    });
  } catch (error) {
    console.error('Failed to update shortcut:', error);
    return NextResponse.json(
      { error: 'Failed to update shortcut' },
      { status: 500 }
    );
  }
}

// 10.15.9 ë‹¨ì¶•í‚¤ ì´ˆê¸°í™” API
export async function DELETE(req: NextRequest) {
  const session = await getServerSession();

  if (!session?.user?.id) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const { searchParams } = new URL(req.url);
    const shortcutId = searchParams.get('shortcutId');

    if (shortcutId) {
      // íŠ¹ì • ë‹¨ì¶•í‚¤ ì´ˆê¸°í™”
      await prisma.userShortcutOverride.delete({
        where: {
          userId_shortcutId: {
            userId: session.user.id,
            shortcutId,
          },
        },
      });
    } else {
      // ëª¨ë“  ë‹¨ì¶•í‚¤ ì´ˆê¸°í™”
      await prisma.userShortcutOverride.deleteMany({
        where: { userId: session.user.id },
      });
    }

    return NextResponse.json({
      success: true,
      message: shortcutId
        ? 'Shortcut reset to default'
        : 'All shortcuts reset to defaults',
    });
  } catch (error) {
    console.error('Failed to reset shortcuts:', error);
    return NextResponse.json(
      { error: 'Failed to reset shortcuts' },
      { status: 500 }
    );
  }
}
```

### 10.16 Part 6.4: ì ‘ê·¼ì„± Analytics API

```typescript
// src/types/accessibility-analytics.ts

// 10.16.1 ì ‘ê·¼ì„± ì´ë²¤íŠ¸ íƒ€ì…
export type AccessibilityEventType =
  | 'keyboard_shortcut_used'
  | 'screen_reader_detected'
  | 'focus_trap_entered'
  | 'focus_trap_exited'
  | 'skip_link_used'
  | 'setting_changed'
  | 'shortcut_customized'
  | 'reduced_motion_activated'
  | 'high_contrast_activated'
  | 'aria_live_announced'
  | 'text_scaling_changed'
  | 'focus_indicator_shown'
  | 'accessibility_issue_reported'
  | 'keyboard_navigation_pattern';

export interface AccessibilityEventProperties {
  // keyboard_shortcut_used
  shortcutKey?: string;
  modifiers?: string[];
  action?: string;
  scope?: string;
  success?: boolean;
  responseTimeMs?: number;

  // screen_reader_detected
  screenReaderType?: 'nvda' | 'jaws' | 'voiceover' | 'talkback' | 'unknown';
  detectionMethod?: 'aria-live' | 'focus-event' | 'user-agent' | 'manual';
  browserInfo?: string;

  // focus_trap
  trapContainerId?: string;
  trapType?: 'modal' | 'dropdown' | 'panel' | 'tooltip';
  timeInTrapMs?: number;
  tabCycleCount?: number;
  focusReturnedCorrectly?: boolean;

  // skip_link
  skipLinkType?: 'main' | 'nav' | 'search' | 'footer';
  targetId?: string;
  timeSavedMs?: number;

  // setting_changed
  changedFields?: string[];
  newValues?: Record<string, unknown>;
  previousValues?: Record<string, unknown>;

  // reduced_motion / high_contrast
  source?: 'user_preference' | 'system_preference';
  enabled?: boolean;

  // text_scaling
  scaleFactor?: number;
  previousScaleFactor?: number;

  // accessibility_issue
  issueType?: string;
  description?: string;
  affectedElement?: string;
  severity?: 'low' | 'medium' | 'high' | 'critical';

  // keyboard_navigation
  navigationPath?: string[];
  elementsVisited?: number;
  backtrackCount?: number;
  taskCompleted?: boolean;
  taskDurationMs?: number;

  // common
  screen?: string;
  component?: string;
}
```

```typescript
// src/app/api/accessibility/analytics/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';
import { z } from 'zod';

// 10.16.2 ì´ë²¤íŠ¸ ë¡œê¹… ìŠ¤í‚¤ë§ˆ
const accessibilityEventSchema = z.object({
  eventType: z.enum([
    'keyboard_shortcut_used',
    'screen_reader_detected',
    'focus_trap_entered',
    'focus_trap_exited',
    'skip_link_used',
    'setting_changed',
    'shortcut_customized',
    'reduced_motion_activated',
    'high_contrast_activated',
    'aria_live_announced',
    'text_scaling_changed',
    'focus_indicator_shown',
    'accessibility_issue_reported',
    'keyboard_navigation_pattern',
  ]),
  properties: z.record(z.unknown()),
  timestamp: z.string().datetime().optional(),
  sessionId: z.string().optional(),
});

// 10.16.3 ì ‘ê·¼ì„± ì´ë²¤íŠ¸ ë¡œê¹… API
export async function POST(req: NextRequest) {
  const session = await getServerSession();

  if (!session?.user?.id) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const body = await req.json();

    // ë°°ì¹˜ ì´ë²¤íŠ¸ ì§€ì›
    const events = Array.isArray(body) ? body : [body];
    const validatedEvents = events.map(e => accessibilityEventSchema.parse(e));

    const created = await prisma.accessibilityEvent.createMany({
      data: validatedEvents.map(event => ({
        userId: session.user.id,
        eventType: event.eventType,
        properties: event.properties,
        sessionId: event.sessionId,
        createdAt: event.timestamp ? new Date(event.timestamp) : new Date(),
      })),
    });

    return NextResponse.json({
      success: true,
      data: { count: created.count },
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }
    console.error('Failed to log accessibility event:', error);
    return NextResponse.json(
      { error: 'Failed to log event' },
      { status: 500 }
    );
  }
}

// 10.16.4 ì ‘ê·¼ì„± ë©”íŠ¸ë¦­ ì¡°íšŒ API
export async function GET(req: NextRequest) {
  const session = await getServerSession();

  if (!session?.user?.id) {
    // ê´€ë¦¬ìë§Œ ì „ì²´ í†µê³„ ì¡°íšŒ ê°€ëŠ¥
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const { searchParams } = new URL(req.url);
    const days = parseInt(searchParams.get('days') || '30');
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    // ì§‘ê³„ ì¿¼ë¦¬
    const [
      totalEvents,
      eventsByType,
      shortcutUsage,
      accessibilityFeatureUsage,
      screenReaderUsers,
      wcagIssues,
    ] = await Promise.all([
      // ì´ ì´ë²¤íŠ¸ ìˆ˜
      prisma.accessibilityEvent.count({
        where: { createdAt: { gte: startDate } },
      }),

      // ì´ë²¤íŠ¸ íƒ€ì…ë³„ ì§‘ê³„
      prisma.accessibilityEvent.groupBy({
        by: ['eventType'],
        where: { createdAt: { gte: startDate } },
        _count: true,
      }),

      // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì‚¬ìš© í†µê³„
      prisma.accessibilityEvent.findMany({
        where: {
          eventType: 'keyboard_shortcut_used',
          createdAt: { gte: startDate },
        },
        select: { properties: true },
      }),

      // ì ‘ê·¼ì„± ê¸°ëŠ¥ ì‚¬ìš©ì ìˆ˜
      prisma.accessibilitySettings.groupBy({
        by: ['reduceMotion', 'highContrast', 'largeText'],
        _count: true,
      }),

      // ìŠ¤í¬ë¦° ë¦¬ë” ì‚¬ìš©ì ìˆ˜
      prisma.accessibilityEvent.findMany({
        where: {
          eventType: 'screen_reader_detected',
          createdAt: { gte: startDate },
        },
        distinct: ['userId'],
      }),

      // ì ‘ê·¼ì„± ì´ìŠˆ ë¦¬í¬íŠ¸
      prisma.accessibilityEvent.findMany({
        where: {
          eventType: 'accessibility_issue_reported',
          createdAt: { gte: startDate },
        },
        select: { properties: true },
        orderBy: { createdAt: 'desc' },
        take: 50,
      }),
    ]);

    // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì‚¬ìš©ë¥  ê³„ì‚°
    const shortcutStats = shortcutUsage.reduce((acc, event) => {
      const props = event.properties as { action?: string; success?: boolean };
      const action = props.action || 'unknown';
      if (!acc[action]) {
        acc[action] = { total: 0, success: 0 };
      }
      acc[action].total++;
      if (props.success) acc[action].success++;
      return acc;
    }, {} as Record<string, { total: number; success: number }>);

    return NextResponse.json({
      success: true,
      data: {
        period: { days, startDate, endDate: new Date() },
        overview: {
          totalEvents,
          uniqueScreenReaderUsers: screenReaderUsers.length,
          wcagIssuesReported: wcagIssues.length,
        },
        eventsByType: eventsByType.map(e => ({
          type: e.eventType,
          count: e._count,
        })),
        shortcutUsage: Object.entries(shortcutStats).map(([action, stats]) => ({
          action,
          total: stats.total,
          successRate: stats.total > 0
            ? (stats.success / stats.total * 100).toFixed(1)
            : 0,
        })),
        accessibilityFeatureUsage: accessibilityFeatureUsage.map(g => ({
          reduceMotion: g.reduceMotion,
          highContrast: g.highContrast,
          largeText: g.largeText,
          count: g._count,
        })),
        recentIssues: wcagIssues.map(i => i.properties),
      },
    });
  } catch (error) {
    console.error('Failed to fetch accessibility metrics:', error);
    return NextResponse.json(
      { error: 'Failed to fetch metrics' },
      { status: 500 }
    );
  }
}
```

```typescript
// src/app/api/accessibility/audit/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';

// 10.16.5 ì ‘ê·¼ì„± ê°ì‚¬ ê²°ê³¼ ì €ì¥/ì¡°íšŒ API
interface AuditResult {
  id: string;
  url: string;
  wcagLevel: 'A' | 'AA' | 'AAA';
  timestamp: string;
  results: {
    violations: AuditViolation[];
    passes: number;
    incomplete: number;
    inapplicable: number;
  };
  score: number;
}

interface AuditViolation {
  id: string;
  impact: 'minor' | 'moderate' | 'serious' | 'critical';
  description: string;
  helpUrl: string;
  nodes: {
    html: string;
    target: string[];
    failureSummary: string;
  }[];
}

export async function POST(req: NextRequest) {
  const session = await getServerSession();

  if (!session?.user?.id) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const auditResult = await req.json() as AuditResult;

    const saved = await prisma.accessibilityAudit.create({
      data: {
        userId: session.user.id,
        url: auditResult.url,
        wcagLevel: auditResult.wcagLevel,
        score: auditResult.score,
        violationCount: auditResult.results.violations.length,
        passCount: auditResult.results.passes,
        incompleteCount: auditResult.results.incomplete,
        results: auditResult.results as object,
      },
    });

    // ì‹¬ê°í•œ ìœ„ë°˜ ì‚¬í•­ì€ ë³„ë„ ì•Œë¦¼
    const criticalViolations = auditResult.results.violations.filter(
      v => v.impact === 'critical'
    );

    if (criticalViolations.length > 0) {
      await prisma.accessibilityEvent.create({
        data: {
          userId: session.user.id,
          eventType: 'accessibility_issue_reported',
          properties: {
            source: 'automated_audit',
            url: auditResult.url,
            criticalViolationCount: criticalViolations.length,
            violations: criticalViolations.map(v => ({
              id: v.id,
              description: v.description,
              nodeCount: v.nodes.length,
            })),
          },
        },
      });
    }

    return NextResponse.json({
      success: true,
      data: {
        id: saved.id,
        score: saved.score,
        violationCount: saved.violationCount,
        criticalViolations: criticalViolations.length,
      },
    });
  } catch (error) {
    console.error('Failed to save audit result:', error);
    return NextResponse.json(
      { error: 'Failed to save audit' },
      { status: 500 }
    );
  }
}

export async function GET(req: NextRequest) {
  const session = await getServerSession();

  if (!session?.user?.id) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const { searchParams } = new URL(req.url);
    const limit = parseInt(searchParams.get('limit') || '10');
    const url = searchParams.get('url');

    const audits = await prisma.accessibilityAudit.findMany({
      where: {
        ...(url && { url }),
      },
      orderBy: { createdAt: 'desc' },
      take: limit,
      select: {
        id: true,
        url: true,
        wcagLevel: true,
        score: true,
        violationCount: true,
        passCount: true,
        incompleteCount: true,
        createdAt: true,
      },
    });

    // ìŠ¤ì½”ì–´ íŠ¸ë Œë“œ ê³„ì‚°
    const scoreHistory = await prisma.accessibilityAudit.groupBy({
      by: ['createdAt'],
      _avg: { score: true },
      orderBy: { createdAt: 'asc' },
      take: 30,
    });

    return NextResponse.json({
      success: true,
      data: {
        audits,
        trend: scoreHistory.map(h => ({
          date: h.createdAt,
          avgScore: h._avg.score,
        })),
        summary: {
          latestScore: audits[0]?.score || 0,
          totalAudits: audits.length,
          avgViolations: audits.reduce((sum, a) => sum + a.violationCount, 0) / audits.length || 0,
        },
      },
    });
  } catch (error) {
    console.error('Failed to fetch audits:', error);
    return NextResponse.json(
      { error: 'Failed to fetch audits' },
      { status: 500 }
    );
  }
}
```

### 10.17 Part 6.4: ì ‘ê·¼ì„± DB ìŠ¤í‚¤ë§ˆ

```prisma
// prisma/schema.prisma (Part 6.4 ì ‘ê·¼ì„± ì¶”ê°€)

// 10.17.1 ì ‘ê·¼ì„± ì„¤ì • ëª¨ë¸
model AccessibilitySettings {
  id                      String   @id @default(cuid())
  userId                  String   @unique
  user                    User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // ëª¨ì…˜ ì„¤ì •
  reduceMotion            Boolean  @default(false)
  reduceTransparency      Boolean  @default(false)

  // ì‹œê° ì„¤ì •
  highContrast            Boolean  @default(false)
  largeText               Boolean  @default(false)
  textScaleFactor         Float    @default(1.0)

  // í¬ì»¤ìŠ¤ ì„¤ì •
  showFocusOutline        Boolean  @default(true)
  focusOutlineWidth       String   @default("normal") // normal | thick

  // ìŠ¤í¬ë¦° ë¦¬ë” ì„¤ì •
  verboseMode             Boolean  @default(false)
  announceStatusChanges   Boolean  @default(true)

  // í‚¤ë³´ë“œ ì„¤ì •
  keyboardShortcutsEnabled Boolean @default(true)
  customShortcuts         Json     @default("{}")
  stickyKeys              Boolean  @default(false)

  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  @@map("accessibility_settings")
}

// 10.17.2 ì‚¬ìš©ì ë‹¨ì¶•í‚¤ ì˜¤ë²„ë¼ì´ë“œ ëª¨ë¸
model UserShortcutOverride {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  shortcutId      String
  customKey       String?
  customModifiers Json     @default("[]")
  isEnabled       Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId, shortcutId])
  @@index([userId])
  @@map("user_shortcut_overrides")
}

// 10.17.3 ì ‘ê·¼ì„± ì´ë²¤íŠ¸ ëª¨ë¸
model AccessibilityEvent {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventType  String
  properties Json     @default("{}")
  sessionId  String?
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([eventType])
  @@index([createdAt])
  @@index([sessionId])
  @@map("accessibility_events")
}

// 10.17.4 ì ‘ê·¼ì„± ê°ì‚¬ ê²°ê³¼ ëª¨ë¸
model AccessibilityAudit {
  id              String   @id @default(cuid())
  userId          String?
  user            User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  url             String
  wcagLevel       String   @default("AA") // A | AA | AAA
  score           Float
  violationCount  Int
  passCount       Int
  incompleteCount Int
  results         Json
  createdAt       DateTime @default(now())

  @@index([url])
  @@index([createdAt])
  @@index([score])
  @@map("accessibility_audits")
}

// 10.17.5 ìŠ¤í¬ë¦° ë¦¬ë” ì„¸ì…˜ ëª¨ë¸
model ScreenReaderSession {
  id               String   @id @default(cuid())
  userId           String
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  screenReaderType String   // nvda | jaws | voiceover | talkback | unknown
  browserInfo      String?
  startedAt        DateTime @default(now())
  endedAt          DateTime?
  pagesVisited     Int      @default(0)
  ariaAnnouncements Int     @default(0)
  focusEvents      Int      @default(0)

  @@index([userId])
  @@index([screenReaderType])
  @@index([startedAt])
  @@map("screen_reader_sessions")
}
```

```typescript
// src/services/accessibility-service.ts

import { prisma } from '@/lib/prisma';

// 10.17.6 ì ‘ê·¼ì„± ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
export class AccessibilityService {
  // ì‚¬ìš©ì ì ‘ê·¼ì„± í”„ë¡œí•„ ì¡°íšŒ
  async getUserAccessibilityProfile(userId: string) {
    const [settings, shortcuts, recentEvents] = await Promise.all([
      prisma.accessibilitySettings.findUnique({
        where: { userId },
      }),
      prisma.userShortcutOverride.findMany({
        where: { userId },
      }),
      prisma.accessibilityEvent.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
        take: 100,
      }),
    ]);

    // ìŠ¤í¬ë¦° ë¦¬ë” ì‚¬ìš© ì—¬ë¶€ ì¶”ë¡ 
    const screenReaderUsed = recentEvents.some(
      e => e.eventType === 'screen_reader_detected'
    );

    // í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ ì„ í˜¸ë„ ì¶”ë¡ 
    const keyboardEvents = recentEvents.filter(
      e => e.eventType === 'keyboard_shortcut_used' ||
           e.eventType === 'keyboard_navigation_pattern'
    );
    const keyboardPreferred = keyboardEvents.length > 20;

    return {
      settings,
      customShortcuts: shortcuts,
      inferred: {
        screenReaderUsed,
        keyboardPreferred,
        eventCount: recentEvents.length,
      },
    };
  }

  // ì ‘ê·¼ì„± í”¼ì²˜ ì‚¬ìš© í†µê³„
  async getFeatureUsageStats(days = 30) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const stats = await prisma.accessibilitySettings.aggregate({
      _count: true,
      _sum: {
        // Booleanì„ ìˆ«ìë¡œ ì§‘ê³„í•˜ê¸° ìœ„í•œ Raw ì¿¼ë¦¬ í•„ìš”
      },
    });

    // Raw ì¿¼ë¦¬ë¡œ ìƒì„¸ í†µê³„
    const featureStats = await prisma.$queryRaw<
      { feature: string; enabled_count: number; total: number }[]
    >`
      SELECT
        'reduceMotion' as feature,
        SUM(CASE WHEN "reduceMotion" = true THEN 1 ELSE 0 END) as enabled_count,
        COUNT(*) as total
      FROM accessibility_settings
      UNION ALL
      SELECT
        'highContrast',
        SUM(CASE WHEN "highContrast" = true THEN 1 ELSE 0 END),
        COUNT(*)
      FROM accessibility_settings
      UNION ALL
      SELECT
        'largeText',
        SUM(CASE WHEN "largeText" = true THEN 1 ELSE 0 END),
        COUNT(*)
      FROM accessibility_settings
      UNION ALL
      SELECT
        'keyboardShortcutsEnabled',
        SUM(CASE WHEN "keyboardShortcutsEnabled" = true THEN 1 ELSE 0 END),
        COUNT(*)
      FROM accessibility_settings
    `;

    return featureStats.map(f => ({
      feature: f.feature,
      enabledCount: Number(f.enabled_count),
      total: Number(f.total),
      percentage: f.total > 0
        ? ((Number(f.enabled_count) / Number(f.total)) * 100).toFixed(1)
        : 0,
    }));
  }

  // WCAG ì¤€ìˆ˜ìœ¨ ê³„ì‚°
  async calculateWCAGComplianceRate() {
    const recentAudits = await prisma.accessibilityAudit.findMany({
      orderBy: { createdAt: 'desc' },
      take: 10,
    });

    if (recentAudits.length === 0) {
      return { complianceRate: null, message: 'No audits available' };
    }

    const avgScore = recentAudits.reduce((sum, a) => sum + a.score, 0)
      / recentAudits.length;

    const avgViolations = recentAudits.reduce((sum, a) => sum + a.violationCount, 0)
      / recentAudits.length;

    return {
      complianceRate: avgScore.toFixed(1),
      avgViolationsPerPage: avgViolations.toFixed(1),
      auditCount: recentAudits.length,
      trend: this.calculateTrend(recentAudits.map(a => a.score)),
    };
  }

  private calculateTrend(scores: number[]): 'improving' | 'stable' | 'declining' {
    if (scores.length < 2) return 'stable';

    const firstHalf = scores.slice(0, Math.floor(scores.length / 2));
    const secondHalf = scores.slice(Math.floor(scores.length / 2));

    const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
    const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;

    const diff = secondAvg - firstAvg;

    if (diff > 2) return 'improving';
    if (diff < -2) return 'declining';
    return 'stable';
  }

  // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì‚¬ìš© ë¶„ì„
  async analyzeShortcutUsage(userId?: string, days = 30) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const events = await prisma.accessibilityEvent.findMany({
      where: {
        eventType: 'keyboard_shortcut_used',
        createdAt: { gte: startDate },
        ...(userId && { userId }),
      },
    });

    const actionStats: Record<string, {
      count: number;
      successCount: number;
      avgResponseTime: number;
      responseTimes: number[];
    }> = {};

    events.forEach(event => {
      const props = event.properties as {
        action?: string;
        success?: boolean;
        responseTimeMs?: number;
      };

      const action = props.action || 'unknown';

      if (!actionStats[action]) {
        actionStats[action] = {
          count: 0,
          successCount: 0,
          avgResponseTime: 0,
          responseTimes: [],
        };
      }

      actionStats[action].count++;
      if (props.success) actionStats[action].successCount++;
      if (props.responseTimeMs) {
        actionStats[action].responseTimes.push(props.responseTimeMs);
      }
    });

    // í‰ê·  ì‘ë‹µ ì‹œê°„ ê³„ì‚°
    Object.keys(actionStats).forEach(action => {
      const times = actionStats[action].responseTimes;
      actionStats[action].avgResponseTime = times.length > 0
        ? times.reduce((a, b) => a + b, 0) / times.length
        : 0;
      delete (actionStats[action] as any).responseTimes;
    });

    return {
      totalUsage: events.length,
      byAction: Object.entries(actionStats)
        .map(([action, stats]) => ({
          action,
          count: stats.count,
          successRate: stats.count > 0
            ? ((stats.successCount / stats.count) * 100).toFixed(1)
            : 0,
          avgResponseTimeMs: stats.avgResponseTime.toFixed(0),
        }))
        .sort((a, b) => b.count - a.count),
    };
  }
}

export const accessibilityService = new AccessibilityService();
```

---

## 11. ë³´ì•ˆ

### 11.1 ë°ì´í„° ì•”í˜¸í™”

```typescript
// src/lib/crypto.ts
import crypto from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const SECRET_KEY = Buffer.from(process.env.ENCRYPTION_KEY!, 'hex');

export function encrypt(text: string): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(ALGORITHM, SECRET_KEY, iv);

  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');

  const authTag = cipher.getAuthTag();

  return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
}

export function decrypt(encrypted: string): string {
  const [ivHex, authTagHex, encryptedText] = encrypted.split(':');

  const iv = Buffer.from(ivHex, 'hex');
  const authTag = Buffer.from(authTagHex, 'hex');

  const decipher = crypto.createDecipheriv(ALGORITHM, SECRET_KEY, iv);
  decipher.setAuthTag(authTag);

  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');

  return decrypted;
}
```

### 11.2 ì…ë ¥ ê²€ì¦ (Zod)

```typescript
// src/lib/validations.ts
import { z } from 'zod';

export const createMeetingSchema = z.object({
  title: z.string().min(1).max(200),
  company: z.string().optional(),
  platform: z.enum(['ZOOM', 'GOOGLE_MEET', 'TEAMS', 'OTHER']),
  startTime: z.coerce.date(),
  participants: z
    .array(
      z.object({
        name: z.string(),
        email: z.string().email().optional(),
        role: z.string().optional(),
      })
    )
    .optional(),
});

// API Routeì—ì„œ ì‚¬ìš©
export async function POST(req: NextRequest) {
  const body = await req.json();

  // ê²€ì¦
  const parsed = createMeetingSchema.safeParse(body);

  if (!parsed.success) {
    return NextResponse.json(
      {
        error: {
          code: 'INVALID_INPUT',
          message: 'Validation failed',
          details: parsed.error.errors,
        },
      },
      { status: 400 }
    );
  }

  // ...
}
```

---

## 12. ë°°í¬ ë° ëª¨ë‹ˆí„°ë§

### 12.1 í™˜ê²½ ë³€ìˆ˜

```bash
# .env.production
DATABASE_URL="postgresql://..."
REDIS_URL="..."
PINECONE_API_KEY="..."
OPENAI_API_KEY="..."
DEEPGRAM_API_KEY="..."
JWT_SECRET="..."
ENCRYPTION_KEY="..."

# Integrations
NOTION_CLIENT_ID="..."
NOTION_CLIENT_SECRET="..."
SALESFORCE_CLIENT_ID="..."
```

### 12.2 Vercel ë°°í¬

```json
// vercel.json
{
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/next"
    }
  ],
  "env": {
    "DATABASE_URL": "@database-url",
    "OPENAI_API_KEY": "@openai-api-key"
  },
  "regions": ["icn1"]  // ì„œìš¸ ë¦¬ì „
}
```

### 12.3 ëª¨ë‹ˆí„°ë§

```typescript
// src/lib/monitoring.ts
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 0.1,
});

// ì—ëŸ¬ íŠ¸ë˜í‚¹
export function captureError(error: unknown, context?: Record<string, any>) {
  Sentry.captureException(error, { extra: context });
}

// ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
export function trackPerformance(name: string, duration: number) {
  Sentry.metrics.distribution(name, duration, {
    unit: 'millisecond',
  });
}
```

---

**ë¬¸ì„œ ë**

**ìµœì¢… ì—…ë°ì´íŠ¸**: 2025-12-30 (Part 3 HUD ì¸í„°ë™ì…˜ API ì¶”ê°€)

**ë‹¤ìŒ ë‹¨ê³„:**
1. Prisma ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒì„±
2. API ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„
3. AI íŒŒì´í”„ë¼ì¸ í…ŒìŠ¤íŠ¸
4. í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„±
5. ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬
6. í”„ë¡œë•ì…˜ ë°°í¬
7. **Part 3 HUD ì„¸ì…˜ API êµ¬í˜„**: HUDSessionService, ì•Œë¦¼ ì‹œìŠ¤í…œ, Gap ë¶„ì„, ì—°ê¸° í•­ëª© ê´€ë¦¬
